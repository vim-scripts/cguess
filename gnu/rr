# 1 "<stdin>"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "<stdin>"
# 1 "/usr/include/gtk++/gtkwindows.hpp" 1 3 4
# 34 "/usr/include/gtk++/gtkwindows.hpp" 3 4
# 1 "/usr/include/gtk++/gtkbins.hpp" 1 3 4
# 51 "/usr/include/gtk++/gtkbins.hpp" 3 4
# 1 "/usr/include/gtk++/gtkcontainers.hpp" 1 3 4
# 49 "/usr/include/gtk++/gtkcontainers.hpp" 3 4
# 1 "/usr/include/gtk++/gtkwidgets.hpp" 1 3 4
# 43 "/usr/include/gtk++/gtkwidgets.hpp" 3 4
# 1 "/usr/include/gtk++/gtkobjects.hpp" 1 3 4
# 46 "/usr/include/gtk++/gtkobjects.hpp" 3 4
# 1 "/usr/include/gtk++/gtktypedefs.hpp" 1 3 4
# 43 "/usr/include/gtk++/gtktypedefs.hpp" 3 4
# 1 "/usr/include/gtk++/gtypedefs.hpp" 1 3 4
# 35 "/usr/include/gtk++/gtypedefs.hpp" 3 4
# 1 "/usr/include/c++/3.3/string" 1 3 4
# 43 "/usr/include/c++/3.3/string" 3 4
       
# 44 "/usr/include/c++/3.3/string" 3

# 1 "/usr/include/c++/3.3/i486-linux/bits/c++config.h" 1 3
# 35 "/usr/include/c++/3.3/i486-linux/bits/c++config.h" 3
# 1 "/usr/include/c++/3.3/i486-linux/bits/os_defines.h" 1 3
# 39 "/usr/include/c++/3.3/i486-linux/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 295 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 296 "/usr/include/features.h" 2 3 4
# 318 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 319 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/c++/3.3/i486-linux/bits/os_defines.h" 2 3
# 36 "/usr/include/c++/3.3/i486-linux/bits/c++config.h" 2 3
# 46 "/usr/include/c++/3.3/string" 2 3
# 1 "/usr/include/c++/3.3/bits/stringfwd.h" 1 3
# 42 "/usr/include/c++/3.3/bits/stringfwd.h" 3
       
# 43 "/usr/include/c++/3.3/bits/stringfwd.h" 3



namespace std
{
  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;

}
# 47 "/usr/include/c++/3.3/string" 2 3
# 1 "/usr/include/c++/3.3/bits/char_traits.h" 1 3
# 43 "/usr/include/c++/3.3/bits/char_traits.h" 3
       
# 44 "/usr/include/c++/3.3/bits/char_traits.h" 3

# 1 "/usr/include/c++/3.3/cstring" 1 3
# 47 "/usr/include/c++/3.3/cstring" 3
       
# 48 "/usr/include/c++/3.3/cstring" 3

# 1 "/usr/include/c++/3.3/cstddef" 1 3
# 46 "/usr/include/c++/3.3/cstddef" 3
       
# 47 "/usr/include/c++/3.3/cstddef" 3

# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3
# 151 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 3
typedef int ptrdiff_t;
# 213 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 3
typedef unsigned int size_t;
# 325 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 3
typedef long int wchar_t;
# 49 "/usr/include/c++/3.3/cstddef" 2 3

namespace std
{
  using ::ptrdiff_t;
  using ::size_t;
}
# 50 "/usr/include/c++/3.3/cstring" 2 3

# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void * __dest,
                     const void * __src, size_t __n) ;


extern void *memmove (void *__dest, const void *__src, size_t __n)
     ;






extern void *memccpy (void * __dest, const void * __src,
                      int __c, size_t __n)
     ;





extern void *memset (void *__s, int __c, size_t __n) ;


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     ;


extern void *memchr (const void *__s, int __c, size_t __n)
      ;





extern void *rawmemchr (const void *__s, int __c) ;


extern void *memrchr (const void *__s, int __c, size_t __n)
      ;





extern char *strcpy (char * __dest, const char * __src)
     ;

extern char *strncpy (char * __dest,
                      const char * __src, size_t __n) ;


extern char *strcat (char * __dest, const char * __src)
     ;

extern char *strncat (char * __dest, const char * __src,
                      size_t __n) ;


extern int strcmp (const char *__s1, const char *__s2)
     ;

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     ;


extern int strcoll (const char *__s1, const char *__s2)
     ;

extern size_t strxfrm (char * __dest,
                       const char * __src, size_t __n) ;






# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;
# 115 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     ;

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
                         __locale_t __l) ;




extern char *strdup (const char *__s) ;






extern char *strndup (const char *__string, size_t __n)
     ;
# 160 "/usr/include/string.h" 3 4


extern char *strchr (const char *__s, int __c) ;

extern char *strrchr (const char *__s, int __c) ;





extern char *strchrnul (const char *__s, int __c) ;





extern size_t strcspn (const char *__s, const char *__reject)
     ;


extern size_t strspn (const char *__s, const char *__accept)
     ;

extern char *strpbrk (const char *__s, const char *__accept)
     ;

extern char *strstr (const char *__haystack, const char *__needle)
     ;



extern char *strtok (char * __s, const char * __delim)
     ;




extern char *__strtok_r (char * __s,
                         const char * __delim,
                         char ** __save_ptr) ;

extern char *strtok_r (char * __s, const char * __delim,
                       char ** __save_ptr) ;




extern char *strcasestr (const char *__haystack, const char *__needle)
     ;






extern void *memmem (const void *__haystack, size_t __haystacklen,
                     const void *__needle, size_t __needlelen)
     ;



extern void *__mempcpy (void * __dest,
                        const void * __src, size_t __n) ;
extern void *mempcpy (void * __dest,
                      const void * __src, size_t __n) ;





extern size_t strlen (const char *__s) ;





extern size_t strnlen (const char *__string, size_t __maxlen)
     ;





extern char *strerror (int __errnum) ;




extern char *strerror_r (int __errnum, char *__buf, size_t __buflen) ;




extern void __bzero (void *__s, size_t __n) ;



extern void bcopy (const void *__src, void *__dest, size_t __n) ;


extern void bzero (void *__s, size_t __n) ;


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     ;


extern char *index (const char *__s, int __c) ;


extern char *rindex (const char *__s, int __c) ;



extern int ffs (int __i) ;




extern int ffsl (long int __l) ;







extern int strcasecmp (const char *__s1, const char *__s2)
     ;


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     ;





extern int strcasecmp_l (const char *__s1, const char *__s2,
                         __locale_t __loc) ;

extern int strncasecmp_l (const char *__s1, const char *__s2,
                          size_t __n, __locale_t __loc)
     ;





extern char *strsep (char ** __stringp,
                     const char * __delim) ;




extern int strverscmp (const char *__s1, const char *__s2)
     ;


extern char *strsignal (int __sig) ;


extern char *__stpcpy (char * __dest, const char * __src)
     ;
extern char *stpcpy (char * __dest, const char * __src)
     ;



extern char *__stpncpy (char * __dest,
                        const char * __src, size_t __n) ;
extern char *stpncpy (char * __dest,
                      const char * __src, size_t __n) ;


extern char *strfry (char *__string) ;


extern void *memfrob (void *__s, size_t __n) ;






extern char *basename (const char *__filename) ;
# 379 "/usr/include/string.h" 3 4

# 52 "/usr/include/c++/3.3/cstring" 2 3
# 77 "/usr/include/c++/3.3/cstring" 3
namespace std
{
  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
}
# 46 "/usr/include/c++/3.3/bits/char_traits.h" 2 3
# 1 "/usr/include/c++/3.3/bits/fpos.h" 1 3
# 42 "/usr/include/c++/3.3/bits/fpos.h" 3
       
# 43 "/usr/include/c++/3.3/bits/fpos.h" 3

# 1 "/usr/include/c++/3.3/i486-linux/bits/c++io.h" 1 3
# 35 "/usr/include/c++/3.3/i486-linux/bits/c++io.h" 3
# 1 "/usr/include/c++/3.3/cstdio" 1 3
# 47 "/usr/include/c++/3.3/cstdio" 3
       
# 48 "/usr/include/c++/3.3/cstdio" 3




# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 32 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 63 "/usr/include/bits/types.h" 3 4
typedef struct
{
  long __val[2];
} __quad_t;
typedef struct
{
  __u_long __val[2];
} __u_quad_t;
# 128 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 129 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long int __off_t;
typedef long long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef int __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long long int __fsfilcnt64_t;




typedef int __ssize_t;
typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef int __intptr_t;


typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4









typedef struct _IO_FILE FILE;





# 62 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 72 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 14 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 354 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 15 "/usr/include/_G_config.h" 2 3 4
# 24 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 51 "/usr/include/wchar.h" 2 3 4
# 76 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 25 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 44 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/gconv.h" 1 3 4
# 28 "/usr/include/gconv.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 29 "/usr/include/gconv.h" 2 3 4


# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 32 "/usr/include/gconv.h" 2 3 4





enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};



enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};



struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;



typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
                            const unsigned char **, const unsigned char *,
                            unsigned char **, size_t *, int, int);


typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);


typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);



typedef int (*__gconv_trans_fct) (struct __gconv_step *,
                                  struct __gconv_step_data *, void *,
                                  const unsigned char *,
                                  const unsigned char **,
                                  const unsigned char *, unsigned char **,
                                  size_t *);


typedef int (*__gconv_trans_context_fct) (void *, const unsigned char *,
                                          const unsigned char *,
                                          unsigned char *, unsigned char *);


typedef int (*__gconv_trans_query_fct) (const char *, const char ***,
                                        size_t *);


typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{

  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};



struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;



  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;


  int __stateful;

  void *__data;
};



struct __gconv_step_data
{
  unsigned char *__outbuf;
  unsigned char *__outbufend;



  int __flags;



  int __invocation_counter;



  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;



  struct __gconv_trans_data *__trans;
};



typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  struct __gconv_step_data __data [1];
} *__gconv_t;
# 45 "/usr/include/_G_config.h" 2 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t ;
typedef int _G_int32_t ;
typedef unsigned int _G_uint16_t ;
typedef unsigned int _G_uint32_t ;
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stdarg.h" 1 3 4
# 43 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4
# 162 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 172 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 195 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};




struct _IO_codecvt
{
  void (*__codecvt_destr) (struct _IO_codecvt *);
  enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *,
                                             __mbstate_t *,
                                             const wchar_t *,
                                             const wchar_t *,
                                             const wchar_t **, char *,
                                             char *, char **);
  enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *,
                                                 __mbstate_t *, char *,
                                                 char *, char **);
  enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *,
                                            __mbstate_t *,
                                            const char *, const char *,
                                            const char **, wchar_t *,
                                            wchar_t *, wchar_t **);
  int (*__codecvt_do_encoding) (struct _IO_codecvt *);
  int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);
  int (*__codecvt_do_length) (struct _IO_codecvt *, __mbstate_t *,
                              const char *, const char *, size_t);
  int (*__codecvt_do_max_length) (struct _IO_codecvt *);

  _G_iconv_t __cd_in;
  _G_iconv_t __cd_out;
};


struct _IO_wide_data
{
  wchar_t *_IO_read_ptr;
  wchar_t *_IO_read_end;
  wchar_t *_IO_read_base;
  wchar_t *_IO_write_base;
  wchar_t *_IO_write_ptr;
  wchar_t *_IO_write_end;
  wchar_t *_IO_buf_base;
  wchar_t *_IO_buf_end;

  wchar_t *_IO_save_base;
  wchar_t *_IO_backup_base;

  wchar_t *_IO_save_end;

  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  struct _IO_codecvt _codecvt;

  wchar_t _shortbuf[1];

  struct _IO_jump_t *_wide_vtable;
};


struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 311 "/usr/include/libio.h" 3 4
  __off64_t _offset;


  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;




  int _mode;

  char _unused2[15 * sizeof (int) - 2 * sizeof (void *)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 350 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
                                 size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
                             void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *) ;
extern int __uflow (_IO_FILE *) ;
extern int __overflow (_IO_FILE *, int) ;
extern wint_t __wunderflow (_IO_FILE *) ;
extern wint_t __wuflow (_IO_FILE *) ;
extern wint_t __woverflow (_IO_FILE *, wint_t) ;
# 432 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp) ;
extern int _IO_putc (int __c, _IO_FILE *__fp) ;
extern int _IO_feof (_IO_FILE *__fp) ;
extern int _IO_ferror (_IO_FILE *__fp) ;

extern int _IO_peekc_locked (_IO_FILE *__fp) ;





extern void _IO_flockfile (_IO_FILE *) ;
extern void _IO_funlockfile (_IO_FILE *) ;
extern int _IO_ftrylockfile (_IO_FILE *) ;
# 462 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * , const char * ,
                        __gnuc_va_list, int *) ;
extern int _IO_vfprintf (_IO_FILE *, const char *,
                         __gnuc_va_list) ;
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t) ;
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t) ;

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int) ;
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int) ;

extern void _IO_free_backup_area (_IO_FILE *) ;


extern wint_t _IO_getwc (_IO_FILE *__fp) ;
extern wint_t _IO_putwc (wchar_t __wc, _IO_FILE *__fp) ;
extern int _IO_fwide (_IO_FILE *__fp, int __mode) ;
# 511 "/usr/include/libio.h" 3 4
extern int _IO_vfwscanf (_IO_FILE * , const wchar_t * ,
                         __gnuc_va_list, int *) ;
extern int _IO_vfwprintf (_IO_FILE *, const wchar_t *,
                          __gnuc_va_list) ;
extern __ssize_t _IO_wpadn (_IO_FILE *, wint_t, __ssize_t) ;
extern void _IO_free_wbackup_area (_IO_FILE *) ;
# 73 "/usr/include/stdio.h" 2 3 4
# 81 "/usr/include/stdio.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stdarg.h" 1 3 4
# 105 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 82 "/usr/include/stdio.h" 2 3 4






typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 138 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 139 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) ;

extern int rename (const char *__old, const char *__new) ;









extern FILE *tmpfile (void);
# 174 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void);



extern char *tmpnam (char *__s) ;





extern char *tmpnam_r (char *__s) ;
# 196 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 221 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 231 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char * __filename,
                    const char * __modes);




extern FILE *freopen (const char * __filename,
                      const char * __modes,
                      FILE * __stream);
# 262 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char * __filename,
                      const char * __modes);
extern FILE *freopen64 (const char * __filename,
                        const char * __modes,
                        FILE * __stream);




extern FILE *fdopen (int __fd, const char *__modes) ;





extern FILE *fopencookie (void * __magic_cookie,
                          const char * __modes,
                          _IO_cookie_io_functions_t __io_funcs) ;


extern FILE *fmemopen (void *__s, size_t __len, const char *__modes) ;




extern FILE *open_memstream (char ** __bufloc,
                             size_t * __sizeloc) ;






extern void setbuf (FILE * __stream, char * __buf) ;



extern int setvbuf (FILE * __stream, char * __buf,
                    int __modes, size_t __n) ;





extern void setbuffer (FILE * __stream, char * __buf,
                       size_t __size) ;


extern void setlinebuf (FILE *__stream) ;








extern int fprintf (FILE * __stream,
                    const char * __format, ...);




extern int printf (const char * __format, ...);

extern int sprintf (char * __s,
                    const char * __format, ...) ;





extern int vfprintf (FILE * __s, const char * __format,
                     __gnuc_va_list __arg);




extern int vprintf (const char * __format, __gnuc_va_list __arg);

extern int vsprintf (char * __s, const char * __format,
                     __gnuc_va_list __arg) ;





extern int snprintf (char * __s, size_t __maxlen,
                     const char * __format, ...)
     ;

extern int vsnprintf (char * __s, size_t __maxlen,
                      const char * __format, __gnuc_va_list __arg)
     ;






extern int vasprintf (char ** __ptr, const char * __f,
                      __gnuc_va_list __arg)
     ;
extern int __asprintf (char ** __ptr,
                       const char * __fmt, ...)
     ;
extern int asprintf (char ** __ptr,
                     const char * __fmt, ...)
     ;







extern int vdprintf (int __fd, const char * __fmt,
                     __gnuc_va_list __arg)
     ;
extern int dprintf (int __fd, const char * __fmt, ...)
     ;








extern int fscanf (FILE * __stream,
                   const char * __format, ...);




extern int scanf (const char * __format, ...);

extern int sscanf (const char * __s,
                   const char * __format, ...) ;








extern int vfscanf (FILE * __s, const char * __format,
                    __gnuc_va_list __arg)
     ;





extern int vscanf (const char * __format, __gnuc_va_list __arg)
     ;


extern int vsscanf (const char * __s,
                    const char * __format, __gnuc_va_list __arg)
     ;









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 454 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 465 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);








extern int fputc (int __c, FILE *__stream) ;
extern int putc (int __c, FILE *__stream) ;





extern int putchar (int __c);

# 495 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream) ;


extern int putw (int __w, FILE *__stream) ;








extern char *fgets (char * __s, int __n, FILE * __stream);






extern char *gets (char *__s);

# 540 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char * __s, int __n,
                             FILE * __stream);
# 556 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char ** __lineptr,
                               size_t * __n, int __delimiter,
                               FILE * __stream);
extern __ssize_t getdelim (char ** __lineptr,
                             size_t * __n, int __delimiter,
                             FILE * __stream);







extern __ssize_t getline (char ** __lineptr,
                            size_t * __n,
                            FILE * __stream);








extern int fputs (const char * __s, FILE * __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void * __ptr, size_t __size,
                     size_t __n, FILE * __stream);




extern size_t fwrite (const void * __ptr, size_t __size,
                      size_t __n, FILE * __s);

# 617 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char * __s,
                           FILE * __stream);
# 628 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void * __ptr, size_t __size,
                              size_t __n, FILE * __stream) ;
extern size_t fwrite_unlocked (const void * __ptr, size_t __size,
                               size_t __n, FILE * __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream);




extern void rewind (FILE *__stream);

# 664 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream);
# 683 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE * __stream, fpos_t * __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 706 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream);
extern int fgetpos64 (FILE * __stream, fpos64_t * __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) ;

extern int feof (FILE *__stream) ;

extern int ferror (FILE *__stream) ;




extern void clearerr_unlocked (FILE *__stream) ;
extern int feof_unlocked (FILE *__stream) ;
extern int ferror_unlocked (FILE *__stream) ;








extern void perror (const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 745 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) ;




extern int fileno_unlocked (FILE *__stream) ;






extern FILE *popen (const char *__command, const char *__modes) ;


extern int pclose (FILE *__stream) ;





extern char *ctermid (char *__s) ;





extern char *cuserid (char *__s) ;




struct obstack;


extern int obstack_printf (struct obstack * __obstack,
                           const char * __format, ...)
     ;
extern int obstack_vprintf (struct obstack * __obstack,
                            const char * __format,
                            __gnuc_va_list __args)
     ;







extern void flockfile (FILE *__stream) ;



extern int ftrylockfile (FILE *__stream) ;


extern void funlockfile (FILE *__stream) ;
# 822 "/usr/include/stdio.h" 3 4

# 53 "/usr/include/c++/3.3/cstdio" 2 3
# 97 "/usr/include/c++/3.3/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 153 "/usr/include/c++/3.3/cstdio" 3
namespace __gnu_cxx
{
# 167 "/usr/include/c++/3.3/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using __gnu_cxx::snprintf;
  using __gnu_cxx::vfscanf;
  using __gnu_cxx::vscanf;
  using __gnu_cxx::vsnprintf;
  using __gnu_cxx::vsscanf;
}
# 36 "/usr/include/c++/3.3/i486-linux/bits/c++io.h" 2 3

# 1 "/usr/include/c++/3.3/i486-linux/bits/gthr.h" 1 3
# 98 "/usr/include/c++/3.3/i486-linux/bits/gthr.h" 3
# 1 "/usr/include/c++/3.3/i486-linux/bits/gthr-default.h" 1 3
# 37 "/usr/include/c++/3.3/i486-linux/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 20 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 118 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 30 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/bits/sched.h" 1 3 4
# 61 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };





extern int clone (int (*__fn) (void *__arg), void *__child_stack,
                  int __flags, void *__arg) ;










struct __sched_param
  {
    int __sched_priority;
  };
# 97 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 33 "/usr/include/sched.h" 2 3 4







extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     ;


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) ;


extern int sched_setscheduler (__pid_t __pid, int __policy,
                               const struct sched_param *__param) ;


extern int sched_getscheduler (__pid_t __pid) ;


extern int sched_yield (void) ;


extern int sched_get_priority_max (int __algorithm) ;


extern int sched_get_priority_min (int __algorithm) ;


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) ;
# 76 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, const cpu_set_t *__mask)
     ;


extern int sched_getaffinity (__pid_t __pid, cpu_set_t *__mask) ;



# 21 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 43 "/usr/include/time.h" 2 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 129 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;








extern clock_t clock (void) ;


extern time_t time (time_t *__timer) ;


extern double difftime (time_t __time1, time_t __time0)
     ;


extern time_t mktime (struct tm *__tp) ;





extern size_t strftime (char * __s, size_t __maxsize,
                        const char * __format,
                        const struct tm * __tp) ;





extern char *strptime (const char * __s,
                       const char * __fmt, struct tm *__tp)
     ;







extern size_t strftime_l (char * __s, size_t __maxsize,
                          const char * __format,
                          const struct tm * __tp,
                          __locale_t __loc) ;

extern char *strptime_l (const char * __s,
                         const char * __fmt, struct tm *__tp,
                         __locale_t __loc) ;






extern struct tm *gmtime (const time_t *__timer) ;



extern struct tm *localtime (const time_t *__timer) ;





extern struct tm *gmtime_r (const time_t * __timer,
                            struct tm * __tp) ;



extern struct tm *localtime_r (const time_t * __timer,
                               struct tm * __tp) ;





extern char *asctime (const struct tm *__tp) ;


extern char *ctime (const time_t *__timer) ;







extern char *asctime_r (const struct tm * __tp,
                        char * __buf) ;


extern char *ctime_r (const time_t * __timer,
                      char * __buf) ;




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) ;



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) ;
# 309 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) ;


extern time_t timelocal (struct tm *__tp) ;


extern int dysize (int __year) ;
# 324 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
                      struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) ;


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) ;


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     ;






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
                            const struct timespec *__req,
                            struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) ;




extern int timer_create (clockid_t __clock_id,
                         struct sigevent * __evp,
                         timer_t * __timerid) ;


extern int timer_delete (timer_t __timerid) ;


extern int timer_settime (timer_t __timerid, int __flags,
                          const struct itimerspec * __value,
                          struct itimerspec * __ovalue) ;


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     ;


extern int timer_getoverrun (timer_t __timerid) ;
# 386 "/usr/include/time.h" 3 4
extern int getdate_err;
# 395 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 409 "/usr/include/time.h" 3 4
extern int getdate_r (const char * __string,
                      struct tm * __resbufp);



# 22 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/signal.h" 2 3 4
# 50 "/usr/include/signal.h" 3 4
typedef __sigset_t sigset_t;
# 392 "/usr/include/signal.h" 3 4

# 25 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4

typedef int __atomic_lock_t;


struct _pthread_fastlock
{
  long int __status;
  __atomic_lock_t __spinlock;

};



typedef struct _pthread_descr_struct *_pthread_descr;





typedef struct __pthread_attr_s
{
  int __detachstate;
  int __schedpolicy;
  struct __sched_param __schedparam;
  int __inheritsched;
  int __scope;
  size_t __guardsize;
  int __stackaddr_set;
  void *__stackaddr;
  size_t __stacksize;
} pthread_attr_t;







typedef long __pthread_cond_align_t;


typedef struct
{
  struct _pthread_fastlock __c_lock;
  _pthread_descr __c_waiting;
  char __padding[48 - sizeof (struct _pthread_fastlock)
                 - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
  __pthread_cond_align_t __align;
} pthread_cond_t;



typedef struct
{
  int __dummy;
} pthread_condattr_t;


typedef unsigned int pthread_key_t;





typedef struct
{
  int __m_reserved;
  int __m_count;
  _pthread_descr __m_owner;
  int __m_kind;
  struct _pthread_fastlock __m_lock;
} pthread_mutex_t;



typedef struct
{
  int __mutexkind;
} pthread_mutexattr_t;



typedef int pthread_once_t;




typedef struct _pthread_rwlock_t
{
  struct _pthread_fastlock __rw_lock;
  int __rw_readers;
  _pthread_descr __rw_writer;
  _pthread_descr __rw_read_waiting;
  _pthread_descr __rw_write_waiting;
  int __rw_kind;
  int __rw_pshared;
} pthread_rwlock_t;



typedef struct
{
  int __lockkind;
  int __pshared;
} pthread_rwlockattr_t;




typedef volatile int pthread_spinlock_t;


typedef struct {
  struct _pthread_fastlock __ba_lock;
  int __ba_required;
  int __ba_present;
  _pthread_descr __ba_waiting;
} pthread_barrier_t;


typedef struct {
  int __pshared;
} pthread_barrierattr_t;





typedef unsigned long int pthread_t;
# 26 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/initspin.h" 1 3 4
# 27 "/usr/include/pthread.h" 2 3 4



# 59 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};

enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};

enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};

enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_ADAPTIVE_NP

};

enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};


enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_WRITER_NP
};
# 131 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};



enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 163 "/usr/include/pthread.h" 3 4
extern int pthread_create (pthread_t * __threadp,
                           const pthread_attr_t * __attr,
                           void *(*__start_routine) (void *),
                           void * __arg) ;


extern pthread_t pthread_self (void) ;


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) ;


extern void pthread_exit (void *__retval)
     ;




extern int pthread_join (pthread_t __th, void **__thread_return) ;





extern int pthread_detach (pthread_t __th) ;







extern int pthread_attr_init (pthread_attr_t *__attr) ;


extern int pthread_attr_destroy (pthread_attr_t *__attr) ;


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
                                        int __detachstate) ;


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
                                        int *__detachstate) ;


extern int pthread_attr_setschedparam (pthread_attr_t * __attr,
                                       const struct sched_param *
                                       __param) ;


extern int pthread_attr_getschedparam (const pthread_attr_t *
                                       __attr,
                                       struct sched_param * __param)
     ;


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     ;


extern int pthread_attr_getschedpolicy (const pthread_attr_t *
                                        __attr, int * __policy)
     ;


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
                                         int __inherit) ;


extern int pthread_attr_getinheritsched (const pthread_attr_t *
                                         __attr, int * __inherit)
     ;


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     ;


extern int pthread_attr_getscope (const pthread_attr_t * __attr,
                                  int * __scope) ;



extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
                                      size_t __guardsize) ;


extern int pthread_attr_getguardsize (const pthread_attr_t *
                                      __attr, size_t * __guardsize)
     ;






extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
                                      void *__stackaddr) ;


extern int pthread_attr_getstackaddr (const pthread_attr_t *
                                      __attr, void ** __stackaddr)
     ;





extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
                                  size_t __stacksize) ;


extern int pthread_attr_getstack (const pthread_attr_t * __attr,
                                  void ** __stackaddr,
                                  size_t * __stacksize) ;





extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
                                      size_t __stacksize) ;


extern int pthread_attr_getstacksize (const pthread_attr_t *
                                      __attr, size_t * __stacksize)
     ;



extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr) ;






extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
                                  const struct sched_param *__param)
     ;


extern int pthread_getschedparam (pthread_t __target_thread,
                                  int * __policy,
                                  struct sched_param * __param)
     ;



extern int pthread_getconcurrency (void) ;


extern int pthread_setconcurrency (int __level) ;







extern int pthread_yield (void) ;






extern int pthread_mutex_init (pthread_mutex_t * __mutex,
                               const pthread_mutexattr_t *
                               __mutex_attr) ;


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex) ;


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex) ;


extern int pthread_mutex_lock (pthread_mutex_t *__mutex) ;



extern int pthread_mutex_timedlock (pthread_mutex_t * __mutex,
                                    const struct timespec *
                                    __abstime) ;



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex) ;






extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr) ;


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr) ;


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
                                         __attr,
                                         int * __pshared) ;


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
                                         int __pshared) ;





extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     ;


extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *
                                      __attr, int * __kind) ;







extern int pthread_cond_init (pthread_cond_t * __cond,
                              const pthread_condattr_t *
                              __cond_attr) ;


extern int pthread_cond_destroy (pthread_cond_t *__cond) ;


extern int pthread_cond_signal (pthread_cond_t *__cond) ;


extern int pthread_cond_broadcast (pthread_cond_t *__cond) ;



extern int pthread_cond_wait (pthread_cond_t * __cond,
                              pthread_mutex_t * __mutex) ;





extern int pthread_cond_timedwait (pthread_cond_t * __cond,
                                   pthread_mutex_t * __mutex,
                                   const struct timespec *
                                   __abstime) ;




extern int pthread_condattr_init (pthread_condattr_t *__attr) ;


extern int pthread_condattr_destroy (pthread_condattr_t *__attr) ;


extern int pthread_condattr_getpshared (const pthread_condattr_t *
                                        __attr,
                                        int * __pshared) ;


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
                                        int __pshared) ;







extern int pthread_rwlock_init (pthread_rwlock_t * __rwlock,
                                const pthread_rwlockattr_t *
                                __attr) ;


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock) ;


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock) ;


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock) ;



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t * __rwlock,
                                       const struct timespec *
                                       __abstime) ;



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock) ;


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock) ;



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t * __rwlock,
                                       const struct timespec *
                                       __abstime) ;



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock) ;





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr) ;


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr) ;


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
                                          __attr,
                                          int * __pshared) ;


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
                                          int __pshared) ;


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *__attr,
                                          int *__pref) ;


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
                                          int __pref) ;
# 509 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     ;


extern int pthread_spin_destroy (pthread_spinlock_t *__lock) ;


extern int pthread_spin_lock (pthread_spinlock_t *__lock) ;


extern int pthread_spin_trylock (pthread_spinlock_t *__lock) ;


extern int pthread_spin_unlock (pthread_spinlock_t *__lock) ;




extern int pthread_barrier_init (pthread_barrier_t * __barrier,
                                 const pthread_barrierattr_t *
                                 __attr, unsigned int __count) ;

extern int pthread_barrier_destroy (pthread_barrier_t *__barrier) ;

extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr) ;

extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr) ;

extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
                                           __attr,
                                           int * __pshared) ;

extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
                                           int __pshared) ;

extern int pthread_barrier_wait (pthread_barrier_t *__barrier) ;
# 556 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
                               void (*__destr_function) (void *)) ;


extern int pthread_key_delete (pthread_key_t __key) ;


extern int pthread_setspecific (pthread_key_t __key,
                                const void *__pointer) ;


extern void *pthread_getspecific (pthread_key_t __key) ;
# 576 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
                         void (*__init_routine) (void)) ;






extern int pthread_setcancelstate (int __state, int *__oldstate) ;



extern int pthread_setcanceltype (int __type, int *__oldtype) ;


extern int pthread_cancel (pthread_t __cancelthread) ;




extern void pthread_testcancel (void) ;
# 610 "/usr/include/pthread.h" 3 4
extern void _pthread_cleanup_push (struct _pthread_cleanup_buffer *__buffer,
                                   void (*__routine) (void *),
                                   void *__arg) ;







extern void _pthread_cleanup_pop (struct _pthread_cleanup_buffer *__buffer,
                                  int __execute) ;
# 631 "/usr/include/pthread.h" 3 4
extern void _pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *__buffer,
                                         void (*__routine) (void *),
                                         void *__arg) ;
# 642 "/usr/include/pthread.h" 3 4
extern void _pthread_cleanup_pop_restore (struct _pthread_cleanup_buffer *__buffer,
                                          int __execute) ;





extern int pthread_getcpuclockid (pthread_t __thread_id,
                                  clockid_t *__clock_id) ;




# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
                            const __sigset_t * __newmask,
                            __sigset_t * __oldmask);


extern int pthread_kill (pthread_t __threadid, int __signo) ;
# 656 "/usr/include/pthread.h" 2 3 4
# 671 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
                           void (*__parent) (void),
                           void (*__child) (void)) ;




extern void pthread_kill_other_threads_np (void) ;


# 38 "/usr/include/c++/3.3/i486-linux/bits/gthr-default.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4

# 171 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 172 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/environments.h" 2 3 4
# 176 "/usr/include/unistd.h" 2 3 4
# 189 "/usr/include/unistd.h" 3 4
typedef __ssize_t ssize_t;





# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 196 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __useconds_t useconds_t;
# 236 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 256 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) ;




extern int euidaccess (const char *__name, int __type) ;
# 286 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) ;
# 298 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence) ;






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes);





extern ssize_t write (int __fd, const void *__buf, size_t __n);
# 328 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
                      __off_t __offset);






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
                       __off_t __offset);
# 356 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
                        __off64_t __offset);


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
                         __off64_t __offset);







extern int pipe (int __pipedes[2]) ;
# 378 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) ;
# 390 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     ;






extern int usleep (__useconds_t __useconds);
# 414 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     ;




extern int chdir (const char *__path) ;



extern int fchdir (int __fd) ;
# 448 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) ;





extern char *get_current_dir_name (void) ;






extern char *getwd (char *__buf) ;




extern int dup (int __fd) ;


extern int dup2 (int __fd, int __fd2) ;


extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
                   char *const __envp[]) ;




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     ;




extern int execv (const char *__path, char *const __argv[]) ;



extern int execle (const char *__path, const char *__arg, ...) ;



extern int execl (const char *__path, const char *__arg, ...) ;



extern int execvp (const char *__file, char *const __argv[]) ;




extern int execlp (const char *__file, const char *__arg, ...) ;




extern int nice (int __inc) ;




extern void _exit (int __status) ;





# 1 "/usr/include/bits/confname.h" 1 3 4
# 25 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,


    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

  };
# 526 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name) ;


extern long int fpathconf (int __fd, int __name) ;


extern long int sysconf (int __name) ;



extern size_t confstr (int __name, char *__buf, size_t __len) ;




extern __pid_t getpid (void) ;


extern __pid_t getppid (void) ;




extern __pid_t getpgrp (void) ;
# 561 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) ;

extern __pid_t getpgid (__pid_t __pid) ;






extern int setpgid (__pid_t __pid, __pid_t __pgid) ;
# 587 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) ;
# 605 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) ;



extern __pid_t getsid (__pid_t __pid) ;



extern __uid_t getuid (void) ;


extern __uid_t geteuid (void) ;


extern __gid_t getgid (void) ;


extern __gid_t getegid (void) ;




extern int getgroups (int __size, __gid_t __list[]) ;



extern int group_member (__gid_t __gid) ;






extern int setuid (__uid_t __uid) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) ;




extern int seteuid (__uid_t __uid) ;






extern int setgid (__gid_t __gid) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) ;




extern int setegid (__gid_t __gid) ;





extern int getresuid (__uid_t *__euid, __uid_t *__ruid, __uid_t *__suid);



extern int getresgid (__gid_t *__egid, __gid_t *__rgid, __gid_t *__sgid);



extern int setresuid (__uid_t __euid, __uid_t __ruid, __uid_t __suid);



extern int setresgid (__gid_t __egid, __gid_t __rgid, __gid_t __sgid);






extern __pid_t fork (void) ;






extern __pid_t vfork (void) ;





extern char *ttyname (int __fd) ;



extern int ttyname_r (int __fd, char *__buf, size_t __buflen) ;



extern int isatty (int __fd) ;





extern int ttyslot (void) ;




extern int link (const char *__from, const char *__to) ;



extern int symlink (const char *__from, const char *__to) ;




extern int readlink (const char * __path, char * __buf,
                     size_t __len) ;



extern int unlink (const char *__name) ;


extern int rmdir (const char *__path) ;



extern __pid_t tcgetpgrp (int __fd) ;


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) ;






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len);




extern int setlogin (const char *__name) ;
# 775 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 47 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 61 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 145 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts);
# 776 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) ;






extern int sethostname (const char *__name, size_t __len) ;



extern int sethostid (long int __id) ;





extern int getdomainname (char *__name, size_t __len) ;
extern int setdomainname (const char *__name, size_t __len) ;





extern int vhangup (void) ;


extern int revoke (const char *__file) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
                   size_t __offset, unsigned int __scale) ;





extern int acct (const char *__name) ;



extern char *getusershell (void) ;
extern void endusershell (void) ;
extern void setusershell (void) ;





extern int daemon (int __nochdir, int __noclose) ;






extern int chroot (const char *__path) ;



extern char *getpass (const char *__prompt) ;
# 857 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void) ;


extern void sync (void) ;




extern int getpagesize (void) ;




extern int truncate (const char *__file, __off_t __length) ;
# 888 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length) ;




extern int ftruncate (int __fd, __off_t __length) ;
# 903 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) ;





extern int getdtablesize (void) ;
# 918 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) ;





extern void *sbrk (intptr_t __delta) ;
# 939 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) ;
# 962 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len);
# 972 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len);
# 993 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes) ;







extern char *crypt (const char *__key, const char *__salt) ;



extern void encrypt (char *__block, int __edflag) ;






extern void swab (const void * __from, void * __to,
                  ssize_t __n) ;







extern char *ctermid (char *__s) ;



# 39 "/usr/include/c++/3.3/i486-linux/bits/gthr-default.h" 2 3

typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
# 96 "/usr/include/c++/3.3/i486-linux/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 449 "/usr/include/c++/3.3/i486-linux/bits/gthr-default.h" 3
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return pthread_key_create (key, dtor);
}

static inline int
__gthread_key_dtor (__gthread_key_t key, void *ptr)
{

  if (ptr)
    return pthread_setspecific (key, 0);
  else
    return 0;
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return pthread_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return pthread_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return pthread_setspecific (key, ptr);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (mutex);
  else
    return 0;
}
# 99 "/usr/include/c++/3.3/i486-linux/bits/gthr.h" 2 3
# 38 "/usr/include/c++/3.3/i486-linux/bits/c++io.h" 2 3

namespace std
{

  typedef long streamoff;
  typedef ptrdiff_t streamsize;

  typedef ptrdiff_t wstreamsize;

  typedef fpos_t __c_streampos;

  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


  struct __ios_flags
  {
    typedef short __int_type;

    static const __int_type _S_boolalpha = 0x0001;
    static const __int_type _S_dec = 0x0002;
    static const __int_type _S_fixed = 0x0004;
    static const __int_type _S_hex = 0x0008;
    static const __int_type _S_internal = 0x0010;
    static const __int_type _S_left = 0x0020;
    static const __int_type _S_oct = 0x0040;
    static const __int_type _S_right = 0x0080;
    static const __int_type _S_scientific = 0x0100;
    static const __int_type _S_showbase = 0x0200;
    static const __int_type _S_showpoint = 0x0400;
    static const __int_type _S_showpos = 0x0800;
    static const __int_type _S_skipws = 0x1000;
    static const __int_type _S_unitbuf = 0x2000;
    static const __int_type _S_uppercase = 0x4000;
    static const __int_type _S_adjustfield = 0x0020 | 0x0080 | 0x0010;
    static const __int_type _S_basefield = 0x0002 | 0x0040 | 0x0008;
    static const __int_type _S_floatfield = 0x0100 | 0x0004;


    static const __int_type _S_badbit = 0x01;
    static const __int_type _S_eofbit = 0x02;
    static const __int_type _S_failbit = 0x04;


    static const __int_type _S_app = 0x01;
    static const __int_type _S_ate = 0x02;
    static const __int_type _S_bin = 0x04;
    static const __int_type _S_in = 0x08;
    static const __int_type _S_out = 0x10;
    static const __int_type _S_trunc = 0x20;
  };
}
# 45 "/usr/include/c++/3.3/bits/fpos.h" 2 3
# 1 "/usr/include/c++/3.3/cwchar" 1 3
# 47 "/usr/include/c++/3.3/cwchar" 3
       
# 48 "/usr/include/c++/3.3/cwchar" 3



# 1 "/usr/include/c++/3.3/ctime" 1 3
# 47 "/usr/include/c++/3.3/ctime" 3
       
# 48 "/usr/include/c++/3.3/ctime" 3
# 64 "/usr/include/c++/3.3/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 52 "/usr/include/c++/3.3/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 93 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



# 118 "/usr/include/wchar.h" 3 4





struct tm;









extern wchar_t *wcscpy (wchar_t * __dest,
                        const wchar_t * __src) ;

extern wchar_t *wcsncpy (wchar_t * __dest,
                         const wchar_t * __src, size_t __n)
     ;


extern wchar_t *wcscat (wchar_t * __dest,
                        const wchar_t * __src) ;

extern wchar_t *wcsncat (wchar_t * __dest,
                         const wchar_t * __src, size_t __n)
     ;


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     ;

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     ;




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) ;


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
                        size_t __n) ;





extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
                         __locale_t __loc) ;

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
                          size_t __n, __locale_t __loc) ;





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) ;



extern size_t wcsxfrm (wchar_t * __s1,
                       const wchar_t * __s2, size_t __n) ;








extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
                      __locale_t __loc) ;




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
                         size_t __n, __locale_t __loc) ;


extern wchar_t *wcsdup (const wchar_t *__s) ;




extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     ;

extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     ;





extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     ;





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     ;


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     ;

extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     ;

extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     ;


extern wchar_t *wcstok (wchar_t * __s,
                        const wchar_t * __delim,
                        wchar_t ** __ptr) ;


extern size_t wcslen (const wchar_t *__s) ;




extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     ;




extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     ;





extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     ;


extern int wmemcmp (const wchar_t * __s1,
                    const wchar_t * __s2, size_t __n)
     ;


extern wchar_t *wmemcpy (wchar_t * __s1,
                         const wchar_t * __s2, size_t __n) ;



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     ;


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) ;





extern wchar_t *wmempcpy (wchar_t * __s1,
                          const wchar_t * __s2, size_t __n)
     ;






extern wint_t btowc (int __c) ;



extern int wctob (wint_t __c) ;



extern int mbsinit (const mbstate_t *__ps) ;



extern size_t mbrtowc (wchar_t * __pwc,
                       const char * __s, size_t __n,
                       mbstate_t *__p) ;


extern size_t wcrtomb (char * __s, wchar_t __wc,
                       mbstate_t * __ps) ;


extern size_t __mbrlen (const char * __s, size_t __n,
                        mbstate_t * __ps) ;
extern size_t mbrlen (const char * __s, size_t __n,
                      mbstate_t * __ps) ;

# 329 "/usr/include/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t * __dst,
                         const char ** __src, size_t __len,
                         mbstate_t * __ps) ;



extern size_t wcsrtombs (char * __dst,
                         const wchar_t ** __src, size_t __len,
                         mbstate_t * __ps) ;






extern size_t mbsnrtowcs (wchar_t * __dst,
                          const char ** __src, size_t __nmc,
                          size_t __len, mbstate_t * __ps) ;



extern size_t wcsnrtombs (char * __dst,
                          const wchar_t ** __src,
                          size_t __nwc, size_t __len,
                          mbstate_t * __ps) ;






extern int wcwidth (wchar_t __c) ;



extern int wcswidth (const wchar_t *__s, size_t __n) ;






extern double wcstod (const wchar_t * __nptr,
                      wchar_t ** __endptr) ;



extern float wcstof (const wchar_t * __nptr,
                     wchar_t ** __endptr) ;
extern long double wcstold (const wchar_t * __nptr,
                            wchar_t ** __endptr) ;





extern long int wcstol (const wchar_t * __nptr,
                        wchar_t ** __endptr, int __base) ;



extern unsigned long int wcstoul (const wchar_t * __nptr,
                                  wchar_t ** __endptr, int __base)
     ;





extern long long int wcstoll (const wchar_t * __nptr,
                              wchar_t ** __endptr, int __base)
     ;




extern unsigned long long int wcstoull (const wchar_t * __nptr,
                                        wchar_t ** __endptr,
                                        int __base) ;


# 448 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t * __nptr,
                          wchar_t ** __endptr, int __base,
                          __locale_t __loc) ;

extern unsigned long int wcstoul_l (const wchar_t * __nptr,
                                    wchar_t ** __endptr,
                                    int __base, __locale_t __loc) ;


extern long long int wcstoll_l (const wchar_t * __nptr,
                                wchar_t ** __endptr,
                                int __base, __locale_t __loc) ;


extern unsigned long long int wcstoull_l (const wchar_t * __nptr,
                                          wchar_t ** __endptr,
                                          int __base, __locale_t __loc)
     ;

extern double wcstod_l (const wchar_t * __nptr,
                        wchar_t ** __endptr, __locale_t __loc)
     ;

extern float wcstof_l (const wchar_t * __nptr,
                       wchar_t ** __endptr, __locale_t __loc)
     ;

extern long double wcstold_l (const wchar_t * __nptr,
                              wchar_t ** __endptr,
                              __locale_t __loc) ;





extern double __wcstod_internal (const wchar_t * __nptr,
                                 wchar_t ** __endptr, int __group)
     ;
extern float __wcstof_internal (const wchar_t * __nptr,
                                wchar_t ** __endptr, int __group)
     ;
extern long double __wcstold_internal (const wchar_t * __nptr,
                                       wchar_t ** __endptr,
                                       int __group) ;


extern long int __wcstol_internal (const wchar_t * __nptr,
                                   wchar_t ** __endptr,
                                   int __base, int __group) ;



extern unsigned long int __wcstoul_internal (const wchar_t * __npt,
                                             wchar_t ** __endptr,
                                             int __base, int __group) ;




extern long long int __wcstoll_internal (const wchar_t * __nptr,
                                         wchar_t ** __endptr,
                                         int __base, int __group) ;




extern unsigned long long int __wcstoull_internal (const wchar_t *
                                                   __nptr,
                                                   wchar_t **
                                                   __endptr,
                                                   int __base,
                                                   int __group) ;
# 568 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__dest, const wchar_t *__src) ;



extern wchar_t *wcpncpy (wchar_t *__dest, const wchar_t *__src, size_t __n)
     ;








extern int fwide (__FILE *__fp, int __mode) ;






extern int fwprintf (__FILE * __stream,
                     const wchar_t * __format, ...)
                                                           ;




extern int wprintf (const wchar_t * __format, ...)
                                                           ;

extern int swprintf (wchar_t * __s, size_t __n,
                     const wchar_t * __format, ...)
     ;





extern int vfwprintf (__FILE * __s,
                      const wchar_t * __format,
                      __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t * __format,
                     __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t * __s, size_t __n,
                      const wchar_t * __format,
                      __gnuc_va_list __arg)
     ;






extern int fwscanf (__FILE * __stream,
                    const wchar_t * __format, ...)
                                                          ;




extern int wscanf (const wchar_t * __format, ...)
                                                          ;

extern int swscanf (const wchar_t * __s,
                    const wchar_t * __format, ...)
     ;











extern int vfwscanf (__FILE * __s,
                     const wchar_t * __format,
                     __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t * __format,
                    __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t * __s,
                     const wchar_t * __format,
                     __gnuc_va_list __arg)
     ;










extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t * __ws, int __n,
                        __FILE * __stream);





extern int fputws (const wchar_t * __ws,
                   __FILE * __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 736 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 762 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 772 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t * __ws, int __n,
                                 __FILE * __stream);







extern int fputws_unlocked (const wchar_t * __ws,
                            __FILE * __stream);







extern size_t wcsftime (wchar_t * __s, size_t __maxsize,
                        const wchar_t * __format,
                        const struct tm * __tp) ;







extern size_t wcsftime_l (wchar_t * __s, size_t __maxsize,
                          const wchar_t * __format,
                          const struct tm * __tp,
                          __locale_t __loc) ;
# 817 "/usr/include/wchar.h" 3 4

# 55 "/usr/include/c++/3.3/cwchar" 2 3
# 69 "/usr/include/c++/3.3/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 133 "/usr/include/c++/3.3/cwchar" 3
namespace std
{
  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
  using ::vfwscanf;
  using ::vswprintf;
  using ::vswscanf;
  using ::vwprintf;
  using ::vwscanf;
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
  using ::wcstof;
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
}







namespace __gnu_cxx
{





  using ::wcstold;
# 242 "/usr/include/c++/3.3/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using __gnu_cxx::wcstold;
  using __gnu_cxx::wcstoll;
  using __gnu_cxx::wcstoull;
}
# 46 "/usr/include/c++/3.3/bits/fpos.h" 2 3

namespace std
{






  template<typename _StateT>
    class fpos
    {
    public:

      typedef _StateT __state_type;

    private:
      streamoff _M_off;
      __state_type _M_st;

    public:
      __state_type
      state() const { return _M_st; }

      void
      state(__state_type __st) { _M_st = __st; }



      fpos(): _M_off(streamoff()), _M_st(__state_type()) { }

      fpos(streamoff __off, __state_type __st = __state_type())
      : _M_off(__off), _M_st(__st) { }

      operator streamoff() const { return _M_off; }

      fpos&
      operator+=(streamoff __off) { _M_off += __off; return *this; }

      fpos&
      operator-=(streamoff __off) { _M_off -= __off; return *this; }

      fpos
      operator+(streamoff __off)
      {
        fpos __t(*this);
        __t += __off;
        return __t;
      }

      fpos
      operator-(streamoff __off)
      {
        fpos __t(*this);
        __t -= __off;
        return __t;
      }

      bool
      operator==(const fpos& __pos) const
      { return _M_off == __pos._M_off; }

      bool
      operator!=(const fpos& __pos) const
      { return _M_off != __pos._M_off; }

      streamoff
      _M_position() const { return _M_off; }

      void
      _M_position(streamoff __off) { _M_off = __off; }
    };


  typedef fpos<mbstate_t> streampos;


  typedef fpos<mbstate_t> wstreampos;

}
# 47 "/usr/include/c++/3.3/bits/char_traits.h" 2 3

namespace std
{
# 61 "/usr/include/c++/3.3/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits
    {
      typedef _CharT char_type;

      typedef unsigned long int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2);

      static bool
      eq(const char_type& __c1, const char_type& __c2);

      static bool
      lt(const char_type& __c1, const char_type& __c2);

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n);

      static size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n);

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c);

      static int_type
      to_int_type(const char_type& __c);

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2);

      static int_type
      eof();

      static int_type
      not_eof(const int_type& __c);
    };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, int_type __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


  template<typename _CharT, typename _Traits>
    struct _Char_traits_match
    {
      _CharT _M_c;
      _Char_traits_match(_CharT const& __c) : _M_c(__c) { }

      bool
      operator()(_CharT const& __a) { return _Traits::eq(_M_c, __a); }
    };
}
# 48 "/usr/include/c++/3.3/string" 2 3
# 1 "/usr/include/c++/3.3/memory" 1 3
# 52 "/usr/include/c++/3.3/memory" 3
       
# 53 "/usr/include/c++/3.3/memory" 3

# 1 "/usr/include/c++/3.3/bits/stl_algobase.h" 1 3
# 66 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/3.3/climits" 1 3
# 47 "/usr/include/c++/3.3/climits" 3
       
# 48 "/usr/include/c++/3.3/climits" 3

# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/limits.h" 1 3
# 11 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/limits.h" 3
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/syslimits.h" 1 3






# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/limits.h" 1 3
# 122 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 45 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 46 "/usr/include/limits.h" 2 3 4
# 144 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 130 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 36 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 37 "/usr/include/bits/local_lim.h" 2 3 4
# 131 "/usr/include/bits/posix1_lim.h" 2 3 4
# 145 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 149 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 153 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/limits.h" 2 3
# 8 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/syslimits.h" 2 3
# 12 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/limits.h" 2 3
# 50 "/usr/include/c++/3.3/climits" 2 3
# 67 "/usr/include/c++/3.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/3.3/cstdlib" 1 3
# 47 "/usr/include/c++/3.3/cstdlib" 3
       
# 48 "/usr/include/c++/3.3/cstdlib" 3




# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 63 "/usr/include/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 64 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

        unsigned int __w_termsig:7;
        unsigned int __w_coredump:1;
        unsigned int __w_retcode:8;
        unsigned int:16;







      } __wait_terminated;
    struct
      {

        unsigned int __w_stopval:8;
        unsigned int __w_stopsig:8;
        unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 93 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







 typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 137 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) ;




extern double atof (const char *__nptr) ;

extern int atoi (const char *__nptr) ;

extern long int atol (const char *__nptr) ;





 extern long long int atoll (const char *__nptr)
     ;





extern double strtod (const char * __nptr,
                      char ** __endptr) ;





extern float strtof (const char * __nptr,
                     char ** __endptr) ;

extern long double strtold (const char * __nptr,
                            char ** __endptr) ;





extern long int strtol (const char * __nptr,
                        char ** __endptr, int __base) ;

extern unsigned long int strtoul (const char * __nptr,
                                  char ** __endptr, int __base)
     ;

# 197 "/usr/include/stdlib.h" 3 4



extern long long int strtoll (const char * __nptr,
                              char ** __endptr, int __base) ;


extern unsigned long long int strtoull (const char * __nptr,
                                        char ** __endptr, int __base)
     ;

# 229 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char * __nptr,
                          char ** __endptr, int __base,
                          __locale_t __loc) ;

extern unsigned long int strtoul_l (const char * __nptr,
                                    char ** __endptr,
                                    int __base, __locale_t __loc) ;


extern long long int strtoll_l (const char * __nptr,
                                char ** __endptr, int __base,
                                __locale_t __loc) ;


extern unsigned long long int strtoull_l (const char * __nptr,
                                          char ** __endptr,
                                          int __base, __locale_t __loc)
     ;

extern double strtod_l (const char * __nptr,
                        char ** __endptr, __locale_t __loc)
     ;

extern float strtof_l (const char * __nptr,
                       char ** __endptr, __locale_t __loc) ;

extern long double strtold_l (const char * __nptr,
                              char ** __endptr,
                              __locale_t __loc) ;






extern double __strtod_internal (const char * __nptr,
                                 char ** __endptr, int __group)
     ;
extern float __strtof_internal (const char * __nptr,
                                char ** __endptr, int __group)
     ;
extern long double __strtold_internal (const char * __nptr,
                                       char ** __endptr,
                                       int __group) ;

extern long int __strtol_internal (const char * __nptr,
                                   char ** __endptr,
                                   int __base, int __group) ;



extern unsigned long int __strtoul_internal (const char * __nptr,
                                             char ** __endptr,
                                             int __base, int __group) ;





extern long long int __strtoll_internal (const char * __nptr,
                                         char ** __endptr,
                                         int __base, int __group) ;




extern unsigned long long int __strtoull_internal (const char *
                                                   __nptr,
                                                   char ** __endptr,
                                                   int __base, int __group)
     ;
# 408 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) ;


extern long int a64l (const char *__s) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;
# 72 "/usr/include/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 116 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 141 "/usr/include/sys/types.h" 3 4
typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 163 "/usr/include/sys/types.h" 3 4
typedef char int8_t;
typedef short int int16_t;
typedef int int32_t;






typedef unsigned char u_int8_t;
typedef unsigned short int u_int16_t;
typedef unsigned int u_int32_t;




typedef int register_t;
# 216 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 35 "/usr/include/sys/select.h" 2 3 4
# 46 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4

# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set * __readfds,
                   fd_set * __writefds,
                   fd_set * __exceptfds,
                   struct timeval * __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set * __readfds,
                    fd_set * __writefds,
                    fd_set * __exceptfds,
                    const struct timespec * __timeout,
                    const __sigset_t * __sigmask);



# 217 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 220 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 258 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 267 "/usr/include/sys/types.h" 2 3 4



# 417 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) ;


extern void srandom (unsigned int __seed) ;





extern char *initstate (unsigned int __seed, char *__statebuf,
                        size_t __statelen) ;



extern char *setstate (char *__statebuf) ;







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data * __buf,
                     int32_t * __result) ;

extern int srandom_r (unsigned int __seed, struct random_data *__buf) ;

extern int initstate_r (unsigned int __seed, char * __statebuf,
                        size_t __statelen,
                        struct random_data * __buf) ;

extern int setstate_r (char * __statebuf,
                       struct random_data * __buf) ;






extern int rand (void) ;

extern void srand (unsigned int __seed) ;




extern int rand_r (unsigned int *__seed) ;







extern double drand48 (void) ;
extern double erand48 (unsigned short int __xsubi[3]) ;


extern long int lrand48 (void) ;
extern long int nrand48 (unsigned short int __xsubi[3]) ;


extern long int mrand48 (void) ;
extern long int jrand48 (unsigned short int __xsubi[3]) ;


extern void srand48 (long int __seedval) ;
extern unsigned short int *seed48 (unsigned short int __seed16v[3]) ;
extern void lcong48 (unsigned short int __param[7]) ;





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data * __buffer,
                      double * __result) ;
extern int erand48_r (unsigned short int __xsubi[3],
                      struct drand48_data * __buffer,
                      double * __result) ;


extern int lrand48_r (struct drand48_data * __buffer,
                      long int * __result) ;
extern int nrand48_r (unsigned short int __xsubi[3],
                      struct drand48_data * __buffer,
                      long int * __result) ;


extern int mrand48_r (struct drand48_data * __buffer,
                      long int * __result) ;
extern int jrand48_r (unsigned short int __xsubi[3],
                      struct drand48_data * __buffer,
                      long int * __result) ;


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     ;

extern int seed48_r (unsigned short int __seed16v[3],
                     struct drand48_data *__buffer) ;

extern int lcong48_r (unsigned short int __param[7],
                      struct drand48_data *__buffer) ;









extern void *malloc (size_t __size) ;

extern void *calloc (size_t __nmemb, size_t __size)
     ;







extern void *realloc (void *__ptr, size_t __size) ;

extern void free (void *__ptr) ;




extern void cfree (void *__ptr) ;



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) ;






# 579 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     ;




extern void abort (void) ;



extern int atexit (void (*__func) (void)) ;





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     ;






extern void exit (int __status) ;






extern void _Exit (int __status) ;






extern char *getenv (const char *__name) ;




extern char *__secure_getenv (const char *__name) ;





extern int putenv (char *__string) ;





extern int setenv (const char *__name, const char *__value, int __replace)
     ;


extern int unsetenv (const char *__name) ;






extern int clearenv (void) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template);
# 683 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template);
# 693 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) ;








extern int system (const char *__command);







extern char *canonicalize_file_name (const char *__name) ;
# 720 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char * __name,
                       char * __resolved) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;






extern void *bsearch (const void *__key, const void *__base,
                      size_t __nmemb, size_t __size, __compar_fn_t __compar);



extern void qsort (void *__base, size_t __nmemb, size_t __size,
                   __compar_fn_t __compar);



extern int abs (int __x) ;
extern long int labs (long int __x) ;



 extern long long int llabs (long long int __x)
     ;







extern div_t div (int __numer, int __denom)
     ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     ;




 extern lldiv_t lldiv (long long int __numer,
                                    long long int __denom)
     ;

# 784 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int * __decpt,
                   int * __sign) ;




extern char *fcvt (double __value, int __ndigit, int * __decpt,
                   int * __sign) ;




extern char *gcvt (double __value, int __ndigit, char *__buf) ;




extern char *qecvt (long double __value, int __ndigit,
                    int * __decpt, int * __sign) ;
extern char *qfcvt (long double __value, int __ndigit,
                    int * __decpt, int * __sign) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf) ;




extern int ecvt_r (double __value, int __ndigit, int * __decpt,
                   int * __sign, char * __buf,
                   size_t __len) ;
extern int fcvt_r (double __value, int __ndigit, int * __decpt,
                   int * __sign, char * __buf,
                   size_t __len) ;

extern int qecvt_r (long double __value, int __ndigit,
                    int * __decpt, int * __sign,
                    char * __buf, size_t __len) ;
extern int qfcvt_r (long double __value, int __ndigit,
                    int * __decpt, int * __sign,
                    char * __buf, size_t __len) ;







extern int mblen (const char *__s, size_t __n) ;


extern int mbtowc (wchar_t * __pwc,
                   const char * __s, size_t __n) ;


extern int wctomb (char *__s, wchar_t __wchar) ;



extern size_t mbstowcs (wchar_t * __pwcs,
                        const char * __s, size_t __n) ;

extern size_t wcstombs (char * __s,
                        const wchar_t * __pwcs, size_t __n)
     ;








extern int rpmatch (const char *__response) ;
# 866 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char ** __optionp,
                      char *const * __tokens,
                      char ** __valuep) ;





extern void setkey (const char *__key) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) ;



extern int unlockpt (int __fd) ;




extern char *ptsname (int __fd) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen) ;


extern int getpt (void) ;






extern int getloadavg (double __loadavg[], int __nelem) ;






# 53 "/usr/include/c++/3.3/cstdlib" 2 3
# 84 "/usr/include/c++/3.3/cstdlib" 3
namespace std
{
  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
  using ::wcstombs;
  using ::wctomb;

  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
}
# 136 "/usr/include/c++/3.3/cstdlib" 3
namespace __gnu_cxx
{

  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }

  inline long long
  llabs(long long __x) { return __x >= 0 ? __x : -__x; }


  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  inline lldiv_t
  lldiv(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }
# 172 "/usr/include/c++/3.3/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;
}

namespace std
{

  using __gnu_cxx::lldiv_t;

  using __gnu_cxx::_Exit;
  using __gnu_cxx::abs;
  using __gnu_cxx::llabs;

  using __gnu_cxx::div;
  using __gnu_cxx::lldiv;

  using __gnu_cxx::atoll;
  using __gnu_cxx::strtof;
  using __gnu_cxx::strtoll;
  using __gnu_cxx::strtoull;
  using __gnu_cxx::strtold;
}
# 68 "/usr/include/c++/3.3/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/3.3/new" 1 3
# 42 "/usr/include/c++/3.3/new" 3
# 1 "/usr/include/c++/3.3/exception" 1 3
# 40 "/usr/include/c++/3.3/exception" 3
extern "C++" {

namespace std
{
# 52 "/usr/include/c++/3.3/exception" 3
  class exception
  {
  public:
    exception() { }
    virtual ~exception() ;


    virtual const char* what() const ;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() { }


    virtual ~bad_exception() ;
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) ;


  void terminate() ;


  unexpected_handler set_unexpected(unexpected_handler) ;


  void unexpected() ;
# 100 "/usr/include/c++/3.3/exception" 3
  bool uncaught_exception() ;
}

namespace __gnu_cxx
{
# 113 "/usr/include/c++/3.3/exception" 3
  void __verbose_terminate_handler ();
}

}
# 43 "/usr/include/c++/3.3/new" 2 3

extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() { }


    virtual ~bad_alloc() ;
  };

  struct nothrow_t { };
  extern const nothrow_t nothrow;


  typedef void (*new_handler)();

  new_handler set_new_handler(new_handler) ;
}
# 82 "/usr/include/c++/3.3/new" 3
void* operator new(std::size_t) ;
void* operator new[](std::size_t) ;
void operator delete(void*) ;
void operator delete[](void*) ;
void* operator new(std::size_t, const std::nothrow_t&) ;
void* operator new[](std::size_t, const std::nothrow_t&) ;
void operator delete(void*, const std::nothrow_t&) ;
void operator delete[](void*, const std::nothrow_t&) ;


inline void* operator new(std::size_t, void* __p) { return __p; }
inline void* operator new[](std::size_t, void* __p) { return __p; }


inline void operator delete (void*, void*) { };
inline void operator delete[](void*, void*) { };

}
# 70 "/usr/include/c++/3.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/3.3/iosfwd" 1 3
# 43 "/usr/include/c++/3.3/iosfwd" 3
       
# 44 "/usr/include/c++/3.3/iosfwd" 3


# 1 "/usr/include/c++/3.3/i486-linux/bits/c++locale.h" 1 3
# 39 "/usr/include/c++/3.3/i486-linux/bits/c++locale.h" 3
       
# 40 "/usr/include/c++/3.3/i486-linux/bits/c++locale.h" 3

# 1 "/usr/include/c++/3.3/clocale" 1 3
# 47 "/usr/include/c++/3.3/clocale" 3
       
# 48 "/usr/include/c++/3.3/clocale" 3

# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4


# 52 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 119 "/usr/include/locale.h" 3 4
};





extern char *setlocale (int __category, const char *__locale) ;


extern struct lconv *localeconv (void) ;


# 148 "/usr/include/locale.h" 3 4
typedef __locale_t locale_t;





extern __locale_t newlocale (int __category_mask, const char *__locale,
                             __locale_t __base) ;
# 189 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) ;



extern void freelocale (__locale_t __dataset) ;






extern __locale_t uselocale (__locale_t __dataset) ;








# 50 "/usr/include/c++/3.3/clocale" 2 3





namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/c++/3.3/i486-linux/bits/c++locale.h" 2 3
# 1 "/usr/include/langinfo.h" 1 3 4
# 24 "/usr/include/langinfo.h" 3 4
# 1 "/usr/include/nl_types.h" 1 3 4
# 31 "/usr/include/nl_types.h" 3 4



typedef void *nl_catd;


typedef int nl_item;





extern nl_catd catopen (const char *__cat_name, int __flag);



extern char *catgets (nl_catd __catalog, int __set, int __number,
                      const char *__string) ;


extern int catclose (nl_catd __catalog) ;


# 25 "/usr/include/langinfo.h" 2 3 4

# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/langinfo.h" 2 3 4



# 43 "/usr/include/langinfo.h" 3 4
enum
{



  ABDAY_1 = (((__LC_TIME) << 16) | (0)),

  ABDAY_2,

  ABDAY_3,

  ABDAY_4,

  ABDAY_5,

  ABDAY_6,

  ABDAY_7,



  DAY_1,

  DAY_2,

  DAY_3,

  DAY_4,

  DAY_5,

  DAY_6,

  DAY_7,



  ABMON_1,

  ABMON_2,

  ABMON_3,

  ABMON_4,

  ABMON_5,

  ABMON_6,

  ABMON_7,

  ABMON_8,

  ABMON_9,

  ABMON_10,

  ABMON_11,

  ABMON_12,



  MON_1,

  MON_2,

  MON_3,

  MON_4,

  MON_5,

  MON_6,

  MON_7,

  MON_8,

  MON_9,

  MON_10,

  MON_11,

  MON_12,


  AM_STR,

  PM_STR,


  D_T_FMT,

  D_FMT,

  T_FMT,

  T_FMT_AMPM,


  ERA,

  __ERA_YEAR,



  ERA_D_FMT,

  ALT_DIGITS,

  ERA_D_T_FMT,

  ERA_T_FMT,


  _NL_TIME_ERA_NUM_ENTRIES,
  _NL_TIME_ERA_ENTRIES,

  _NL_WABDAY_1,
  _NL_WABDAY_2,
  _NL_WABDAY_3,
  _NL_WABDAY_4,
  _NL_WABDAY_5,
  _NL_WABDAY_6,
  _NL_WABDAY_7,


  _NL_WDAY_1,
  _NL_WDAY_2,
  _NL_WDAY_3,
  _NL_WDAY_4,
  _NL_WDAY_5,
  _NL_WDAY_6,
  _NL_WDAY_7,


  _NL_WABMON_1,
  _NL_WABMON_2,
  _NL_WABMON_3,
  _NL_WABMON_4,
  _NL_WABMON_5,
  _NL_WABMON_6,
  _NL_WABMON_7,
  _NL_WABMON_8,
  _NL_WABMON_9,
  _NL_WABMON_10,
  _NL_WABMON_11,
  _NL_WABMON_12,


  _NL_WMON_1,
  _NL_WMON_2,
  _NL_WMON_3,
  _NL_WMON_4,
  _NL_WMON_5,
  _NL_WMON_6,
  _NL_WMON_7,
  _NL_WMON_8,
  _NL_WMON_9,
  _NL_WMON_10,
  _NL_WMON_11,
  _NL_WMON_12,

  _NL_WAM_STR,
  _NL_WPM_STR,

  _NL_WD_T_FMT,
  _NL_WD_FMT,
  _NL_WT_FMT,
  _NL_WT_FMT_AMPM,

  _NL_WERA_YEAR,
  _NL_WERA_D_FMT,
  _NL_WALT_DIGITS,
  _NL_WERA_D_T_FMT,
  _NL_WERA_T_FMT,

  _NL_TIME_WEEK_NDAYS,
  _NL_TIME_WEEK_1STDAY,
  _NL_TIME_WEEK_1STWEEK,
  _NL_TIME_FIRST_WEEKDAY,
  _NL_TIME_FIRST_WORKDAY,
  _NL_TIME_CAL_DIRECTION,
  _NL_TIME_TIMEZONE,

  _DATE_FMT,

  _NL_W_DATE_FMT,

  _NL_TIME_CODESET,

  _NL_NUM_LC_TIME,




  _NL_COLLATE_NRULES = (((__LC_COLLATE) << 16) | (0)),
  _NL_COLLATE_RULESETS,
  _NL_COLLATE_TABLEMB,
  _NL_COLLATE_WEIGHTMB,
  _NL_COLLATE_EXTRAMB,
  _NL_COLLATE_INDIRECTMB,
  _NL_COLLATE_GAP1,
  _NL_COLLATE_GAP2,
  _NL_COLLATE_GAP3,
  _NL_COLLATE_TABLEWC,
  _NL_COLLATE_WEIGHTWC,
  _NL_COLLATE_EXTRAWC,
  _NL_COLLATE_INDIRECTWC,
  _NL_COLLATE_SYMB_HASH_SIZEMB,
  _NL_COLLATE_SYMB_TABLEMB,
  _NL_COLLATE_SYMB_EXTRAMB,
  _NL_COLLATE_COLLSEQMB,
  _NL_COLLATE_COLLSEQWC,
  _NL_COLLATE_CODESET,
  _NL_NUM_LC_COLLATE,




  _NL_CTYPE_CLASS = (((__LC_CTYPE) << 16) | (0)),
  _NL_CTYPE_TOUPPER,
  _NL_CTYPE_GAP1,
  _NL_CTYPE_TOLOWER,
  _NL_CTYPE_GAP2,
  _NL_CTYPE_CLASS32,
  _NL_CTYPE_GAP3,
  _NL_CTYPE_GAP4,
  _NL_CTYPE_GAP5,
  _NL_CTYPE_GAP6,
  _NL_CTYPE_CLASS_NAMES,
  _NL_CTYPE_MAP_NAMES,
  _NL_CTYPE_WIDTH,
  _NL_CTYPE_MB_CUR_MAX,
  _NL_CTYPE_CODESET_NAME,
  CODESET = _NL_CTYPE_CODESET_NAME,

  _NL_CTYPE_TOUPPER32,
  _NL_CTYPE_TOLOWER32,
  _NL_CTYPE_CLASS_OFFSET,
  _NL_CTYPE_MAP_OFFSET,
  _NL_CTYPE_INDIGITS_MB_LEN,
  _NL_CTYPE_INDIGITS0_MB,
  _NL_CTYPE_INDIGITS1_MB,
  _NL_CTYPE_INDIGITS2_MB,
  _NL_CTYPE_INDIGITS3_MB,
  _NL_CTYPE_INDIGITS4_MB,
  _NL_CTYPE_INDIGITS5_MB,
  _NL_CTYPE_INDIGITS6_MB,
  _NL_CTYPE_INDIGITS7_MB,
  _NL_CTYPE_INDIGITS8_MB,
  _NL_CTYPE_INDIGITS9_MB,
  _NL_CTYPE_INDIGITS_WC_LEN,
  _NL_CTYPE_INDIGITS0_WC,
  _NL_CTYPE_INDIGITS1_WC,
  _NL_CTYPE_INDIGITS2_WC,
  _NL_CTYPE_INDIGITS3_WC,
  _NL_CTYPE_INDIGITS4_WC,
  _NL_CTYPE_INDIGITS5_WC,
  _NL_CTYPE_INDIGITS6_WC,
  _NL_CTYPE_INDIGITS7_WC,
  _NL_CTYPE_INDIGITS8_WC,
  _NL_CTYPE_INDIGITS9_WC,
  _NL_CTYPE_OUTDIGIT0_MB,
  _NL_CTYPE_OUTDIGIT1_MB,
  _NL_CTYPE_OUTDIGIT2_MB,
  _NL_CTYPE_OUTDIGIT3_MB,
  _NL_CTYPE_OUTDIGIT4_MB,
  _NL_CTYPE_OUTDIGIT5_MB,
  _NL_CTYPE_OUTDIGIT6_MB,
  _NL_CTYPE_OUTDIGIT7_MB,
  _NL_CTYPE_OUTDIGIT8_MB,
  _NL_CTYPE_OUTDIGIT9_MB,
  _NL_CTYPE_OUTDIGIT0_WC,
  _NL_CTYPE_OUTDIGIT1_WC,
  _NL_CTYPE_OUTDIGIT2_WC,
  _NL_CTYPE_OUTDIGIT3_WC,
  _NL_CTYPE_OUTDIGIT4_WC,
  _NL_CTYPE_OUTDIGIT5_WC,
  _NL_CTYPE_OUTDIGIT6_WC,
  _NL_CTYPE_OUTDIGIT7_WC,
  _NL_CTYPE_OUTDIGIT8_WC,
  _NL_CTYPE_OUTDIGIT9_WC,
  _NL_CTYPE_TRANSLIT_TAB_SIZE,
  _NL_CTYPE_TRANSLIT_FROM_IDX,
  _NL_CTYPE_TRANSLIT_FROM_TBL,
  _NL_CTYPE_TRANSLIT_TO_IDX,
  _NL_CTYPE_TRANSLIT_TO_TBL,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING,
  _NL_CTYPE_TRANSLIT_IGNORE_LEN,
  _NL_CTYPE_TRANSLIT_IGNORE,
  _NL_CTYPE_EXTRA_MAP_1,
  _NL_CTYPE_EXTRA_MAP_2,
  _NL_CTYPE_EXTRA_MAP_3,
  _NL_CTYPE_EXTRA_MAP_4,
  _NL_CTYPE_EXTRA_MAP_5,
  _NL_CTYPE_EXTRA_MAP_6,
  _NL_CTYPE_EXTRA_MAP_7,
  _NL_CTYPE_EXTRA_MAP_8,
  _NL_CTYPE_EXTRA_MAP_9,
  _NL_CTYPE_EXTRA_MAP_10,
  _NL_CTYPE_EXTRA_MAP_11,
  _NL_CTYPE_EXTRA_MAP_12,
  _NL_CTYPE_EXTRA_MAP_13,
  _NL_CTYPE_EXTRA_MAP_14,
  _NL_NUM_LC_CTYPE,




  __INT_CURR_SYMBOL = (((__LC_MONETARY) << 16) | (0)),



  __CURRENCY_SYMBOL,



  __MON_DECIMAL_POINT,



  __MON_THOUSANDS_SEP,



  __MON_GROUPING,



  __POSITIVE_SIGN,



  __NEGATIVE_SIGN,



  __INT_FRAC_DIGITS,



  __FRAC_DIGITS,



  __P_CS_PRECEDES,



  __P_SEP_BY_SPACE,



  __N_CS_PRECEDES,



  __N_SEP_BY_SPACE,



  __P_SIGN_POSN,



  __N_SIGN_POSN,



  _NL_MONETARY_CRNCYSTR,

  __INT_P_CS_PRECEDES,



  __INT_P_SEP_BY_SPACE,



  __INT_N_CS_PRECEDES,



  __INT_N_SEP_BY_SPACE,



  __INT_P_SIGN_POSN,



  __INT_N_SIGN_POSN,



  _NL_MONETARY_DUO_INT_CURR_SYMBOL,
  _NL_MONETARY_DUO_CURRENCY_SYMBOL,
  _NL_MONETARY_DUO_INT_FRAC_DIGITS,
  _NL_MONETARY_DUO_FRAC_DIGITS,
  _NL_MONETARY_DUO_P_CS_PRECEDES,
  _NL_MONETARY_DUO_P_SEP_BY_SPACE,
  _NL_MONETARY_DUO_N_CS_PRECEDES,
  _NL_MONETARY_DUO_N_SEP_BY_SPACE,
  _NL_MONETARY_DUO_INT_P_CS_PRECEDES,
  _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE,
  _NL_MONETARY_DUO_INT_N_CS_PRECEDES,
  _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE,
  _NL_MONETARY_DUO_P_SIGN_POSN,
  _NL_MONETARY_DUO_N_SIGN_POSN,
  _NL_MONETARY_DUO_INT_P_SIGN_POSN,
  _NL_MONETARY_DUO_INT_N_SIGN_POSN,
  _NL_MONETARY_UNO_VALID_FROM,
  _NL_MONETARY_UNO_VALID_TO,
  _NL_MONETARY_DUO_VALID_FROM,
  _NL_MONETARY_DUO_VALID_TO,
  _NL_MONETARY_CONVERSION_RATE,
  _NL_MONETARY_DECIMAL_POINT_WC,
  _NL_MONETARY_THOUSANDS_SEP_WC,
  _NL_MONETARY_CODESET,
  _NL_NUM_LC_MONETARY,



  __DECIMAL_POINT = (((__LC_NUMERIC) << 16) | (0)),



  RADIXCHAR = __DECIMAL_POINT,

  __THOUSANDS_SEP,



  THOUSEP = __THOUSANDS_SEP,

  __GROUPING,



  _NL_NUMERIC_DECIMAL_POINT_WC,
  _NL_NUMERIC_THOUSANDS_SEP_WC,
  _NL_NUMERIC_CODESET,
  _NL_NUM_LC_NUMERIC,

  __YESEXPR = (((__LC_MESSAGES) << 16) | (0)),

  __NOEXPR,

  __YESSTR,



  __NOSTR,



  _NL_MESSAGES_CODESET,
  _NL_NUM_LC_MESSAGES,

  _NL_PAPER_HEIGHT = (((__LC_PAPER) << 16) | (0)),
  _NL_PAPER_WIDTH,
  _NL_PAPER_CODESET,
  _NL_NUM_LC_PAPER,

  _NL_NAME_NAME_FMT = (((__LC_NAME) << 16) | (0)),
  _NL_NAME_NAME_GEN,
  _NL_NAME_NAME_MR,
  _NL_NAME_NAME_MRS,
  _NL_NAME_NAME_MISS,
  _NL_NAME_NAME_MS,
  _NL_NAME_CODESET,
  _NL_NUM_LC_NAME,

  _NL_ADDRESS_POSTAL_FMT = (((__LC_ADDRESS) << 16) | (0)),
  _NL_ADDRESS_COUNTRY_NAME,
  _NL_ADDRESS_COUNTRY_POST,
  _NL_ADDRESS_COUNTRY_AB2,
  _NL_ADDRESS_COUNTRY_AB3,
  _NL_ADDRESS_COUNTRY_CAR,
  _NL_ADDRESS_COUNTRY_NUM,
  _NL_ADDRESS_COUNTRY_ISBN,
  _NL_ADDRESS_LANG_NAME,
  _NL_ADDRESS_LANG_AB,
  _NL_ADDRESS_LANG_TERM,
  _NL_ADDRESS_LANG_LIB,
  _NL_ADDRESS_CODESET,
  _NL_NUM_LC_ADDRESS,

  _NL_TELEPHONE_TEL_INT_FMT = (((__LC_TELEPHONE) << 16) | (0)),
  _NL_TELEPHONE_TEL_DOM_FMT,
  _NL_TELEPHONE_INT_SELECT,
  _NL_TELEPHONE_INT_PREFIX,
  _NL_TELEPHONE_CODESET,
  _NL_NUM_LC_TELEPHONE,

  _NL_MEASUREMENT_MEASUREMENT = (((__LC_MEASUREMENT) << 16) | (0)),
  _NL_MEASUREMENT_CODESET,
  _NL_NUM_LC_MEASUREMENT,

  _NL_IDENTIFICATION_TITLE = (((__LC_IDENTIFICATION) << 16) | (0)),
  _NL_IDENTIFICATION_SOURCE,
  _NL_IDENTIFICATION_ADDRESS,
  _NL_IDENTIFICATION_CONTACT,
  _NL_IDENTIFICATION_EMAIL,
  _NL_IDENTIFICATION_TEL,
  _NL_IDENTIFICATION_FAX,
  _NL_IDENTIFICATION_LANGUAGE,
  _NL_IDENTIFICATION_TERRITORY,
  _NL_IDENTIFICATION_AUDIENCE,
  _NL_IDENTIFICATION_APPLICATION,
  _NL_IDENTIFICATION_ABBREVIATION,
  _NL_IDENTIFICATION_REVISION,
  _NL_IDENTIFICATION_DATE,
  _NL_IDENTIFICATION_CATEGORY,
  _NL_IDENTIFICATION_CODESET,
  _NL_NUM_LC_IDENTIFICATION,


  _NL_NUM
};
# 575 "/usr/include/langinfo.h" 3 4
extern char *nl_langinfo (nl_item __item) ;
# 586 "/usr/include/langinfo.h" 3 4
extern char *nl_langinfo_l (nl_item __item, __locale_t l);



# 43 "/usr/include/c++/3.3/i486-linux/bits/c++locale.h" 2 3
# 1 "/usr/include/iconv.h" 1 3 4
# 24 "/usr/include/iconv.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 25 "/usr/include/iconv.h" 2 3 4





typedef void *iconv_t;







extern iconv_t iconv_open (const char *__tocode, const char *__fromcode);




extern size_t iconv (iconv_t __cd, char ** __inbuf,
                     size_t * __inbytesleft,
                     char ** __outbuf,
                     size_t * __outbytesleft);





extern int iconv_close (iconv_t __cd);


# 44 "/usr/include/c++/3.3/i486-linux/bits/c++locale.h" 2 3
# 1 "/usr/include/libintl.h" 1 3 4
# 35 "/usr/include/libintl.h" 3 4





extern char *gettext (const char *__msgid) ;



extern char *dgettext (const char *__domainname, const char *__msgid)
     ;
extern char *__dgettext (const char *__domainname, const char *__msgid)
     ;



extern char *dcgettext (const char *__domainname,
                        const char *__msgid, int __category) ;
extern char *__dcgettext (const char *__domainname,
                          const char *__msgid, int __category)
     ;




extern char *ngettext (const char *__msgid1, const char *__msgid2,
                       unsigned long int __n)
     ;



extern char *dngettext (const char *__domainname, const char *__msgid1,
                        const char *__msgid2, unsigned long int __n)
     ;



extern char *dcngettext (const char *__domainname, const char *__msgid1,
                         const char *__msgid2, unsigned long int __n,
                         int __category)
     ;





extern char *textdomain (const char *__domainname) ;



extern char *bindtextdomain (const char *__domainname,
                             const char *__dirname) ;



extern char *bind_textdomain_codeset (const char *__domainname,
                                      const char *__codeset) ;
# 120 "/usr/include/libintl.h" 3 4

# 45 "/usr/include/c++/3.3/i486-linux/bits/c++locale.h" 2 3






namespace __gnu_cxx
{
  extern "C" __typeof(uselocale) __uselocale;
}


namespace std
{
  typedef __locale_t __c_locale;





  template<typename _Tv>
    int
    __convert_from_v(char* __out, const int __size, const char* __fmt,

                     _Tv __v, const __c_locale& __cloc, int __prec = -1)
    {
      __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 82 "/usr/include/c++/3.3/i486-linux/bits/c++locale.h" 3
      int __ret;

      if (__prec >= 0)
        __ret = snprintf(__out, __size, __fmt, __prec, __v);
      else
        __ret = snprintf(__out, __size, __fmt, __v);
# 96 "/usr/include/c++/3.3/i486-linux/bits/c++locale.h" 3
      __gnu_cxx::__uselocale(__old);




      return __ret;
    }
}
# 47 "/usr/include/c++/3.3/iosfwd" 2 3
# 1 "/usr/include/c++/3.3/cctype" 1 3
# 46 "/usr/include/c++/3.3/cctype" 3
       
# 47 "/usr/include/c++/3.3/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 30 "/usr/include/ctype.h" 3 4

# 48 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     ;
extern const __int32_t **__ctype_tolower_loc (void)
     ;
extern const __int32_t **__ctype_toupper_loc (void)
     ;
# 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) ;
extern int isalpha (int) ;
extern int iscntrl (int) ;
extern int isdigit (int) ;
extern int islower (int) ;
extern int isgraph (int) ;
extern int isprint (int) ;
extern int ispunct (int) ;
extern int isspace (int) ;
extern int isupper (int) ;
extern int isxdigit (int) ;



extern int tolower (int __c) ;


extern int toupper (int __c) ;








extern int isblank (int) ;






extern int isctype (int __c, int __mask) ;






extern int isascii (int __c) ;



extern int toascii (int __c) ;



extern int _toupper (int) ;
extern int _tolower (int) ;
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) ;
extern int isalpha_l (int, __locale_t) ;
extern int iscntrl_l (int, __locale_t) ;
extern int isdigit_l (int, __locale_t) ;
extern int islower_l (int, __locale_t) ;
extern int isgraph_l (int, __locale_t) ;
extern int isprint_l (int, __locale_t) ;
extern int ispunct_l (int, __locale_t) ;
extern int isspace_l (int, __locale_t) ;
extern int isupper_l (int, __locale_t) ;
extern int isxdigit_l (int, __locale_t) ;

extern int isblank_l (int, __locale_t) ;



extern int __tolower_l (int __c, __locale_t __l) ;
extern int tolower_l (int __c, __locale_t __l) ;


extern int __toupper_l (int __c, __locale_t __l) ;
extern int toupper_l (int __c, __locale_t __l) ;
# 323 "/usr/include/ctype.h" 3 4

# 50 "/usr/include/c++/3.3/cctype" 2 3
# 66 "/usr/include/c++/3.3/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
# 48 "/usr/include/c++/3.3/iosfwd" 2 3


# 1 "/usr/include/c++/3.3/bits/functexcept.h" 1 3
# 34 "/usr/include/c++/3.3/bits/functexcept.h" 3
# 1 "/usr/include/c++/3.3/exception_defines.h" 1 3
# 35 "/usr/include/c++/3.3/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 51 "/usr/include/c++/3.3/iosfwd" 2 3

namespace std
{
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 136 "/usr/include/c++/3.3/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;


}
# 71 "/usr/include/c++/3.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/3.3/bits/stl_pair.h" 1 3
# 64 "/usr/include/c++/3.3/bits/stl_pair.h" 3
namespace std
{


template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;




  pair() : first(), second() {}




  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}
};


template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first == __y.first && __x.second == __y.second;
}


template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}


template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x == __y);
}


template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __y < __x;
}


template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__y < __x);
}


template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x < __y);
}
# 140 "/usr/include/c++/3.3/bits/stl_pair.h" 3
template <class _T1, class _T2>


inline pair<_T1, _T2> make_pair(_T1 __x, _T2 __y)



{
  return pair<_T1, _T2>(__x, __y);
}

}
# 72 "/usr/include/c++/3.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/3.3/bits/type_traits.h" 1 3
# 52 "/usr/include/c++/3.3/bits/type_traits.h" 3
       
# 53 "/usr/include/c++/3.3/bits/type_traits.h" 3
# 90 "/usr/include/c++/3.3/bits/type_traits.h" 3
struct __true_type {};
struct __false_type {};

template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 113 "/usr/include/c++/3.3/bits/type_traits.h" 3
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};




template<> struct __type_traits<bool> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<char> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<signed char> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned char> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<wchar_t> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<short> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned short> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<int> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned int> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<long long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned long long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<float> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<double> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<long double> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template <class _Tp>
struct __type_traits<_Tp*> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};





template <class _Tp> struct _Is_integer {
  typedef __false_type _Integral;
};

template<> struct _Is_integer<bool> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<char> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<signed char> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned char> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<wchar_t> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long long> {
  typedef __true_type _Integral;
};

template<typename _Tp> struct _Is_normal_iterator {
   typedef __false_type _Normal;
};


namespace __gnu_cxx
{
  template<typename _Iterator, typename _Container> class __normal_iterator;
}

template<typename _Iterator, typename _Container>
struct _Is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator, _Container> > {
   typedef __true_type _Normal;
};
# 73 "/usr/include/c++/3.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/3.3/bits/stl_iterator_base_types.h" 1 3
# 67 "/usr/include/c++/3.3/bits/stl_iterator_base_types.h" 3
       
# 68 "/usr/include/c++/3.3/bits/stl_iterator_base_types.h" 3

namespace std
{
# 80 "/usr/include/c++/3.3/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};

  struct bidirectional_iterator_tag : public forward_iterator_tag {};

  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 102 "/usr/include/c++/3.3/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*> {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*> {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 74 "/usr/include/c++/3.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/3.3/bits/stl_iterator_base_funcs.h" 1 3
# 67 "/usr/include/c++/3.3/bits/stl_iterator_base_funcs.h" 3
       
# 68 "/usr/include/c++/3.3/bits/stl_iterator_base_funcs.h" 3
# 1 "/usr/include/c++/3.3/bits/concept_check.h" 1 3
# 38 "/usr/include/c++/3.3/bits/concept_check.h" 3
       
# 39 "/usr/include/c++/3.3/bits/concept_check.h" 3
# 69 "/usr/include/c++/3.3/bits/stl_iterator_base_funcs.h" 2 3

namespace std
{
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last) {
        ++__first; ++__n;
      }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     
      return __last - __first;
    }
# 109 "/usr/include/c++/3.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return __distance(__first, __last, __iterator_category(__first));
    }

  template<typename _InputIter, typename _Distance>
    inline void
    __advance(_InputIter& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--) ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
              bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--) ++__i;
      else
        while (__n++) --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     
      __i += __n;
    }
# 162 "/usr/include/c++/3.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      __advance(__i, __n, __iterator_category(__i));
    }
}
# 75 "/usr/include/c++/3.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/3.3/bits/stl_iterator.h" 1 3
# 68 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
namespace std
{
# 89 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                      typename iterator_traits<_Iterator>::value_type,
                      typename iterator_traits<_Iterator>::difference_type,
                      typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                               difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
        : current(__x.base()) { }




      iterator_type
      base() const { return current; }






      reference
      operator*() const
      {
        _Iterator __tmp = current;
        return *--__tmp;
      }






      pointer
      operator->() const { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
        --current;
        return *this;
      }






      reverse_iterator
      operator++(int)
      {
        reverse_iterator __tmp = *this;
        --current;
        return __tmp;
      }






      reverse_iterator&
      operator--()
      {
        ++current;
        return *this;
      }






      reverse_iterator operator--(int)
      {
        reverse_iterator __tmp = *this;
        ++current;
        return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
        current -= __n;
        return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
        current += __n;
        return *this;
      }






      reference
      operator[](difference_type __n) const { return *(*this + __n); }
    };
# 272 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
               const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
              const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
               const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
              const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
                const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
               const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
              const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
              const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
# 332 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 358 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
        container->push_back(__value);
        return *this;
      }


      back_insert_iterator&
      operator*() { return *this; }


      back_insert_iterator&
      operator++() { return *this; }


      back_insert_iterator
      operator++(int) { return *this; }
    };
# 389 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 404 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 429 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
        container->push_front(__value);
        return *this;
      }


      front_insert_iterator&
      operator*() { return *this; }


      front_insert_iterator&
      operator++() { return *this; }


      front_insert_iterator
      operator++(int) { return *this; }
    };
# 460 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 479 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 521 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
        iter = container->insert(iter, __value);
        ++iter;
        return *this;
      }


      insert_iterator&
      operator*() { return *this; }


      insert_iterator&
      operator++() { return *this; }


      insert_iterator&
      operator++(int) { return *this; }
    };
# 553 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
                                         typename _Container::iterator(__i));
    }
}

namespace __gnu_cxx
{







  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                                                               difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };
# 654 "/usr/include/c++/3.3/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
            const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
            const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
            const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
            const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
}
# 76 "/usr/include/c++/3.3/bits/stl_algobase.h" 2 3


namespace std
{
# 91 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    inline void
    iter_swap(_ForwardIter1 __a, _ForwardIter2 __b)
    {
      typedef typename iterator_traits<_ForwardIter1>::value_type _ValueType1;
      typedef typename iterator_traits<_ForwardIter2>::value_type _ValueType2;


     
     
     
     

      _ValueType1 __tmp = *__a;
      *__a = *__b;
      *__b = __tmp;
    }
# 118 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }
# 146 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a) return __b; return __a;
    }
# 166 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b) return __b; return __a;
    }
# 186 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a)) return __b; return __a;
    }
# 204 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b)) return __b; return __a;
    }
# 221 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy(_InputIter __first, _InputIter __last,
           _OutputIter __result,
           input_iterator_tag)
    {
      for ( ; __first != __last; ++__result, ++__first)
        *__result = *__first;
      return __result;
    }

  template<typename _RandomAccessIter, typename _OutputIter>
    inline _OutputIter
    __copy(_RandomAccessIter __first, _RandomAccessIter __last,
           _OutputIter __result,
           random_access_iterator_tag)
    {
      typedef typename iterator_traits<_RandomAccessIter>::difference_type
          _Distance;
      for (_Distance __n = __last - __first; __n > 0; --__n) {
        *__result = *__first;
        ++__first;
        ++__result;
      }
      return __result;
    }

  template<typename _Tp>
    inline _Tp*
    __copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result)
    {
      memmove(__result, __first, sizeof(_Tp) * (__last - __first));
      return __result + (__last - __first);
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_aux2(_InputIter __first, _InputIter __last,
                _OutputIter __result, __false_type)
    { return __copy(__first, __last, __result, __iterator_category(__first)); }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_aux2(_InputIter __first, _InputIter __last,
                _OutputIter __result, __true_type)
    { return __copy(__first, __last, __result, __iterator_category(__first)); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(_Tp* __first, _Tp* __last,
                _Tp* __result, __true_type)
    { return __copy_trivial(__first, __last, __result); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(const _Tp* __first, const _Tp* __last,
                _Tp* __result, __true_type)
    { return __copy_trivial(__first, __last, __result); }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni2(_InputIter __first, _InputIter __last,
               _OutputIter __result, __true_type)
    {
      typedef typename iterator_traits<_InputIter>::value_type
          _ValueType;
      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator
          _Trivial;
      return _OutputIter(__copy_aux2(__first, __last,
                                     __result.base(),
                                     _Trivial()));
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni2(_InputIter __first, _InputIter __last,
               _OutputIter __result, __false_type)
    {
      typedef typename iterator_traits<_InputIter>::value_type
          _ValueType;
      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator
          _Trivial;
      return __copy_aux2(__first, __last,
                         __result,
                         _Trivial());
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni1(_InputIter __first, _InputIter __last,
               _OutputIter __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;
      return __copy_ni2(__first.base(), __last.base(), __result, __Normal());
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni1(_InputIter __first, _InputIter __last,
               _OutputIter __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;
      return __copy_ni2(__first, __last, __result, __Normal());
    }
# 339 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    copy(_InputIter __first, _InputIter __last, _OutputIter __result)
    {

     
     


       typedef typename _Is_normal_iterator<_InputIter>::_Normal __Normal;
       return __copy_ni1(__first, __last, __result, __Normal());
    }




  template<typename _BidirectionalIter1, typename _BidirectionalIter2>
    inline _BidirectionalIter2
    __copy_backward(_BidirectionalIter1 __first, _BidirectionalIter1 __last,
                    _BidirectionalIter2 __result,
                    bidirectional_iterator_tag)
    {
      while (__first != __last)
        *--__result = *--__last;
      return __result;
    }

  template<typename _RandomAccessIter, typename _BidirectionalIter>
    inline _BidirectionalIter
    __copy_backward(_RandomAccessIter __first, _RandomAccessIter __last,
                    _BidirectionalIter __result,
                    random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIter>::difference_type __n;
      for (__n = __last - __first; __n > 0; --__n)
        *--__result = *--__last;
      return __result;
    }







  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BoolType>
    struct __copy_backward_dispatch
    {
      static _BidirectionalIter2
      copy(_BidirectionalIter1 __first, _BidirectionalIter1 __last,
           _BidirectionalIter2 __result)
      {
        return __copy_backward(__first, __last,
                               __result,
                               __iterator_category(__first));
      }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
        const ptrdiff_t _Num = __last - __first;
        memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
        return __result - _Num;
      }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
        return __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
          ::copy(__first, __last, __result);
      }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>
                            ::has_trivial_assignment_operator _Trivial;
      return __copy_backward_dispatch<_BI1, _BI2, _Trivial>
                  ::copy(__first, __last, __result);
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
                                           _BI2 __result, __true_type)
    { return _BI2(__copy_backward_aux(__first, __last, __result.base())); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
                                           _BI2 __result, __false_type)
    { return __copy_backward_aux(__first, __last, __result); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
                                          _BI2 __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return __copy_backward_output_normal_iterator(__first.base(), __last.base(),
                                                    __result, __Normal());
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
                                          _BI2 __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return __copy_backward_output_normal_iterator(__first, __last, __result,
                                                    __Normal());
    }
# 477 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     



      typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;
      return __copy_backward_input_normal_iterator(__first, __last, __result,
                                                   __Normal());
    }
# 509 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _ForwardIter, typename _Tp>
    void
    fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value)
    {

     

      for ( ; __first != __last; ++__first)
        *__first = __value;
    }
# 531 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _OutputIter, typename _Size, typename _Tp>
    _OutputIter
    fill_n(_OutputIter __first, _Size __n, const _Tp& __value)
    {

     

      for ( ; __n > 0; --__n, ++__first)
        *__first = __value;
      return __first;
    }



  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
    unsigned char __tmp = __c;
    memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
    signed char __tmp = __c;
    memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
    char __tmp = __c;
    memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(char* __first, _Size __n, const signed char& __c)
    {
      fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 606 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2>
    pair<_InputIter1, _InputIter2>
    mismatch(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2)
    {

     
     
     

     


      while (__first1 != __last1 && *__first1 == *__first2) {
        ++__first1;
        ++__first2;
      }
      return pair<_InputIter1, _InputIter2>(__first1, __first2);
    }
# 640 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _BinaryPredicate>
    pair<_InputIter1, _InputIter2>
    mismatch(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2,
             _BinaryPredicate __binary_pred)
    {

     
     

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
        ++__first1;
        ++__first2;
      }
      return pair<_InputIter1, _InputIter2>(__first1, __first2);
    }
# 668 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2>
    inline bool
    equal(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2)
    {

     
     
     



      for ( ; __first1 != __last1; ++__first1, ++__first2)
        if (!(*__first1 == *__first2))
          return false;
      return true;
    }
# 699 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _BinaryPredicate>
    inline bool
    equal(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2,
          _BinaryPredicate __binary_pred)
    {

     
     

      for ( ; __first1 != __last1; ++__first1, ++__first2)
        if (!__binary_pred(*__first1, *__first2))
          return false;
      return true;
    }
# 732 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2>
    bool
    lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2)
    {

     
     
     

     


      for ( ; __first1 != __last1 && __first2 != __last2
            ; ++__first1, ++__first2) {
        if (*__first1 < *__first2)
          return true;
        if (*__first2 < *__first1)
          return false;
      }
      return __first1 == __last1 && __first2 != __last2;
    }
# 767 "/usr/include/c++/3.3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _Compare>
    bool
    lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _Compare __comp)
    {

     
     

      for ( ; __first1 != __last1 && __first2 != __last2
            ; ++__first1, ++__first2) {
        if (__comp(*__first1, *__first2))
          return true;
        if (__comp(*__first2, *__first1))
          return false;
      }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1, const unsigned char* __last1,
                          const unsigned char* __first2, const unsigned char* __last2)
  {
    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = memcmp(__first1, __first2, min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
                          const char* __first2, const char* __last2)
  {

    return lexicographical_compare((const signed char*) __first1,
                                   (const signed char*) __last1,
                                   (const signed char*) __first2,
                                   (const signed char*) __last2);






  }

}
# 55 "/usr/include/c++/3.3/memory" 2 3
# 1 "/usr/include/c++/3.3/bits/stl_alloc.h" 1 3
# 88 "/usr/include/c++/3.3/bits/stl_alloc.h" 3
# 1 "/usr/include/c++/3.3/bits/functexcept.h" 1 3
# 34 "/usr/include/c++/3.3/bits/functexcept.h" 3
# 1 "/usr/include/c++/3.3/exception_defines.h" 1 3
# 35 "/usr/include/c++/3.3/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 89 "/usr/include/c++/3.3/bits/stl_alloc.h" 2 3
# 1 "/usr/include/c++/3.3/bits/stl_threads.h" 1 3
# 54 "/usr/include/c++/3.3/bits/stl_threads.h" 3
namespace std
{




  struct _Refcount_Base
  {

    typedef size_t _RC_t;


    volatile _RC_t _M_ref_count;


    __gthread_mutex_t _M_ref_count_lock;

    _Refcount_Base(_RC_t __n) : _M_ref_count(__n)
    {

      __gthread_mutex_t __tmp = {0, 0, 0, PTHREAD_MUTEX_TIMED_NP, { 0, 0 }};
      _M_ref_count_lock = __tmp;





    }

    void
    _M_incr()
    {
      __gthread_mutex_lock(&_M_ref_count_lock);
      ++_M_ref_count;
      __gthread_mutex_unlock(&_M_ref_count_lock);
    }

    _RC_t
    _M_decr()
    {
      __gthread_mutex_lock(&_M_ref_count_lock);
      volatile _RC_t __tmp = --_M_ref_count;
      __gthread_mutex_unlock(&_M_ref_count_lock);
      return __tmp;
    }
  };
# 109 "/usr/include/c++/3.3/bits/stl_threads.h" 3
  template<int __dummy>
    struct _Swap_lock_struct
    { static __gthread_mutex_t _S_swap_lock; };

  template<int __dummy>
    __gthread_mutex_t
    _Swap_lock_struct<__dummy>::_S_swap_lock = {0, 0, 0, PTHREAD_MUTEX_TIMED_NP, { 0, 0 }};



  inline unsigned long
  _Atomic_swap(unsigned long * __p, unsigned long __q)
  {
    __gthread_mutex_lock(&_Swap_lock_struct<0>::_S_swap_lock);
    unsigned long __result = *__p;
    *__p = __q;
    __gthread_mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);
    return __result;
  }

}
# 155 "/usr/include/c++/3.3/bits/stl_threads.h" 3
namespace std
{
  struct _STL_mutex_lock
  {





    __gthread_mutex_t _M_lock;

    void
    _M_initialize()
    {
# 192 "/usr/include/c++/3.3/bits/stl_threads.h" 3
    }

    void
    _M_acquire_lock()
    {



      __gthread_mutex_lock(&_M_lock);
    }

    void
    _M_release_lock()
    {



      __gthread_mutex_unlock(&_M_lock);
    }
  };
# 228 "/usr/include/c++/3.3/bits/stl_threads.h" 3
  struct _STL_auto_lock
  {
    _STL_mutex_lock& _M_lock;

    _STL_auto_lock(_STL_mutex_lock& __lock) : _M_lock(__lock)
    { _M_lock._M_acquire_lock(); }

    ~_STL_auto_lock() { _M_lock._M_release_lock(); }

  private:
    void operator=(const _STL_auto_lock&);
    _STL_auto_lock(const _STL_auto_lock&);
  };

}
# 90 "/usr/include/c++/3.3/bits/stl_alloc.h" 2 3

# 1 "/usr/include/c++/3.3/i486-linux/bits/atomicity.h" 1 3
# 33 "/usr/include/c++/3.3/i486-linux/bits/atomicity.h" 3
typedef int _Atomic_word;

static inline _Atomic_word

__exchange_and_add (volatile _Atomic_word *__mem, int __val)
{
  register _Atomic_word __result;
  __asm__ __volatile__ ("lock; xadd{l} {%0,%1|%1,%0}"
                        : "=r" (__result), "+m" (*__mem)
                        : "0" (__val)
                        : "memory");
  return __result;
}

static inline void

__atomic_add (volatile _Atomic_word* __mem, int __val)
{
  __asm__ __volatile__ ("lock; add{l} {%1,%0|%0,%1}"
                        : "+m" (*__mem) : "ir" (__val) : "memory");
}
# 92 "/usr/include/c++/3.3/bits/stl_alloc.h" 2 3

namespace std
{
# 103 "/usr/include/c++/3.3/bits/stl_alloc.h" 3
  class __new_alloc
  {
  public:
    static void*
    allocate(size_t __n)
    { return ::operator new(__n); }

    static void
    deallocate(void* __p, size_t)
    { ::operator delete(__p); }
  };
# 126 "/usr/include/c++/3.3/bits/stl_alloc.h" 3
  template<int __inst>
    class __malloc_alloc_template
    {
    private:
      static void* _S_oom_malloc(size_t);
      static void* _S_oom_realloc(void*, size_t);
      static void (* __malloc_alloc_oom_handler)();

    public:
      static void*
      allocate(size_t __n)
      {
        void* __result = malloc(__n);
        if (__builtin_expect(__result == 0, 0))
          __result = _S_oom_malloc(__n);
        return __result;
      }

      static void
      deallocate(void* __p, size_t )
      { free(__p); }

      static void*
      reallocate(void* __p, size_t , size_t __new_sz)
      {
        void* __result = realloc(__p, __new_sz);
        if (__builtin_expect(__result == 0, 0))
          __result = _S_oom_realloc(__p, __new_sz);
        return __result;
      }

      static void (* __set_malloc_handler(void (*__f)()))()
      {
        void (* __old)() = __malloc_alloc_oom_handler;
        __malloc_alloc_oom_handler = __f;
        return __old;
      }
    };


  template<int __inst>
    void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;

  template<int __inst>
    void*
    __malloc_alloc_template<__inst>::
    _S_oom_malloc(size_t __n)
    {
      void (* __my_malloc_handler)();
      void* __result;

      for (;;)
        {
          __my_malloc_handler = __malloc_alloc_oom_handler;
          if (__builtin_expect(__my_malloc_handler == 0, 0))
            __throw_bad_alloc();
          (*__my_malloc_handler)();
          __result = malloc(__n);
          if (__result)
            return __result;
        }
    }

  template<int __inst>
    void*
    __malloc_alloc_template<__inst>::
    _S_oom_realloc(void* __p, size_t __n)
    {
      void (* __my_malloc_handler)();
      void* __result;

      for (;;)
        {
          __my_malloc_handler = __malloc_alloc_oom_handler;
          if (__builtin_expect(__my_malloc_handler == 0, 0))
            __throw_bad_alloc();
          (*__my_malloc_handler)();
          __result = realloc(__p, __n);
          if (__result)
            return __result;
        }
    }


  typedef __new_alloc __mem_interface;
# 223 "/usr/include/c++/3.3/bits/stl_alloc.h" 3
  template<typename _Tp, typename _Alloc>
    class __simple_alloc
    {
    public:
      static _Tp*
      allocate(size_t __n)
      {
        _Tp* __ret = 0;
        if (__n)
          __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));
        return __ret;
      }

      static _Tp*
      allocate()
      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }

      static void
      deallocate(_Tp* __p, size_t __n)
      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }

      static void
      deallocate(_Tp* __p)
      { _Alloc::deallocate(__p, sizeof (_Tp)); }
    };
# 261 "/usr/include/c++/3.3/bits/stl_alloc.h" 3
  template<typename _Alloc>
    class __debug_alloc
    {
    private:


      enum {_S_extra = 8};

    public:
      static void*
      allocate(size_t __n)
      {
        char* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);
        *(size_t*)__result = __n;
        return __result + (int) _S_extra;
      }

      static void
      deallocate(void* __p, size_t __n)
      {
        char* __real_p = (char*)__p - (int) _S_extra;
        if (*(size_t*)__real_p != __n)
          abort();
        _Alloc::deallocate(__real_p, __n + (int) _S_extra);
      }

      static void*
      reallocate(void* __p, size_t __old_sz, size_t __new_sz)
      {
        char* __real_p = (char*)__p - (int) _S_extra;
        if (*(size_t*)__real_p != __old_sz)
          abort();
        char* __result = (char*) _Alloc::reallocate(__real_p,
                                                    __old_sz + (int) _S_extra,
                                                    __new_sz + (int) _S_extra);
        *(size_t*)__result = __new_sz;
        return __result + (int) _S_extra;
      }
    };
# 332 "/usr/include/c++/3.3/bits/stl_alloc.h" 3
  template<bool __threads, int __inst>
    class __default_alloc_template
    {
    private:
      enum {_ALIGN = 8};
      enum {_MAX_BYTES = 128};
      enum {_NFREELISTS = _MAX_BYTES / _ALIGN};

      union _Obj
      {
        union _Obj* _M_free_list_link;
        char _M_client_data[1];
      };

      static _Obj* volatile _S_free_list[_NFREELISTS];


      static char* _S_start_free;
      static char* _S_end_free;
      static size_t _S_heap_size;

      static _STL_mutex_lock _S_node_allocator_lock;

      static size_t
      _S_round_up(size_t __bytes)
      { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }

      static size_t
      _S_freelist_index(size_t __bytes)
      { return (((__bytes) + (size_t)_ALIGN - 1)/(size_t)_ALIGN - 1); }



      static void*
      _S_refill(size_t __n);



      static char*
      _S_chunk_alloc(size_t __size, int& __nobjs);



      struct _Lock
      {
        _Lock() { if (__threads) _S_node_allocator_lock._M_acquire_lock(); }
        ~_Lock() { if (__threads) _S_node_allocator_lock._M_release_lock(); }
      } ;
      friend struct _Lock;

      static _Atomic_word _S_force_new;

    public:

      static void*
      allocate(size_t __n)
      {
        void* __ret = 0;




        if (_S_force_new == 0)
          {
            if (getenv("GLIBCPP_FORCE_NEW"))
              __atomic_add(&_S_force_new, 1);
            else
              __atomic_add(&_S_force_new, -1);
          }

        if ((__n > (size_t) _MAX_BYTES) || (_S_force_new > 0))
          __ret = __new_alloc::allocate(__n);
        else
          {
            _Obj* volatile* __my_free_list = _S_free_list
              + _S_freelist_index(__n);



            _Lock __lock_instance;
            _Obj* __restrict__ __result = *__my_free_list;
            if (__builtin_expect(__result == 0, 0))
              __ret = _S_refill(_S_round_up(__n));
            else
              {
                *__my_free_list = __result -> _M_free_list_link;
                __ret = __result;
              }
            if (__builtin_expect(__ret == 0, 0))
              __throw_bad_alloc();
          }
        return __ret;
      }


      static void
      deallocate(void* __p, size_t __n)
      {
        if ((__n > (size_t) _MAX_BYTES) || (_S_force_new > 0))
          __new_alloc::deallocate(__p, __n);
        else
          {
            _Obj* volatile* __my_free_list = _S_free_list
              + _S_freelist_index(__n);
            _Obj* __q = (_Obj*)__p;




            _Lock __lock_instance;
            __q -> _M_free_list_link = *__my_free_list;
            *__my_free_list = __q;
          }
      }

      static void*
      reallocate(void* __p, size_t __old_sz, size_t __new_sz);
    };

  template<bool __threads, int __inst> _Atomic_word
  __default_alloc_template<__threads, __inst>::_S_force_new = 0;

  template<bool __threads, int __inst>
    inline bool
    operator==(const __default_alloc_template<__threads,__inst>&,
               const __default_alloc_template<__threads,__inst>&)
    { return true; }

  template<bool __threads, int __inst>
    inline bool
    operator!=(const __default_alloc_template<__threads,__inst>&,
               const __default_alloc_template<__threads,__inst>&)
    { return false; }





  template<bool __threads, int __inst>
    char*
    __default_alloc_template<__threads, __inst>::
    _S_chunk_alloc(size_t __size, int& __nobjs)
    {
      char* __result;
      size_t __total_bytes = __size * __nobjs;
      size_t __bytes_left = _S_end_free - _S_start_free;

      if (__bytes_left >= __total_bytes)
        {
          __result = _S_start_free;
          _S_start_free += __total_bytes;
          return __result ;
        }
      else if (__bytes_left >= __size)
        {
          __nobjs = (int)(__bytes_left/__size);
          __total_bytes = __size * __nobjs;
          __result = _S_start_free;
          _S_start_free += __total_bytes;
          return __result;
        }
      else
        {
          size_t __bytes_to_get =
            2 * __total_bytes + _S_round_up(_S_heap_size >> 4);

          if (__bytes_left > 0)
            {
              _Obj* volatile* __my_free_list =
                _S_free_list + _S_freelist_index(__bytes_left);

              ((_Obj*)(void*)_S_start_free) -> _M_free_list_link = *__my_free_list;
              *__my_free_list = (_Obj*)(void*)_S_start_free;
            }
          _S_start_free = (char*) __new_alloc::allocate(__bytes_to_get);
          if (_S_start_free == 0)
            {
              size_t __i;
              _Obj* volatile* __my_free_list;
              _Obj* __p;



              __i = __size;
              for (; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN)
                {
                  __my_free_list = _S_free_list + _S_freelist_index(__i);
                  __p = *__my_free_list;
                  if (__p != 0)
                    {
                      *__my_free_list = __p -> _M_free_list_link;
                      _S_start_free = (char*)__p;
                      _S_end_free = _S_start_free + __i;
                      return _S_chunk_alloc(__size, __nobjs);


                    }
                }
              _S_end_free = 0;
              _S_start_free = (char*)__new_alloc::allocate(__bytes_to_get);


            }
          _S_heap_size += __bytes_to_get;
          _S_end_free = _S_start_free + __bytes_to_get;
          return _S_chunk_alloc(__size, __nobjs);
        }
    }





  template<bool __threads, int __inst>
    void*
    __default_alloc_template<__threads, __inst>::_S_refill(size_t __n)
    {
      int __nobjs = 20;
      char* __chunk = _S_chunk_alloc(__n, __nobjs);
      _Obj* volatile* __my_free_list;
      _Obj* __result;
      _Obj* __current_obj;
      _Obj* __next_obj;
      int __i;

      if (1 == __nobjs)
        return __chunk;
      __my_free_list = _S_free_list + _S_freelist_index(__n);


      __result = (_Obj*)(void*)__chunk;
      *__my_free_list = __next_obj = (_Obj*)(void*)(__chunk + __n);
      for (__i = 1; ; __i++)
        {
          __current_obj = __next_obj;
          __next_obj = (_Obj*)(void*)((char*)__next_obj + __n);
          if (__nobjs - 1 == __i)
            {
              __current_obj -> _M_free_list_link = 0;
              break;
            }
          else
            __current_obj -> _M_free_list_link = __next_obj;
        }
      return __result;
    }


  template<bool threads, int inst>
    void*
    __default_alloc_template<threads, inst>::
    reallocate(void* __p, size_t __old_sz, size_t __new_sz)
    {
      void* __result;
      size_t __copy_sz;

      if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES)
        return(realloc(__p, __new_sz));
      if (_S_round_up(__old_sz) == _S_round_up(__new_sz))
        return(__p);
      __result = allocate(__new_sz);
      __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;
      memcpy(__result, __p, __copy_sz);
      deallocate(__p, __old_sz);
      return __result;
    }

  template<bool __threads, int __inst>
    _STL_mutex_lock
    __default_alloc_template<__threads,__inst>::_S_node_allocator_lock
    = { {0, 0, 0, PTHREAD_MUTEX_TIMED_NP, { 0, 0 }} };

  template<bool __threads, int __inst>
    char* __default_alloc_template<__threads,__inst>::_S_start_free = 0;

  template<bool __threads, int __inst>
    char* __default_alloc_template<__threads,__inst>::_S_end_free = 0;

  template<bool __threads, int __inst>
    size_t __default_alloc_template<__threads,__inst>::_S_heap_size = 0;

  template<bool __threads, int __inst>
    typename __default_alloc_template<__threads,__inst>::_Obj* volatile
    __default_alloc_template<__threads,__inst>::_S_free_list[_NFREELISTS];

  typedef __default_alloc_template<true,0> __alloc;
  typedef __default_alloc_template<false,0> __single_client_alloc;
# 635 "/usr/include/c++/3.3/bits/stl_alloc.h" 3
  template<typename _Tp>
    class allocator
    {
      typedef __alloc _Alloc;
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() {}
      allocator(const allocator&) {}
      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) {}
      ~allocator() {}

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      _Tp*
      allocate(size_type __n, const void* = 0)
      {
        _Tp* __ret = 0;
        if (__n)
          {
            if (__n <= this->max_size())
              __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));
            else
              __throw_bad_alloc();
          }
        return __ret;
      }


      void
      deallocate(pointer __p, size_type __n)
      { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }

      size_type
      max_size() const { return size_t(-1) / sizeof(_Tp); }

      void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
      void destroy(pointer __p) { __p->~_Tp(); }
    };

  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };


  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }
# 731 "/usr/include/c++/3.3/bits/stl_alloc.h" 3
  template<typename _Tp, typename _Alloc>
    struct __allocator
    {
      _Alloc __underlying_alloc;

      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef __allocator<_Tp1, _Alloc> other; };

      __allocator() {}
      __allocator(const __allocator& __a)
      : __underlying_alloc(__a.__underlying_alloc) {}

      template<typename _Tp1>
        __allocator(const __allocator<_Tp1, _Alloc>& __a)
        : __underlying_alloc(__a.__underlying_alloc) {}

      ~__allocator() {}

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      _Tp*
      allocate(size_type __n, const void* = 0)
      {
        _Tp* __ret = 0;
        if (__n)
          __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));
        return __ret;
      }


      void
      deallocate(pointer __p, size_type __n)
      { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }

      size_type
      max_size() const { return size_t(-1) / sizeof(_Tp); }

      void
      construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Alloc>
    struct __allocator<void, _Alloc>
    {
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef __allocator<_Tp1, _Alloc> other; };
    };

  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const __allocator<_Tp,_Alloc>& __a1,
               const __allocator<_Tp,_Alloc>& __a2)
    { return __a1.__underlying_alloc == __a2.__underlying_alloc; }

  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const __allocator<_Tp, _Alloc>& __a1,
               const __allocator<_Tp, _Alloc>& __a2)
    { return __a1.__underlying_alloc != __a2.__underlying_alloc; }







  template<int inst>
    inline bool
    operator==(const __malloc_alloc_template<inst>&,
               const __malloc_alloc_template<inst>&)
    { return true; }

  template<int __inst>
    inline bool
    operator!=(const __malloc_alloc_template<__inst>&,
               const __malloc_alloc_template<__inst>&)
    { return false; }

  template<typename _Alloc>
    inline bool
    operator==(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)
    { return true; }

  template<typename _Alloc>
    inline bool
    operator!=(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)
    { return false; }
# 884 "/usr/include/c++/3.3/bits/stl_alloc.h" 3
  template<typename _Tp, typename _Allocator>
    struct _Alloc_traits
    {
      static const bool _S_instanceless = false;
      typedef typename _Allocator::template rebind<_Tp>::other allocator_type;
    };

  template<typename _Tp, typename _Allocator>
    const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;


  template<typename _Tp, typename _Tp1>
    struct _Alloc_traits<_Tp, allocator<_Tp1> >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __alloc> _Alloc_type;
      typedef allocator<_Tp> allocator_type;
    };




  template<typename _Tp, int __inst>
    struct _Alloc_traits<_Tp, __malloc_alloc_template<__inst> >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
      typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
    };

  template<typename _Tp, bool __threads, int __inst>
    struct _Alloc_traits<_Tp, __default_alloc_template<__threads, __inst> >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __default_alloc_template<__threads, __inst> >
      _Alloc_type;
      typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> >
      allocator_type;
    };

  template<typename _Tp, typename _Alloc>
    struct _Alloc_traits<_Tp, __debug_alloc<_Alloc> >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;
      typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;
    };





  template<typename _Tp, typename _Tp1, int __inst>
    struct _Alloc_traits<_Tp,
                         __allocator<_Tp1, __malloc_alloc_template<__inst> > >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
      typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
    };

  template<typename _Tp, typename _Tp1, bool __thr, int __inst>
    struct _Alloc_traits<_Tp, __allocator<_Tp1, __default_alloc_template<__thr, __inst> > >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __default_alloc_template<__thr,__inst> >
      _Alloc_type;
      typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> >
      allocator_type;
    };

  template<typename _Tp, typename _Tp1, typename _Alloc>
    struct _Alloc_traits<_Tp, __allocator<_Tp1, __debug_alloc<_Alloc> > >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;
      typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;
  extern template class __default_alloc_template<true,0>;

}
# 56 "/usr/include/c++/3.3/memory" 2 3
# 1 "/usr/include/c++/3.3/bits/stl_construct.h" 1 3
# 67 "/usr/include/c++/3.3/bits/stl_construct.h" 3
namespace std
{






  template <class _T1, class _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    { new (static_cast<void*>(__p)) _T1(__value); }







  template <class _T1>
    inline void
    _Construct(_T1* __p)
    { new (static_cast<void*>(__p)) _T1(); }
# 98 "/usr/include/c++/3.3/bits/stl_construct.h" 3
  template <class _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)
    { for ( ; __first != __last; ++__first) _Destroy(&*__first); }
# 112 "/usr/include/c++/3.3/bits/stl_construct.h" 3
  template <class _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }






  template <class _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 134 "/usr/include/c++/3.3/bits/stl_construct.h" 3
  template <class _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename __type_traits<_Value_type>::has_trivial_destructor
                       _Has_trivial_destructor;

      __destroy_aux(__first, __last, _Has_trivial_destructor());
    }
}
# 57 "/usr/include/c++/3.3/memory" 2 3

# 1 "/usr/include/c++/3.3/bits/stl_uninitialized.h" 1 3
# 66 "/usr/include/c++/3.3/bits/stl_uninitialized.h" 3
namespace std
{



  template<typename _InputIter, typename _ForwardIter>
    inline _ForwardIter
    __uninitialized_copy_aux(_InputIter __first, _InputIter __last,
                             _ForwardIter __result,
                             __true_type)
    { return copy(__first, __last, __result); }

  template<typename _InputIter, typename _ForwardIter>
    _ForwardIter
    __uninitialized_copy_aux(_InputIter __first, _InputIter __last,
                             _ForwardIter __result,
                             __false_type)
    {
      _ForwardIter __cur = __result;
      if (true) {
        for ( ; __first != __last; ++__first, ++__cur)
          _Construct(&*__cur, *__first);
        return __cur;
      }
      if (false)
        {
          _Destroy(__result, __cur);
          ;
        }
    }
# 106 "/usr/include/c++/3.3/bits/stl_uninitialized.h" 3
  template<typename _InputIter, typename _ForwardIter>
    inline _ForwardIter
    uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return __uninitialized_copy_aux(__first, __last, __result, _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
                     wchar_t* __result)
  {
    memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIter, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last,
                             const _Tp& __x, __true_type)
    { fill(__first, __last, __x); }

  template<typename _ForwardIter, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last,
                             const _Tp& __x, __false_type)
    {
      _ForwardIter __cur = __first;
      if (true) {
        for ( ; __cur != __last; ++__cur)
          _Construct(&*__cur, __x);
      }
      if (false)
        {
          _Destroy(__first, __cur);
          ;
        }
    }
# 164 "/usr/include/c++/3.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIter, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      __uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIter, typename _Size, typename _Tp>
    inline _ForwardIter
    __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
                               const _Tp& __x, __true_type)
    {
      return fill_n(__first, __n, __x);
    }

  template<typename _ForwardIter, typename _Size, typename _Tp>
    _ForwardIter
    __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
                               const _Tp& __x, __false_type)
    {
      _ForwardIter __cur = __first;
      if (true) {
        for ( ; __n > 0; --__n, ++__cur)
          _Construct(&*__cur, __x);
        return __cur;
      }
      if (false)
        {
          _Destroy(__first, __cur);
          ;
        }
    }
# 210 "/usr/include/c++/3.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIter, typename _Size, typename _Tp>
    inline _ForwardIter
    uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }
# 227 "/usr/include/c++/3.3/bits/stl_uninitialized.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _ForwardIter>
    inline _ForwardIter
    __uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2,
                              _ForwardIter __result)
    {
      _ForwardIter __mid = uninitialized_copy(__first1, __last1, __result);
      if (true) {
        return uninitialized_copy(__first2, __last2, __mid);
      }
      if (false)
        {
          _Destroy(__result, __mid);
          ;
        }
    }




  template<typename _ForwardIter, typename _Tp, typename _InputIter>
    inline _ForwardIter
    __uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid,
                              const _Tp& __x,
                              _InputIter __first, _InputIter __last)
    {
      uninitialized_fill(__result, __mid, __x);
      if (true) {
        return uninitialized_copy(__first, __last, __mid);
      }
      if (false)
        {
          _Destroy(__result, __mid);
          ;
        }
    }




  template<typename _InputIter, typename _ForwardIter, typename _Tp>
    inline void
    __uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
                              _ForwardIter __first2, _ForwardIter __last2,
                              const _Tp& __x)
    {
      _ForwardIter __mid2 = uninitialized_copy(__first1, __last1, __first2);
      if (true) {
        uninitialized_fill(__mid2, __last2, __x);
      }
      if (false)
        {
          _Destroy(__first2, __mid2);
          ;
        }
    }

}
# 59 "/usr/include/c++/3.3/memory" 2 3
# 1 "/usr/include/c++/3.3/bits/stl_raw_storage_iter.h" 1 3
# 64 "/usr/include/c++/3.3/bits/stl_raw_storage_iter.h" 3
namespace std
{




  template <class _ForwardIterator, class _Tp>
  class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
        _Construct(&*_M_iter, __element);
        return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
        ++_M_iter;
        return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
        raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
        ++_M_iter;
        return __tmp;
      }
    };
}
# 60 "/usr/include/c++/3.3/memory" 2 3

namespace std
{
# 71 "/usr/include/c++/3.3/memory" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      if (__len > ptrdiff_t(2147483647 / sizeof(_Tp)))
        __len = 2147483647 / sizeof(_Tp);

      while (__len > 0)
        {
          _Tp* __tmp = (_Tp*) std::malloc((std::size_t)__len * sizeof(_Tp));
          if (__tmp != 0)
            return pair<_Tp*, ptrdiff_t>(__tmp, __len);
          __len /= 2;
        }
      return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
    }
# 103 "/usr/include/c++/3.3/memory" 3
  template<typename _Tp>
    inline pair<_Tp*,ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return __get_temporary_buffer(__len, (_Tp*) 0); }
# 115 "/usr/include/c++/3.3/memory" 3
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { std::free(__p); }
# 127 "/usr/include/c++/3.3/memory" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
# 166 "/usr/include/c++/3.3/memory" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) : _M_ptr(__p) { }
# 192 "/usr/include/c++/3.3/memory" 3
      auto_ptr(auto_ptr& __a) : _M_ptr(__a.release()) { }
# 203 "/usr/include/c++/3.3/memory" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) : _M_ptr(__a.release()) { }
# 214 "/usr/include/c++/3.3/memory" 3
      auto_ptr&
      operator=(auto_ptr& __a)
      {
        reset(__a.release());
        return *this;
      }
# 231 "/usr/include/c++/3.3/memory" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a)
        {
          reset(__a.release());
          return *this;
        }
# 251 "/usr/include/c++/3.3/memory" 3
      ~auto_ptr() { delete _M_ptr; }
# 261 "/usr/include/c++/3.3/memory" 3
      element_type&
      operator*() const { return *_M_ptr; }







      element_type*
      operator->() const { return _M_ptr; }
# 283 "/usr/include/c++/3.3/memory" 3
      element_type*
      get() const { return _M_ptr; }
# 297 "/usr/include/c++/3.3/memory" 3
      element_type*
      release()
      {
        element_type* __tmp = _M_ptr;
        _M_ptr = 0;
        return __tmp;
      }
# 312 "/usr/include/c++/3.3/memory" 3
      void
      reset(element_type* __p = 0)
      {
        if (__p != _M_ptr)
          {
            delete _M_ptr;
            _M_ptr = __p;
          }
      }
# 333 "/usr/include/c++/3.3/memory" 3
      auto_ptr(auto_ptr_ref<element_type> __ref)
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref)
      {
        if (__ref._M_ptr != this->get())
          {
            delete _M_ptr;
            _M_ptr = __ref._M_ptr;
          }
        return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>()
        { return auto_ptr<_Tp1>(this->release()); }

  };
}
# 49 "/usr/include/c++/3.3/string" 2 3



# 1 "/usr/include/c++/3.3/bits/stl_function.h" 1 3
# 64 "/usr/include/c++/3.3/bits/stl_function.h" 3
namespace std
{
# 101 "/usr/include/c++/3.3/bits/stl_function.h" 3
template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};




template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};
# 127 "/usr/include/c++/3.3/bits/stl_function.h" 3
template <class _Tp>
struct plus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};


template <class _Tp>
struct minus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};


template <class _Tp>
struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};


template <class _Tp>
struct divides : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};


template <class _Tp>
struct modulus : public binary_function<_Tp,_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};


template <class _Tp>
struct negate : public unary_function<_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x) const { return -__x; }
};
# 173 "/usr/include/c++/3.3/bits/stl_function.h" 3
template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};


template <class _Tp>
struct not_equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};


template <class _Tp>
struct greater : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};


template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
};


template <class _Tp>
struct greater_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};


template <class _Tp>
struct less_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};
# 222 "/usr/include/c++/3.3/bits/stl_function.h" 3
template <class _Tp>
struct logical_and : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};


template <class _Tp>
struct logical_or : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};


template <class _Tp>
struct logical_not : public unary_function<_Tp,bool>
{
  bool operator()(const _Tp& __x) const { return !__x; }
};
# 271 "/usr/include/c++/3.3/bits/stl_function.h" 3
template <class _Predicate>
class unary_negate
  : public unary_function<typename _Predicate::argument_type, bool> {
protected:
  _Predicate _M_pred;
public:
  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::argument_type& __x) const {
    return !_M_pred(__x);
  }
};


template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate& __pred)
{
  return unary_negate<_Predicate>(__pred);
}


template <class _Predicate>
class binary_negate
  : public binary_function<typename _Predicate::first_argument_type,
                           typename _Predicate::second_argument_type,
                           bool> {
protected:
  _Predicate _M_pred;
public:
  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::first_argument_type& __x,
                  const typename _Predicate::second_argument_type& __y) const
  {
    return !_M_pred(__x, __y);
  }
};


template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate& __pred)
{
  return binary_negate<_Predicate>(__pred);
}
# 349 "/usr/include/c++/3.3/bits/stl_function.h" 3
template <class _Operation>
class binder1st
  : public unary_function<typename _Operation::second_argument_type,
                          typename _Operation::result_type> {
protected:
  _Operation op;
  typename _Operation::first_argument_type value;
public:
  binder1st(const _Operation& __x,
            const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}
  typename _Operation::result_type
  operator()(const typename _Operation::second_argument_type& __x) const {
    return op(value, __x);
  }


  typename _Operation::result_type
  operator()(typename _Operation::second_argument_type& __x) const {
    return op(value, __x);
  }

};


template <class _Operation, class _Tp>
inline binder1st<_Operation>
bind1st(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::first_argument_type _Arg1_type;
  return binder1st<_Operation>(__fn, _Arg1_type(__x));
}


template <class _Operation>
class binder2nd
  : public unary_function<typename _Operation::first_argument_type,
                          typename _Operation::result_type> {
protected:
  _Operation op;
  typename _Operation::second_argument_type value;
public:
  binder2nd(const _Operation& __x,
            const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}
  typename _Operation::result_type
  operator()(const typename _Operation::first_argument_type& __x) const {
    return op(__x, value);
  }


  typename _Operation::result_type
  operator()(typename _Operation::first_argument_type& __x) const {
    return op(__x, value);
  }

};


template <class _Operation, class _Tp>
inline binder2nd<_Operation>
bind2nd(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::second_argument_type _Arg2_type;
  return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}
# 438 "/usr/include/c++/3.3/bits/stl_function.h" 3
template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
  _Result (*_M_ptr)(_Arg);
public:
  pointer_to_unary_function() {}
  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
};


template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))
{
  return pointer_to_unary_function<_Arg, _Result>(__x);
}


template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function :
  public binary_function<_Arg1,_Arg2,_Result> {
protected:
    _Result (*_M_ptr)(_Arg1, _Arg2);
public:
    pointer_to_binary_function() {}
    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
    _Result operator()(_Arg1 __x, _Arg2 __y) const {
      return _M_ptr(__x, __y);
    }
};


template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__x)(_Arg1, _Arg2)) {
  return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__x);
}


template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  _Tp& operator()(_Tp& __x) const { return __x; }
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  typename _Pair::first_type& operator()(_Pair& __x) const {
    return __x.first;
  }
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
{
  typename _Pair::second_type& operator()(_Pair& __x) const {
    return __x.second;
  }
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};
# 528 "/usr/include/c++/3.3/bits/stl_function.h" 3
template <class _Ret, class _Tp>
class mem_fun_t : public unary_function<_Tp*,_Ret> {
public:
  explicit mem_fun_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)();
};


template <class _Ret, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
public:
  explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)() const;
};


template <class _Ret, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
public:
  explicit mem_fun_ref_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)();
};


template <class _Ret, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
public:
  explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)() const;
};


template <class _Ret, class _Tp, class _Arg>
class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
public:
  explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg);
};


template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
public:
  explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p, _Arg __x) const
    { return (__p->*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg) const;
};


template <class _Ret, class _Tp, class _Arg>
class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
public:
  explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg);
};


template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
public:
  explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg) const;
};


template <class _Tp>
class mem_fun_t<void, _Tp> : public unary_function<_Tp*,void> {
public:
  explicit mem_fun_t(void (_Tp::*__pf)()) : _M_f(__pf) {}
  void operator()(_Tp* __p) const { (__p->*_M_f)(); }
private:
  void (_Tp::*_M_f)();
};


template <class _Tp>
class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*,void> {
public:
  explicit const_mem_fun_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}
  void operator()(const _Tp* __p) const { (__p->*_M_f)(); }
private:
  void (_Tp::*_M_f)() const;
};


template <class _Tp>
class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
public:
  explicit mem_fun_ref_t(void (_Tp::*__pf)()) : _M_f(__pf) {}
  void operator()(_Tp& __r) const { (__r.*_M_f)(); }
private:
  void (_Tp::*_M_f)();
};


template <class _Tp>
class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
public:
  explicit const_mem_fun_ref_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}
  void operator()(const _Tp& __r) const { (__r.*_M_f)(); }
private:
  void (_Tp::*_M_f)() const;
};


template <class _Tp, class _Arg>
class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*,_Arg,void> {
public:
  explicit mem_fun1_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  void operator()(_Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg);
};


template <class _Tp, class _Arg>
class const_mem_fun1_t<void, _Tp, _Arg>
  : public binary_function<const _Tp*,_Arg,void> {
public:
  explicit const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  void operator()(const _Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg) const;
};


template <class _Tp, class _Arg>
class mem_fun1_ref_t<void, _Tp, _Arg>
  : public binary_function<_Tp,_Arg,void> {
public:
  explicit mem_fun1_ref_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  void operator()(_Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg);
};


template <class _Tp, class _Arg>
class const_mem_fun1_ref_t<void, _Tp, _Arg>
  : public binary_function<_Tp,_Arg,void> {
public:
  explicit const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  void operator()(const _Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg) const;
};





template <class _Ret, class _Tp>
inline mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)())
  { return mem_fun_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp>
inline const_mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)() const)
  { return const_mem_fun_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp>
inline mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)())
  { return mem_fun_ref_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp>
inline const_mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)() const)
  { return const_mem_fun_ref_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))
  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const)
  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>
mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }



}
# 53 "/usr/include/c++/3.3/string" 2 3
# 1 "/usr/include/c++/3.3/bits/basic_string.h" 1 3
# 43 "/usr/include/c++/3.3/bits/basic_string.h" 3
       
# 44 "/usr/include/c++/3.3/bits/basic_string.h" 3



namespace std
{
# 108 "/usr/include/c++/3.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {

    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _Alloc::size_type size_type;
      typedef typename _Alloc::difference_type difference_type;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 143 "/usr/include/c++/3.3/bits/basic_string.h" 3
      struct _Rep
      {

        typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 161 "/usr/include/c++/3.3/bits/basic_string.h" 3
        static const size_type _S_max_size;
        static const _CharT _S_terminal;

        size_type _M_length;
        size_type _M_capacity;
        _Atomic_word _M_references;

        bool
        _M_is_leaked() const
        { return _M_references < 0; }

        bool
        _M_is_shared() const
        { return _M_references > 0; }

        void
        _M_set_leaked()
        { _M_references = -1; }

        void
        _M_set_sharable()
        { _M_references = 0; }

        _CharT*
        _M_refdata()
        { return reinterpret_cast<_CharT*>(this + 1); }

        _CharT&
        operator[](size_t __s)
        { return _M_refdata() [__s]; }

        _CharT*
        _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
        {
          return (!_M_is_leaked() && __alloc1 == __alloc2)
                  ? _M_refcopy() : _M_clone(__alloc1);
        }


        static _Rep*
        _S_create(size_t, const _Alloc&);

        void
        _M_dispose(const _Alloc& __a)
        {
          if (__exchange_and_add(&_M_references, -1) <= 0)
            _M_destroy(__a);
        }

        void
        _M_destroy(const _Alloc&) ;

        _CharT*
        _M_refcopy()
        {
          __atomic_add(&_M_references, 1);
          return _M_refdata();
        }

        _CharT*
        _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
        _Alloc_hider(_CharT* __dat, const _Alloc& __a)
        : _Alloc(__a), _M_p(__dat) { }

        _CharT* _M_p;
      };

    public:



      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;



      static size_type _S_empty_rep_storage[(sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const { return iterator(_M_data()); }

      iterator
      _M_iend() const { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
        if (!_M_rep()->_M_is_leaked())
          _M_leak_hard();
      }

      iterator
      _M_check(size_type __pos) const
      {
        if (__pos > this->size())
          __throw_out_of_range("basic_string::_M_check");
        return _M_ibegin() + __pos;
      }


      iterator
      _M_fold(size_type __pos, size_type __off) const
      {
        bool __testoff = __off < this->size() - __pos;
        size_type __newoff = __testoff ? __off : this->size() - __pos;
        return (_M_ibegin() + __pos + __newoff);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
          for (; __k1 != __k2; ++__k1, ++__p)
            traits_type::assign(*__p, *__k1);
        }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }

    public:




      inline
      basic_string();

      explicit
      basic_string(const _Alloc& __a);


      basic_string(const basic_string& __str);
      basic_string(const basic_string& __str, size_type __pos,
                   size_type __n = npos);
      basic_string(const basic_string& __str, size_type __pos,
                   size_type __n, const _Alloc& __a);

      basic_string(const _CharT* __s, size_type __n,
                   const _Alloc& __a = _Alloc());
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());

      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
                     const _Alloc& __a = _Alloc());

      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }

      basic_string&
      operator=(const basic_string& __str) { return this->assign(__str); }

      basic_string&
      operator=(const _CharT* __s) { return this->assign(__s); }

      basic_string&
      operator=(_CharT __c) { return this->assign(1, __c); }


      iterator
      begin()
      {
        _M_leak();
        return iterator(_M_data());
      }

      const_iterator
      begin() const
      { return const_iterator(_M_data()); }

      iterator
      end()
      {
         _M_leak();
         return iterator(_M_data() + this->size());
      }

      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }

      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:

      size_type
      size() const { return _M_rep()->_M_length; }

      size_type
      length() const { return _M_rep()->_M_length; }

      size_type
      max_size() const { return _Rep::_S_max_size; }

      void
      resize(size_type __n, _CharT __c);

      void
      resize(size_type __n) { this->resize(__n, _CharT()); }

      size_type
      capacity() const { return _M_rep()->_M_capacity; }

      void
      reserve(size_type __res_arg = 0);

      void
      clear() { _M_mutate(0, this->size(), 0); }

      bool
      empty() const { return this->size() == 0; }


      const_reference
      operator[] (size_type __pos) const
      { return _M_data()[__pos]; }

      reference
      operator[](size_type __pos)
      {
        _M_leak();
        return _M_data()[__pos];
      }

      const_reference
      at(size_type __n) const
      {
        if (__n >= this->size())
          __throw_out_of_range("basic_string::at");
        return _M_data()[__n];
      }

      reference
      at(size_type __n)
      {
        if (__n >= size())
          __throw_out_of_range("basic_string::at");
        _M_leak();
        return _M_data()[__n];
      }


      basic_string&
      operator+=(const basic_string& __str) { return this->append(__str); }

      basic_string&
      operator+=(const _CharT* __s) { return this->append(__s); }

      basic_string&
      operator+=(_CharT __c) { return this->append(size_type(1), __c); }

      basic_string&
      append(const basic_string& __str);

      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);

      basic_string&
      append(const _CharT* __s, size_type __n);

      basic_string&
      append(const _CharT* __s)
      { return this->append(__s, traits_type::length(__s)); }

      basic_string&
      append(size_type __n, _CharT __c);

      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }

      void
      push_back(_CharT __c)
      { this->replace(_M_iend(), _M_iend(), 1, __c); }

      basic_string&
      assign(const basic_string& __str);

      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n);

      basic_string&
      assign(const _CharT* __s, size_type __n);

      basic_string&
      assign(const _CharT* __s)
      { return this->assign(__s, traits_type::length(__s)); }

      basic_string&
      assign(size_type __n, _CharT __c)
      { return this->replace(_M_ibegin(), _M_iend(), __n, __c); }

      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }

      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }

      template<class _InputIterator>
        void insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }

      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, 0, __str.size()); }

      basic_string&
      insert(size_type __pos1, const basic_string& __str,
             size_type __pos2, size_type __n);

      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);

      basic_string&
      insert(size_type __pos, const _CharT* __s)
      { return this->insert(__pos, __s, traits_type::length(__s)); }

      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      {
        this->insert(_M_check(__pos), __n, __c);
        return *this;
      }

      iterator
      insert(iterator __p, _CharT __c = _CharT())
      {
        size_type __pos = __p - _M_ibegin();
        this->insert(_M_check(__pos), size_type(1), __c);
        _M_rep()->_M_set_leaked();
        return this->_M_ibegin() + __pos;
      }

      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
        return this->replace(_M_check(__pos), _M_fold(__pos, __n),
                             _M_data(), _M_data());
      }

      iterator
      erase(iterator __position)
      {
        size_type __i = __position - _M_ibegin();
        this->replace(__position, __position + 1, _M_data(), _M_data());
        _M_rep()->_M_set_leaked();
        return _M_ibegin() + __i;
      }

      iterator
      erase(iterator __first, iterator __last)
      {
        size_type __i = __first - _M_ibegin();
        this->replace(__first, __last, _M_data(), _M_data());
        _M_rep()->_M_set_leaked();
       return _M_ibegin() + __i;
      }

      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }

      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
              size_type __pos2, size_type __n2);

      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
              size_type __n2);

      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      { return this->replace(__pos, __n1, __s, traits_type::length(__s)); }

      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return this->replace(_M_check(__pos), _M_fold(__pos, __n1), __n2, __c); }

      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }

      basic_string&
      replace(iterator __i1, iterator __i2,
                           const _CharT* __s, size_type __n)
      { return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n); }

      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      { return this->replace(__i1, __i2, __s, traits_type::length(__s)); }

      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c);

      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
                _InputIterator __k1, _InputIterator __k2)
        { return _M_replace(__i1, __i2, __k1, __k2,
             typename iterator_traits<_InputIterator>::iterator_category()); }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                               __k1, __k2 - __k1); }

      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __k1, const _CharT* __k2)
        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                               __k1, __k2 - __k1); }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                               __k1.base(), __k2 - __k1);
        }

      basic_string&
      replace(iterator __i1, iterator __i2, const_iterator __k1, const_iterator __k2)
        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                               __k1.base(), __k2 - __k1);
        }

    private:
      template<class _InputIterator>
        basic_string&
        _M_replace(iterator __i1, iterator __i2, _InputIterator __k1,
                   _InputIterator __k2, input_iterator_tag);

      template<class _ForwardIterator>
        basic_string&
        _M_replace_safe(iterator __i1, iterator __i2, _ForwardIterator __k1,
                   _ForwardIterator __k2);



      template<class _InIter>
        static _CharT*
        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,
                         __false_type)
        {
          typedef typename iterator_traits<_InIter>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
        }

      template<class _InIter>
        static _CharT*
        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,
                         __true_type)
        {
          return _S_construct(static_cast<size_type>(__beg),
                              static_cast<value_type>(__end), __a);
        }

      template<class _InIter>
        static _CharT*
        _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a)
        {
          typedef typename _Is_integer<_InIter>::_Integral _Integral;
          return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIter>
        static _CharT*
         _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,
                      input_iterator_tag);



      template<class _FwdIter>
        static _CharT*
        _S_construct(_FwdIter __beg, _FwdIter __end, const _Alloc& __a,
                     forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:

      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;

      void
      swap(basic_string<_CharT, _Traits, _Alloc>& __s);


      const _CharT*
      c_str() const
      {

        size_type __n = this->size();
        traits_type::assign(_M_data()[__n], _Rep::_S_terminal);
        return _M_data();
      }

      const _CharT*
      data() const { return _M_data(); }

      allocator_type
      get_allocator() const { return _M_dataplus; }

      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }

      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      { return this->find(__s, __pos, traits_type::length(__s)); }

      size_type
      find(_CharT __c, size_type __pos = 0) const;

      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }

      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      { return this->rfind(__s, __pos, traits_type::length(__s)); }

      size_type
      rfind(_CharT __c, size_type __pos = npos) const;

      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }

      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      { return this->find_first_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }

      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }

      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      { return this->find_last_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }

      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }

      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
                        size_type __n) const;

      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      { return this->find_first_not_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;

      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }

      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
                       size_type __n) const;
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      { return this->find_last_not_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;

      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      {
        if (__pos > this->size())
          __throw_out_of_range("basic_string::substr");
        return basic_string(*this, __pos, __n);
      }

      int
      compare(const basic_string& __str) const
      {
        size_type __size = this->size();
        size_type __osize = __str.size();
        size_type __len = std::min(__size, __osize);

        int __r = traits_type::compare(_M_data(), __str.data(), __len);
        if (!__r)
          __r = __size - __osize;
        return __r;
      }

      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;

      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
              size_type __pos2, size_type __n2) const;

      int
      compare(const _CharT* __s) const;



      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;

      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
              size_type __n2) const;
  };


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()
    : _M_dataplus(_S_empty_rep()._M_refcopy(), _Alloc()) { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
              const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
             const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
  { return __rhs.compare(__lhs) >= 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
             const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
         basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               basic_string<_CharT, _Traits, _Alloc>& __str);

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const basic_string<_CharT, _Traits, _Alloc>& __str);

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
            basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
            basic_string<_CharT, _Traits, _Alloc>& __str);
}
# 54 "/usr/include/c++/3.3/string" 2 3


# 1 "/usr/include/c++/3.3/algorithm" 1 3
# 64 "/usr/include/c++/3.3/algorithm" 3
       
# 65 "/usr/include/c++/3.3/algorithm" 3




# 1 "/usr/include/c++/3.3/bits/stl_algo.h" 1 3
# 64 "/usr/include/c++/3.3/bits/stl_algo.h" 3
# 1 "/usr/include/c++/3.3/bits/stl_heap.h" 1 3
# 63 "/usr/include/c++/3.3/bits/stl_heap.h" 3
namespace std
{



  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
                _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value) {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
      *(__first + __holeIndex) = __value;
    }

  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     

     

      __push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0),
                  _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
            typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value)) {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
      *(__first + __holeIndex) = __value;
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
              _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     


      __push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0),
                  _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                  _Distance __len, _Tp __value)
    {
      _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len) {
        if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
          __secondChild--;
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
      }
      if (__secondChild == __len) {
        *(__first + __holeIndex) = *(__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
      }
      __push_heap(__first, __holeIndex, __topIndex, __value);
    }

  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
               _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;
      *__result = *__first;
      __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);
    }

  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;


     

     

      __pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance,
           typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                  _Distance __len, _Tp __value, _Compare __comp)
    {
      _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len) {
        if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))
          __secondChild--;
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
      }
      if (__secondChild == __len) {
        *(__first + __holeIndex) = *(__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
      }
      __push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
               _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;
      *__result = *__first;
      __adjust_heap(__first, _Distance(0), _Distance(__last - __first),
                    __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
             _RandomAccessIterator __last, _Compare __comp)
    {

     


      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
      __pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     

     

      if (__last - __first < 2) return;
      _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2)/2;

      while (true) {
        __adjust_heap(__first, __parent, __len, _ValueType(*(__first + __parent)));
        if (__parent == 0) return;
        __parent--;
      }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
              _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     


      if (__last - __first < 2) return;
      _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2)/2;

      while (true) {
        __adjust_heap(__first, __parent, __len,
                      _ValueType(*(__first + __parent)), __comp);
        if (__parent == 0) return;
        __parent--;
      }
    }

  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     


      while (__last - __first > 1)
        pop_heap(__first, __last--);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
              _Compare __comp)
    {

     


      while (__last - __first > 1)
        pop_heap(__first, __last--, __comp);
    }

}
# 65 "/usr/include/c++/3.3/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/3.3/bits/stl_tempbuf.h" 1 3
# 64 "/usr/include/c++/3.3/bits/stl_tempbuf.h" 3
namespace std
{
# 74 "/usr/include/c++/3.3/bits/stl_tempbuf.h" 3
template <class _ForwardIterator, class _Tp>
  class _Temporary_buffer
{

 

  ptrdiff_t _M_original_len;
  ptrdiff_t _M_len;
  _Tp* _M_buffer;


  void _M_allocate_buffer() {
    _M_original_len = _M_len;
    _M_buffer = 0;

    if (_M_len > (ptrdiff_t)(2147483647 / sizeof(_Tp)))
      _M_len = 2147483647 / sizeof(_Tp);

    while (_M_len > 0) {
      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
      if (_M_buffer)
        break;
      _M_len /= 2;
    }
  }

  void _M_initialize_buffer(const _Tp&, __true_type) {}
  void _M_initialize_buffer(const _Tp& val, __false_type) {
    uninitialized_fill_n(_M_buffer, _M_len, val);
  }

public:

  ptrdiff_t size() const { return _M_len; }

  ptrdiff_t requested_size() const { return _M_original_len; }

  _Tp* begin() { return _M_buffer; }

  _Tp* end() { return _M_buffer + _M_len; }

  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {

    typedef typename __type_traits<_Tp>::has_trivial_default_constructor
            _Trivial;

    if (true) {
      _M_len = distance(__first, __last);
      _M_allocate_buffer();
      if (_M_len > 0)
        _M_initialize_buffer(*__first, _Trivial());
    }
    if (false)
      {
        free(_M_buffer);
        _M_buffer = 0;
        _M_len = 0;
        ;
      }
  }

  ~_Temporary_buffer() {
    _Destroy(_M_buffer, _M_buffer + _M_len);
    free(_M_buffer);
  }

private:

  _Temporary_buffer(const _Temporary_buffer&) {}
  void operator=(const _Temporary_buffer&) {}
};

}
# 66 "/usr/include/c++/3.3/bits/stl_algo.h" 2 3



namespace std
{
# 84 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _Tp>
  inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {

     
      if (__a < __b)
        if (__b < __c)
          return __b;
        else if (__a < __c)
          return __c;
        else
          return __a;
      else if (__a < __c)
        return __a;
      else if (__b < __c)
        return __c;
      else
        return __b;
    }
# 118 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {

     
      if (__comp(__a, __b))
        if (__comp(__b, __c))
          return __b;
        else if (__comp(__a, __c))
          return __c;
        else
          return __a;
      else if (__comp(__a, __c))
        return __a;
      else if (__comp(__b, __c))
        return __c;
      else
        return __b;
    }
# 150 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Function>
    _Function
    for_each(_InputIter __first, _InputIter __last, _Function __f)
    {

     
      for ( ; __first != __last; ++__first)
        __f(*__first);
      return __f;
    }






  template<typename _InputIter, typename _Tp>
    inline _InputIter
    find(_InputIter __first, _InputIter __last,
         const _Tp& __val,
         input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
        ++__first;
      return __first;
    }






  template<typename _InputIter, typename _Predicate>
    inline _InputIter
    find_if(_InputIter __first, _InputIter __last,
            _Predicate __pred,
            input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
        ++__first;
      return __first;
    }






  template<typename _RandomAccessIter, typename _Tp>
    _RandomAccessIter
    find(_RandomAccessIter __first, _RandomAccessIter __last,
         const _Tp& __val,
         random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIter>::difference_type __trip_count
        = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count) {
        if (*__first == __val) return __first;
        ++__first;

        if (*__first == __val) return __first;
        ++__first;

        if (*__first == __val) return __first;
        ++__first;

        if (*__first == __val) return __first;
        ++__first;
      }

      switch(__last - __first) {
      case 3:
        if (*__first == __val) return __first;
        ++__first;
      case 2:
        if (*__first == __val) return __first;
        ++__first;
      case 1:
        if (*__first == __val) return __first;
        ++__first;
      case 0:
      default:
        return __last;
      }
    }






  template<typename _RandomAccessIter, typename _Predicate>
    _RandomAccessIter
    find_if(_RandomAccessIter __first, _RandomAccessIter __last,
            _Predicate __pred,
            random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIter>::difference_type __trip_count
        = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count) {
        if (__pred(*__first)) return __first;
        ++__first;

        if (__pred(*__first)) return __first;
        ++__first;

        if (__pred(*__first)) return __first;
        ++__first;

        if (__pred(*__first)) return __first;
        ++__first;
      }

      switch(__last - __first) {
      case 3:
        if (__pred(*__first)) return __first;
        ++__first;
      case 2:
        if (__pred(*__first)) return __first;
        ++__first;
      case 1:
        if (__pred(*__first)) return __first;
        ++__first;
      case 0:
      default:
        return __last;
      }
    }
# 289 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Tp>
    inline _InputIter
    find(_InputIter __first, _InputIter __last,
         const _Tp& __val)
    {

     
     

      return find(__first, __last, __val, __iterator_category(__first));
    }
# 309 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Predicate>
    inline _InputIter
    find_if(_InputIter __first, _InputIter __last,
            _Predicate __pred)
    {

     
     

      return find_if(__first, __last, __pred, __iterator_category(__first));
    }
# 329 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter>
    _ForwardIter
    adjacent_find(_ForwardIter __first, _ForwardIter __last)
    {

     
     

      if (__first == __last)
        return __last;
      _ForwardIter __next = __first;
      while(++__next != __last) {
        if (*__first == *__next)
          return __first;
        __first = __next;
      }
      return __last;
    }
# 358 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _BinaryPredicate>
    _ForwardIter
    adjacent_find(_ForwardIter __first, _ForwardIter __last,
                  _BinaryPredicate __binary_pred)
    {

     
     


      if (__first == __last)
        return __last;
      _ForwardIter __next = __first;
      while(++__next != __last) {
        if (__binary_pred(*__first, *__next))
          return __first;
        __first = __next;
      }
      return __last;
    }
# 387 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Tp>
    typename iterator_traits<_InputIter>::difference_type
    count(_InputIter __first, _InputIter __last, const _Tp& __value)
    {

     
     

     
      typename iterator_traits<_InputIter>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
        if (*__first == __value)
          ++__n;
      return __n;
    }
# 411 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Predicate>
    typename iterator_traits<_InputIter>::difference_type
    count_if(_InputIter __first, _InputIter __last, _Predicate __pred)
    {

     
     

      typename iterator_traits<_InputIter>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
        if (__pred(*__first))
          ++__n;
      return __n;
    }
# 450 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    _ForwardIter1
    search(_ForwardIter1 __first1, _ForwardIter1 __last1,
           _ForwardIter2 __first2, _ForwardIter2 __last2)
    {

     
     
     




      if (__first1 == __last1 || __first2 == __last2)
        return __first1;


      _ForwardIter2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
        return find(__first1, __last1, *__first2);



      _ForwardIter2 __p1, __p;

      __p1 = __first2; ++__p1;

      _ForwardIter1 __current = __first1;

      while (__first1 != __last1) {
        __first1 = find(__first1, __last1, *__first2);
        if (__first1 == __last1)
          return __last1;

        __p = __p1;
        __current = __first1;
        if (++__current == __last1)
          return __last1;

        while (*__current == *__p) {
          if (++__p == __last2)
            return __first1;
          if (++__current == __last1)
            return __last1;
        }

        ++__first1;
      }
      return __first1;
    }
# 522 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2, typename _BinaryPred>
    _ForwardIter1
    search(_ForwardIter1 __first1, _ForwardIter1 __last1,
           _ForwardIter2 __first2, _ForwardIter2 __last2,
           _BinaryPred __predicate)
    {

     
     
     




      if (__first1 == __last1 || __first2 == __last2)
        return __first1;


      _ForwardIter2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2) {
        while (__first1 != __last1 && !__predicate(*__first1, *__first2))
          ++__first1;
        return __first1;
      }



      _ForwardIter2 __p1, __p;

      __p1 = __first2; ++__p1;

      _ForwardIter1 __current = __first1;

      while (__first1 != __last1) {
        while (__first1 != __last1) {
          if (__predicate(*__first1, *__first2))
            break;
          ++__first1;
        }
        while (__first1 != __last1 && !__predicate(*__first1, *__first2))
          ++__first1;
        if (__first1 == __last1)
          return __last1;

        __p = __p1;
        __current = __first1;
        if (++__current == __last1) return __last1;

        while (__predicate(*__current, *__p)) {
          if (++__p == __last2)
            return __first1;
          if (++__current == __last1)
            return __last1;
        }

        ++__first1;
      }
      return __first1;
    }
# 596 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Integer, typename _Tp>
    _ForwardIter
    search_n(_ForwardIter __first, _ForwardIter __last,
             _Integer __count, const _Tp& __val)
    {

     
     

     

      if (__count <= 0)
        return __first;
      else {
        __first = find(__first, __last, __val);
        while (__first != __last) {
          _Integer __n = __count - 1;
          _ForwardIter __i = __first;
          ++__i;
          while (__i != __last && __n != 0 && *__i == __val) {
            ++__i;
            --__n;
          }
          if (__n == 0)
            return __first;
          else
            __first = find(__i, __last, __val);
        }
        return __last;
      }
    }
# 643 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Integer, typename _Tp,
           typename _BinaryPred>
    _ForwardIter
    search_n(_ForwardIter __first, _ForwardIter __last,
             _Integer __count, const _Tp& __val,
             _BinaryPred __binary_pred)
    {

     
     


      if (__count <= 0)
        return __first;
      else {
        while (__first != __last) {
          if (__binary_pred(*__first, __val))
            break;
          ++__first;
        }
        while (__first != __last) {
          _Integer __n = __count - 1;
          _ForwardIter __i = __first;
          ++__i;
          while (__i != __last && __n != 0 && __binary_pred(*__i, __val)) {
            ++__i;
            --__n;
          }
          if (__n == 0)
            return __first;
          else {
            while (__i != __last) {
              if (__binary_pred(*__i, __val))
                break;
              ++__i;
            }
            __first = __i;
          }
        }
        return __last;
      }
    }
# 697 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    _ForwardIter2
    swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1,
                _ForwardIter2 __first2)
    {

     
     
     


     



      for ( ; __first1 != __last1; ++__first1, ++__first2)
        iter_swap(__first1, __first2);
      return __first2;
    }
# 732 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _UnaryOperation>
    _OutputIter
    transform(_InputIter __first, _InputIter __last,
              _OutputIter __result, _UnaryOperation __unary_op)
    {

     
     



      for ( ; __first != __last; ++__first, ++__result)
        *__result = __unary_op(*__first);
      return __result;
    }
# 765 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _BinaryOperation>
    _OutputIter
    transform(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _OutputIter __result,
              _BinaryOperation __binary_op)
    {

     
     
     



      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 796 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    void
    replace(_ForwardIter __first, _ForwardIter __last,
            const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (*__first == __old_value)
          *__first = __new_value;
    }
# 825 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIter __first, _ForwardIter __last,
               _Predicate __pred, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (__pred(*__first))
          *__first = __new_value;
    }
# 856 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Tp>
    _OutputIter
    replace_copy(_InputIter __first, _InputIter __last,
                 _OutputIter __result,
                 const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first, ++__result)
        *__result = *__first == __old_value ? __new_value : *__first;
      return __result;
    }
# 888 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Predicate,
           typename _Tp>
    _OutputIter
    replace_copy_if(_InputIter __first, _InputIter __last,
                    _OutputIter __result,
                    _Predicate __pred, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first, ++__result)
        *__result = __pred(*__first) ? __new_value : *__first;
      return __result;
    }
# 918 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Generator>
    void
    generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen)
    {

     
     


      for ( ; __first != __last; ++__first)
        *__first = __gen();
    }
# 942 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _OutputIter, typename _Size, typename _Generator>
    _OutputIter
    generate_n(_OutputIter __first, _Size __n, _Generator __gen)
    {

     



      for ( ; __n > 0; --__n, ++__first)
        *__first = __gen();
      return __first;
    }
# 969 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Tp>
    _OutputIter
    remove_copy(_InputIter __first, _InputIter __last,
                _OutputIter __result, const _Tp& __value)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (!(*__first == __value)) {
          *__result = *__first;
          ++__result;
        }
      return __result;
    }
# 1003 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Predicate>
    _OutputIter
    remove_copy_if(_InputIter __first, _InputIter __last,
                   _OutputIter __result, _Predicate __pred)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (!__pred(*__first)) {
          *__result = *__first;
          ++__result;
        }
      return __result;
    }
# 1039 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    _ForwardIter
    remove(_ForwardIter __first, _ForwardIter __last,
           const _Tp& __value)
    {

     
     

     


      __first = find(__first, __last, __value);
      _ForwardIter __i = __first;
      return __first == __last ? __first
                               : remove_copy(++__i, __last, __first, __value);
    }
# 1073 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate>
    _ForwardIter
    remove_if(_ForwardIter __first, _ForwardIter __last,
              _Predicate __pred)
    {

     
     


      __first = find_if(__first, __last, __pred);
      _ForwardIter __i = __first;
      return __first == __last ? __first
                               : remove_copy_if(++__i, __last, __first, __pred);
    }







  template<typename _InputIter, typename _OutputIter>
    _OutputIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _OutputIter __result,
                  output_iterator_tag)
    {

      typename iterator_traits<_InputIter>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
        if (!(__value == *__first)) {
          __value = *__first;
          *++__result = __value;
        }
      return ++__result;
    }







  template<typename _InputIter, typename _ForwardIter>
    _ForwardIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _ForwardIter __result,
                  forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
        if (!(*__result == *__first))
          *++__result = *__first;
      return ++__result;
    }
# 1145 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    unique_copy(_InputIter __first, _InputIter __last,
                _OutputIter __result)
    {

     
     

     


      typedef typename iterator_traits<_OutputIter>::iterator_category _IterType;

      if (__first == __last) return __result;
      return __unique_copy(__first, __last, __result, _IterType());
    }
# 1170 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _BinaryPredicate>
    _OutputIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _OutputIter __result,
                  _BinaryPredicate __binary_pred,
                  output_iterator_tag)
    {

     



      typename iterator_traits<_InputIter>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
        if (!__binary_pred(__value, *__first)) {
          __value = *__first;
          *++__result = __value;
        }
      return ++__result;
    }
# 1199 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _ForwardIter, typename _BinaryPredicate>
    _ForwardIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _ForwardIter __result,
                  _BinaryPredicate __binary_pred,
                  forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
        if (!__binary_pred(*__result, *__first)) *++__result = *__first;
      return ++__result;
    }
# 1232 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _BinaryPredicate>
    inline _OutputIter
    unique_copy(_InputIter __first, _InputIter __last,
                _OutputIter __result,
                _BinaryPredicate __binary_pred)
    {

     
     


      typedef typename iterator_traits<_OutputIter>::iterator_category _IterType;

      if (__first == __last) return __result;
      return __unique_copy(__first, __last,
__result, __binary_pred, _IterType());
    }
# 1263 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter>
    _ForwardIter
    unique(_ForwardIter __first, _ForwardIter __last)
    {

         
         


          __first = adjacent_find(__first, __last);
          return unique_copy(__first, __last, __first);
    }
# 1290 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _BinaryPredicate>
    _ForwardIter
    unique(_ForwardIter __first, _ForwardIter __last,
           _BinaryPredicate __binary_pred)
    {

     
     



      __first = adjacent_find(__first, __last, __binary_pred);
      return unique_copy(__first, __last, __first, __binary_pred);
    }







  template<typename _BidirectionalIter>
    void
    __reverse(_BidirectionalIter __first, _BidirectionalIter __last,
                          bidirectional_iterator_tag)
    {
          while (true)
            if (__first == __last || __first == --__last)
                  return;
            else
                  iter_swap(__first++, __last);
    }







  template<typename _RandomAccessIter>
    void
    __reverse(_RandomAccessIter __first, _RandomAccessIter __last,
                          random_access_iterator_tag)
    {
          while (__first < __last)
            iter_swap(__first++, --__last);
    }
# 1349 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIter>
    inline void
    reverse(_BidirectionalIter __first, _BidirectionalIter __last)
    {

         

          __reverse(__first, __last, __iterator_category(__first));
    }
# 1374 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIter, typename _OutputIter>
    _OutputIter
    reverse_copy(_BidirectionalIter __first, _BidirectionalIter __last,
                             _OutputIter __result)
    {

     
     


      while (__first != __last) {
        --__last;
        *__result = *__last;
        ++__result;
      }
      return __result;
    }
# 1399 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0) {
        _EuclideanRingElement __t = __m % __n;
        __m = __n;
        __n = __t;
      }
      return __m;
    }






  template<typename _ForwardIter>
    void
    __rotate(_ForwardIter __first,
             _ForwardIter __middle,
             _ForwardIter __last,
              forward_iterator_tag)
    {
      if ((__first == __middle) || (__last == __middle))
        return;

      _ForwardIter __first2 = __middle;
      do {
        swap(*__first++, *__first2++);
        if (__first == __middle)
          __middle = __first2;
      } while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last) {
        swap(*__first++, *__first2++);
        if (__first == __middle)
          __middle = __first2;
        else if (__first2 == __last)
          __first2 = __middle;
      }
    }






  template<typename _BidirectionalIter>
    void
    __rotate(_BidirectionalIter __first,
             _BidirectionalIter __middle,
             _BidirectionalIter __last,
              bidirectional_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
        return;

      __reverse(__first, __middle, bidirectional_iterator_tag());
      __reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
        swap (*__first++, *--__last);

      if (__first == __middle) {
        __reverse(__middle, __last, bidirectional_iterator_tag());
      }
      else {
        __reverse(__first, __middle, bidirectional_iterator_tag());
      }
    }






  template<typename _RandomAccessIter>
    void
    __rotate(_RandomAccessIter __first,
             _RandomAccessIter __middle,
             _RandomAccessIter __last,
             random_access_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
        return;

      typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;
      _Distance __l = __n - __k;

      if (__k == __l) {
        swap_ranges(__first, __middle, __middle);
        return;
      }

      _Distance __d = __gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++) {
        _ValueType __tmp = *__first;
        _RandomAccessIter __p = __first;

        if (__k < __l) {
          for (_Distance __j = 0; __j < __l/__d; __j++) {
            if (__p > __first + __l) {
              *__p = *(__p - __l);
              __p -= __l;
            }

            *__p = *(__p + __k);
            __p += __k;
          }
        }

        else {
          for (_Distance __j = 0; __j < __k/__d - 1; __j ++) {
            if (__p < __last - __k) {
              *__p = *(__p + __k);
              __p += __k;
            }

            *__p = * (__p - __l);
            __p -= __l;
          }
        }

        *__p = __tmp;
        ++__first;
      }
    }
# 1561 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter>
    inline void
    rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last)
    {

     

      typedef typename iterator_traits<_ForwardIter>::iterator_category _IterType;
      __rotate(__first, __middle, __last, _IterType());
    }
# 1589 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _OutputIter>
    _OutputIter
    rotate_copy(_ForwardIter __first, _ForwardIter __middle,
                _ForwardIter __last, _OutputIter __result)
    {

     
     


      return copy(__first, __middle, copy(__middle, __last, __result));
    }
# 1612 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _Distance>
    inline _Distance
    __random_number(_Distance __n)
    {

      return lrand48() % __n;



    }
# 1634 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    inline void
    random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last)
    {

     


      if (__first == __last) return;
      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
        iter_swap(__i, __first + __random_number((__i - __first) + 1));
    }
# 1660 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
                   _RandomNumberGenerator& __rand)
    {

     


      if (__first == __last) return;
      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
        iter_swap(__i, __first + __rand((__i - __first) + 1));
    }







  template<typename _ForwardIter, typename _Predicate>
    _ForwardIter
    __partition(_ForwardIter __first, _ForwardIter __last,
                _Predicate __pred,
                forward_iterator_tag)
    {
      if (__first == __last) return __first;

      while (__pred(*__first))
        if (++__first == __last) return __first;

      _ForwardIter __next = __first;

      while (++__next != __last)
        if (__pred(*__next)) {
          swap(*__first, *__next);
          ++__first;
        }

      return __first;
    }






  template<typename _BidirectionalIter, typename _Predicate>
    _BidirectionalIter
    __partition(_BidirectionalIter __first, _BidirectionalIter __last,
                _Predicate __pred,
                bidirectional_iterator_tag)
    {
      while (true) {
        while (true)
          if (__first == __last)
            return __first;
          else if (__pred(*__first))
            ++__first;
          else
            break;
        --__last;
        while (true)
          if (__first == __last)
            return __first;
          else if (!__pred(*__last))
            --__last;
          else
            break;
        iter_swap(__first, __last);
        ++__first;
      }
    }
# 1748 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate>
    inline _ForwardIter
    partition(_ForwardIter __first, _ForwardIter __last,
              _Predicate __pred)
    {

     
     


      return __partition(__first, __last, __pred, __iterator_category(__first));
    }







  template<typename _ForwardIter, typename _Predicate, typename _Distance>
    _ForwardIter
    __inplace_stable_partition(_ForwardIter __first, _ForwardIter __last,
                               _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
        return __pred(*__first) ? __last : __first;
      _ForwardIter __middle = __first;
      advance(__middle, __len / 2);
      _ForwardIter __begin = __inplace_stable_partition(__first, __middle,
                                                        __pred,
                                                        __len / 2);
      _ForwardIter __end = __inplace_stable_partition(__middle, __last,
                                                      __pred,
                                                      __len - __len / 2);
      rotate(__begin, __middle, __end);
      advance(__begin, distance(__middle, __end));
      return __begin;
    }






  template<typename _ForwardIter, typename _Pointer, typename _Predicate,
           typename _Distance>
    _ForwardIter
    __stable_partition_adaptive(_ForwardIter __first, _ForwardIter __last,
                                _Predicate __pred, _Distance __len,
                                _Pointer __buffer,
                                _Distance __buffer_size)
    {
      if (__len <= __buffer_size) {
        _ForwardIter __result1 = __first;
        _Pointer __result2 = __buffer;
        for ( ; __first != __last ; ++__first)
          if (__pred(*__first)) {
            *__result1 = *__first;
            ++__result1;
          }
          else {
            *__result2 = *__first;
            ++__result2;
          }
        copy(__buffer, __result2, __result1);
        return __result1;
      }
      else {
        _ForwardIter __middle = __first;
        advance(__middle, __len / 2);
        _ForwardIter __begin = __stable_partition_adaptive(__first, __middle,
                                                           __pred,
                                                           __len / 2,
                                                           __buffer, __buffer_size);
        _ForwardIter __end = __stable_partition_adaptive( __middle, __last,
                                                          __pred,
                                                          __len - __len / 2,
                                                          __buffer, __buffer_size);
        rotate(__begin, __middle, __end);
        advance(__begin, distance(__middle, __end));
        return __begin;
      }
    }
# 1848 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate>
    _ForwardIter
    stable_partition(_ForwardIter __first, _ForwardIter __last,
                     _Predicate __pred)
    {

     
     


      if (__first == __last)
        return __first;
      else
      {
        typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
        typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;

        _Temporary_buffer<_ForwardIter, _ValueType> __buf(__first, __last);
        if (__buf.size() > 0)
          return __stable_partition_adaptive(__first, __last, __pred,
                                             _DistanceType(__buf.requested_size()),
                                             __buf.begin(), __buf.size());
        else
          return __inplace_stable_partition(__first, __last, __pred,
                                            _DistanceType(__buf.requested_size()));
      }
    }






  template<typename _RandomAccessIter, typename _Tp>
    _RandomAccessIter
    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last,
                          _Tp __pivot)
    {
      while (true) {
        while (*__first < __pivot)
          ++__first;
        --__last;
        while (__pivot < *__last)
          --__last;
        if (!(__first < __last))
          return __first;
        iter_swap(__first, __last);
        ++__first;
      }
    }






  template<typename _RandomAccessIter, typename _Tp, typename _Compare>
    _RandomAccessIter
    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last,
                          _Tp __pivot, _Compare __comp)
    {
      while (true) {
        while (__comp(*__first, __pivot))
          ++__first;
        --__last;
        while (__comp(__pivot, *__last))
          --__last;
        if (!(__first < __last))
          return __first;
        iter_swap(__first, __last);
        ++__first;
      }
    }
# 1929 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  enum { _M_threshold = 16 };






  template<typename _RandomAccessIter, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val)
    {
      _RandomAccessIter __next = __last;
      --__next;
      while (__val < *__next) {
        *__last = *__next;
        __last = __next;
        --__next;
      }
      *__last = __val;
    }






  template<typename _RandomAccessIter, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val, _Compare __comp)
    {
      _RandomAccessIter __next = __last;
      --__next;
      while (__comp(__val, *__next)) {
        *__last = *__next;
        __last = __next;
        --__next;
      }
      *__last = __val;
    }






  template<typename _RandomAccessIter>
    void
    __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      if (__first == __last) return;

      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
      {
        typename iterator_traits<_RandomAccessIter>::value_type __val = *__i;
        if (__val < *__first) {
          copy_backward(__first, __i, __i + 1);
          *__first = __val;
        }
        else
          __unguarded_linear_insert(__i, __val);
      }
    }






  template<typename _RandomAccessIter, typename _Compare>
    void
    __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                     _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
      {
        typename iterator_traits<_RandomAccessIter>::value_type __val = *__i;
        if (__comp(__val, *__first)) {
          copy_backward(__first, __i, __i + 1);
          *__first = __val;
        }
        else
          __unguarded_linear_insert(__i, __val, __comp);
      }
    }






  template<typename _RandomAccessIter>
    inline void
    __unguarded_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert(__i, _ValueType(*__i));
    }






  template<typename _RandomAccessIter, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                               _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }






  template<typename _RandomAccessIter>
    void
    __final_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      if (__last - __first > _M_threshold) {
        __insertion_sort(__first, __first + _M_threshold);
        __unguarded_insertion_sort(__first + _M_threshold, __last);
      }
      else
        __insertion_sort(__first, __last);
    }






  template<typename _RandomAccessIter, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Compare __comp)
    {
      if (__last - __first > _M_threshold) {
        __insertion_sort(__first, __first + _M_threshold, __comp);
        __unguarded_insertion_sort(__first + _M_threshold, __last, __comp);
      }
      else
        __insertion_sort(__first, __last, __comp);
    }






  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1) ++__k;
      return __k;
    }






  template<typename _RandomAccessIter, typename _Size>
    void
    __introsort_loop(_RandomAccessIter __first, _RandomAccessIter __last,
                     _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      while (__last - __first > _M_threshold) {
        if (__depth_limit == 0) {
          partial_sort(__first, __last, __last);
          return;
        }
        --__depth_limit;
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1))));
        __introsort_loop(__cut, __last, __depth_limit);
        __last = __cut;
      }
    }






  template<typename _RandomAccessIter, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIter __first, _RandomAccessIter __last,
                     _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      while (__last - __first > _M_threshold) {
        if (__depth_limit == 0) {
          partial_sort(__first, __last, __last, __comp);
          return;
        }
        --__depth_limit;
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1), __comp)),
           __comp);
        __introsort_loop(__cut, __last, __depth_limit, __comp);
        __last = __cut;
      }
    }
# 2166 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    inline void
    sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     

      if (__first != __last) {
        __introsort_loop(__first, __last, __lg(__last - __first) * 2);
        __final_insertion_sort(__first, __last);
      }
    }
# 2197 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    inline void
    sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     

      if (__first != __last) {
        __introsort_loop(__first, __last, __lg(__last - __first) * 2, __comp);
        __final_insertion_sort(__first, __last, __comp);
      }
    }







  template<typename _RandomAccessIter>
    void
    __inplace_stable_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      if (__last - __first < 15) {
        __insertion_sort(__first, __last);
        return;
      }
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle);
      __inplace_stable_sort(__middle, __last);
      __merge_without_buffer(__first, __middle, __last,
                             __middle - __first,
                             __last - __middle);
    }






  template<typename _RandomAccessIter, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                          _Compare __comp)
    {
      if (__last - __first < 15) {
        __insertion_sort(__first, __last, __comp);
        return;
      }
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle, __comp);
      __inplace_stable_sort(__middle, __last, __comp);
      __merge_without_buffer(__first, __middle, __last,
                             __middle - __first,
                             __last - __middle,
                             __comp);
    }

  template<typename _RandomAccessIter1, typename _RandomAccessIter2,
           typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last,
                      _RandomAccessIter2 __result, _Distance __step_size)
    {
      _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step) {
        __result = merge(__first, __first + __step_size,
                         __first + __step_size, __first + __two_step,
                         __result);
        __first += __two_step;
      }

      __step_size = min(_Distance(__last - __first), __step_size);
      merge(__first, __first + __step_size, __first + __step_size, __last,
            __result);
    }

  template<typename _RandomAccessIter1, typename _RandomAccessIter2,
           typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last,
                      _RandomAccessIter2 __result, _Distance __step_size,
                      _Compare __comp)
    {
      _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step) {
        __result = merge(__first, __first + __step_size,
                         __first + __step_size, __first + __two_step,
                         __result,
                         __comp);
        __first += __two_step;
      }
      __step_size = min(_Distance(__last - __first), __step_size);

      merge(__first, __first + __step_size,
            __first + __step_size, __last,
            __result,
            __comp);
    }

  enum { _M_chunk_size = 7 };

  template<typename _RandomAccessIter, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size) {
        __insertion_sort(__first, __first + __chunk_size);
        __first += __chunk_size;
      }
      __insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIter, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size) {
        __insertion_sort(__first, __first + __chunk_size, __comp);
        __first += __chunk_size;
      }
      __insertion_sort(__first, __last, __comp);
    }

  template<typename _RandomAccessIter, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIter __first, _RandomAccessIter __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;

      _Distance __len = __last - __first;
      _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _M_chunk_size;
      __chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len) {
        __merge_sort_loop(__first, __last, __buffer, __step_size);
        __step_size *= 2;
        __merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
        __step_size *= 2;
      }
    }

  template<typename _RandomAccessIter, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIter __first, _RandomAccessIter __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;

      _Distance __len = __last - __first;
      _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _M_chunk_size;
      __chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len) {
        __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
        __step_size *= 2;
        __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
        __step_size *= 2;
      }
    }

  template<typename _RandomAccessIter, typename _Pointer, typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      _Distance __len = (__last - __first + 1) / 2;
      _RandomAccessIter __middle = __first + __len;
      if (__len > __buffer_size) {
        __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);
        __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);
      }
      else {
        __merge_sort_with_buffer(__first, __middle, __buffer);
        __merge_sort_with_buffer(__middle, __last, __buffer);
      }
      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
                       _Distance(__last - __middle), __buffer, __buffer_size);
    }

  template<typename _RandomAccessIter, typename _Pointer, typename _Distance,
           typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      _Distance __len = (__last - __first + 1) / 2;
      _RandomAccessIter __middle = __first + __len;
      if (__len > __buffer_size) {
        __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size,
                               __comp);
        __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size,
                               __comp);
      }
      else {
        __merge_sort_with_buffer(__first, __middle, __buffer, __comp);
        __merge_sort_with_buffer(__middle, __last, __buffer, __comp);
      }
      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
                       _Distance(__last - __middle), __buffer, __buffer_size,
                       __comp);
    }
# 2430 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    inline void
    stable_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     

     

      _Temporary_buffer<_RandomAccessIter, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
        __inplace_stable_sort(__first, __last);
      else
        __stable_sort_adaptive(__first, __last, buf.begin(), _DistanceType(buf.size()));
    }
# 2466 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    inline void
    stable_sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     

     


      _Temporary_buffer<_RandomAccessIter, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
        __inplace_stable_sort(__first, __last, __comp);
      else
        __stable_sort_adaptive(__first, __last, buf.begin(), _DistanceType(buf.size()),
                               __comp);
    }
# 2502 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    void
    partial_sort(_RandomAccessIter __first,
                 _RandomAccessIter __middle,
                 _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     

      make_heap(__first, __middle);
      for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (*__i < *__first)
          __pop_heap(__first, __middle, __i, _ValueType(*__i));
      sort_heap(__first, __middle);
    }
# 2540 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    void
    partial_sort(_RandomAccessIter __first,
                 _RandomAccessIter __middle,
                 _RandomAccessIter __last,
                 _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     


      make_heap(__first, __middle, __comp);
      for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (__comp(*__i, *__first))
          __pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
      sort_heap(__first, __middle, __comp);
    }
# 2579 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _RandomAccessIter>
    _RandomAccessIter
    partial_sort_copy(_InputIter __first, _InputIter __last,
                      _RandomAccessIter __result_first,
                      _RandomAccessIter __result_last)
    {
      typedef typename iterator_traits<_InputIter>::value_type _InputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::value_type _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     
     
     
     

      if (__result_first == __result_last) return __result_last;
      _RandomAccessIter __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last) {
        *__result_real_last = *__first;
        ++__result_real_last;
        ++__first;
      }
      make_heap(__result_first, __result_real_last);
      while (__first != __last) {
        if (*__first < *__result_first)
          __adjust_heap(__result_first, _DistanceType(0),
                        _DistanceType(__result_real_last - __result_first),
                        _InputValueType(*__first));
        ++__first;
      }
      sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2633 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _RandomAccessIter, typename _Compare>
    _RandomAccessIter
    partial_sort_copy(_InputIter __first, _InputIter __last,
                      _RandomAccessIter __result_first,
                      _RandomAccessIter __result_last,
                      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIter>::value_type _InputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::value_type _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     
     
     
     


      if (__result_first == __result_last) return __result_last;
      _RandomAccessIter __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last) {
        *__result_real_last = *__first;
        ++__result_real_last;
        ++__first;
      }
      make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last) {
        if (__comp(*__first, *__result_first))
          __adjust_heap(__result_first, _DistanceType(0),
                        _DistanceType(__result_real_last - __result_first),
                        _InputValueType(*__first),
                        __comp);
        ++__first;
      }
      sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 2686 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    void
    nth_element(_RandomAccessIter __first,
                _RandomAccessIter __nth,
                _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     
     

      while (__last - __first > 3) {
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1))));
        if (__cut <= __nth)
          __first = __cut;
        else
          __last = __cut;
      }
      __insertion_sort(__first, __last);
    }
# 2728 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    void
    nth_element(_RandomAccessIter __first,
                _RandomAccessIter __nth,
                _RandomAccessIter __last,
                            _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     
     


      while (__last - __first > 3) {
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1),
                                                    __comp)),
                                __comp);
        if (__cut <= __nth)
          __first = __cut;
        else
          __last = __cut;
      }
      __insertion_sort(__first, __last, __comp);
    }
# 2768 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    _ForwardIter
    lower_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;






     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (*__middle < __val) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else
          __len = __half;
      }
      return __first;
    }
# 2816 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    _ForwardIter
    lower_bound(_ForwardIter __first, _ForwardIter __last,
                const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;


     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__comp(*__middle, __val)) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else
          __len = __half;
      }
      return __first;
    }
# 2856 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    _ForwardIter
    upper_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;



     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__val < *__middle)
          __len = __half;
        else {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
      }
      return __first;
    }
# 2901 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    _ForwardIter
    upper_bound(_ForwardIter __first, _ForwardIter __last,
                const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;


     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__comp(__val, *__middle))
          __len = __half;
        else {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
      }
      return __first;
    }
# 2948 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    pair<_ForwardIter, _ForwardIter>
    equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;



     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle, __left, __right;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (*__middle < __val) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else if (__val < *__middle)
          __len = __half;
        else {
          __left = lower_bound(__first, __middle, __val);
          advance(__first, __len);
          __right = upper_bound(++__middle, __first, __val);
          return pair<_ForwardIter, _ForwardIter>(__left, __right);
        }
      }
      return pair<_ForwardIter, _ForwardIter>(__first, __first);
    }
# 3003 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    pair<_ForwardIter, _ForwardIter>
    equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;


     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle, __left, __right;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__comp(*__middle, __val)) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else if (__comp(__val, *__middle))
          __len = __half;
        else {
          __left = lower_bound(__first, __middle, __val, __comp);
          advance(__first, __len);
          __right = upper_bound(++__middle, __first, __val, __comp);
          return pair<_ForwardIter, _ForwardIter>(__left, __right);
        }
      }
      return pair<_ForwardIter, _ForwardIter>(__first, __first);
    }
# 3052 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    bool
    binary_search(_ForwardIter __first, _ForwardIter __last,
                  const _Tp& __val)
    {


     
     

     

      _ForwardIter __i = lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 3083 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIter __first, _ForwardIter __last,
                  const _Tp& __val, _Compare __comp)
    {

     
     

     


      _ForwardIter __i = lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
# 3115 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    merge(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _InputIter2 __last2,
          _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2) {
        if (*__first2 < *__first1) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }
# 3166 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    merge(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _InputIter2 __last2,
          _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2) {
        if (__comp(*__first2, *__first1)) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }






  template<typename _BidirectionalIter, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIter __first,
                           _BidirectionalIter __middle,
                           _BidirectionalIter __last,
                           _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
        return;
      if (__len1 + __len2 == 2) {
        if (*__middle < *__first)
              iter_swap(__first, __middle);
        return;
      }
      _BidirectionalIter __first_cut = __first;
      _BidirectionalIter __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2) {
        __len11 = __len1 / 2;
        advance(__first_cut, __len11);
        __second_cut = lower_bound(__middle, __last, *__first_cut);
        __len22 = distance(__middle, __second_cut);
      }
      else {
        __len22 = __len2 / 2;
        advance(__second_cut, __len22);
        __first_cut = upper_bound(__first, __middle, *__second_cut);
        __len11 = distance(__first, __first_cut);
      }
      rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIter __new_middle = __first_cut;
      advance(__new_middle, distance(__middle, __second_cut));
      __merge_without_buffer(__first, __first_cut, __new_middle,
                             __len11, __len22);
      __merge_without_buffer(__new_middle, __second_cut, __last,
                             __len1 - __len11, __len2 - __len22);
    }






  template<typename _BidirectionalIter, typename _Distance, typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIter __first,
                           _BidirectionalIter __middle,
                           _BidirectionalIter __last,
                           _Distance __len1, _Distance __len2,
                           _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
        return;
      if (__len1 + __len2 == 2) {
        if (__comp(*__middle, *__first))
              iter_swap(__first, __middle);
        return;
      }
      _BidirectionalIter __first_cut = __first;
      _BidirectionalIter __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2) {
        __len11 = __len1 / 2;
        advance(__first_cut, __len11);
        __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
        __len22 = distance(__middle, __second_cut);
      }
      else {
        __len22 = __len2 / 2;
        advance(__second_cut, __len22);
        __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
        __len11 = distance(__first, __first_cut);
      }
      rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIter __new_middle = __first_cut;
      advance(__new_middle, distance(__middle, __second_cut));
      __merge_without_buffer(__first, __first_cut, __new_middle,
                             __len11, __len22, __comp);
      __merge_without_buffer(__new_middle, __second_cut, __last,
                             __len1 - __len11, __len2 - __len22, __comp);
    }






  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _Distance>
    _BidirectionalIter1
    __rotate_adaptive(_BidirectionalIter1 __first,
                      _BidirectionalIter1 __middle,
                      _BidirectionalIter1 __last,
                      _Distance __len1, _Distance __len2,
                      _BidirectionalIter2 __buffer,
                      _Distance __buffer_size)
    {
      _BidirectionalIter2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size) {
        __buffer_end = copy(__middle, __last, __buffer);
        copy_backward(__first, __middle, __last);
        return copy(__buffer, __buffer_end, __first);
      }
      else if (__len1 <= __buffer_size) {
        __buffer_end = copy(__first, __middle, __buffer);
        copy(__middle, __last, __first);
        return copy_backward(__buffer, __buffer_end, __last);
      }
      else {
        rotate(__first, __middle, __last);
        advance(__first, distance(__middle, __last));
        return __first;
      }
    }






  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BidirectionalIter3>
    _BidirectionalIter3
    __merge_backward(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
                     _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
                     _BidirectionalIter3 __result)
    {
      if (__first1 == __last1)
        return copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
        return copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true) {
        if (*__last2 < *__last1) {
          *--__result = *__last1;
          if (__first1 == __last1)
            return copy_backward(__first2, ++__last2, __result);
          --__last1;
        }
        else {
          *--__result = *__last2;
          if (__first2 == __last2)
            return copy_backward(__first1, ++__last1, __result);
          --__last2;
        }
      }
    }






  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BidirectionalIter3, typename _Compare>
    _BidirectionalIter3
    __merge_backward(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
                     _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
                     _BidirectionalIter3 __result,
                     _Compare __comp)
    {
      if (__first1 == __last1)
        return copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
        return copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true) {
        if (__comp(*__last2, *__last1)) {
          *--__result = *__last1;
          if (__first1 == __last1)
            return copy_backward(__first2, ++__last2, __result);
          --__last1;
        }
        else {
          *--__result = *__last2;
          if (__first2 == __last2)
            return copy_backward(__first1, ++__last1, __result);
          --__last2;
        }
      }
    }






  template<typename _BidirectionalIter, typename _Distance, typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIter __first,
                     _BidirectionalIter __middle,
                     _BidirectionalIter __last,
                     _Distance __len1, _Distance __len2,
                     _Pointer __buffer, _Distance __buffer_size)
    {
          if (__len1 <= __len2 && __len1 <= __buffer_size) {
            _Pointer __buffer_end = copy(__first, __middle, __buffer);
            merge(__buffer, __buffer_end, __middle, __last, __first);
          }
          else if (__len2 <= __buffer_size) {
            _Pointer __buffer_end = copy(__middle, __last, __buffer);
            __merge_backward(__first, __middle, __buffer, __buffer_end, __last);
          }
          else {
            _BidirectionalIter __first_cut = __first;
            _BidirectionalIter __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2) {
                  __len11 = __len1 / 2;
                  advance(__first_cut, __len11);
                  __second_cut = lower_bound(__middle, __last, *__first_cut);
                  __len22 = distance(__middle, __second_cut);
            }
            else {
                  __len22 = __len2 / 2;
                  advance(__second_cut, __len22);
                  __first_cut = upper_bound(__first, __middle, *__second_cut);
                  __len11 = distance(__first, __first_cut);
            }
            _BidirectionalIter __new_middle =
                  __rotate_adaptive(__first_cut, __middle, __second_cut,
                                    __len1 - __len11, __len22, __buffer,
                                    __buffer_size);
            __merge_adaptive(__first, __first_cut, __new_middle, __len11,
                             __len22, __buffer, __buffer_size);
            __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
                             __len2 - __len22, __buffer, __buffer_size);
          }
    }






  template<typename _BidirectionalIter, typename _Distance, typename _Pointer,
           typename _Compare>
    void
    __merge_adaptive(_BidirectionalIter __first,
                     _BidirectionalIter __middle,
                     _BidirectionalIter __last,
                     _Distance __len1, _Distance __len2,
                     _Pointer __buffer, _Distance __buffer_size,
                     _Compare __comp)
    {
          if (__len1 <= __len2 && __len1 <= __buffer_size) {
            _Pointer __buffer_end = copy(__first, __middle, __buffer);
            merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
          }
          else if (__len2 <= __buffer_size) {
            _Pointer __buffer_end = copy(__middle, __last, __buffer);
            __merge_backward(__first, __middle, __buffer, __buffer_end, __last,
                                             __comp);
          }
          else {
            _BidirectionalIter __first_cut = __first;
            _BidirectionalIter __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2) {
                  __len11 = __len1 / 2;
                  advance(__first_cut, __len11);
                  __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
                  __len22 = distance(__middle, __second_cut);
            }
            else {
                  __len22 = __len2 / 2;
                  advance(__second_cut, __len22);
                  __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
                  __len11 = distance(__first, __first_cut);
            }
            _BidirectionalIter __new_middle =
                  __rotate_adaptive(__first_cut, __middle, __second_cut,
                                    __len1 - __len11, __len22, __buffer,
                                    __buffer_size);
            __merge_adaptive(__first, __first_cut, __new_middle, __len11,
                             __len22, __buffer, __buffer_size, __comp);
            __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
                             __len2 - __len22, __buffer, __buffer_size, __comp);
          }
    }
# 3508 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIter>
    void
    inplace_merge(_BidirectionalIter __first,
                  _BidirectionalIter __middle,
                  _BidirectionalIter __last)
    {
      typedef typename iterator_traits<_BidirectionalIter>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIter>::difference_type
          _DistanceType;


     

     

      if (__first == __middle || __middle == __last)
        return;

      _DistanceType __len1 = distance(__first, __middle);
      _DistanceType __len2 = distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIter, _ValueType> __buf(__first, __last);
      if (__buf.begin() == 0)
        __merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
        __merge_adaptive(__first, __middle, __last, __len1, __len2,
                         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3559 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIter, typename _Compare>
    void
    inplace_merge(_BidirectionalIter __first,
                  _BidirectionalIter __middle,
                  _BidirectionalIter __last,
                  _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIter>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIter>::difference_type
          _DistanceType;


     

     


      if (__first == __middle || __middle == __last)
        return;

      _DistanceType __len1 = distance(__first, __middle);
      _DistanceType __len2 = distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIter, _ValueType> __buf(__first, __last);
      if (__buf.begin() == 0)
        __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
      else
        __merge_adaptive(__first, __middle, __last, __len1, __len2,
                         __buf.begin(), _DistanceType(__buf.size()),
                         __comp);
    }






  template<typename _InputIter1, typename _InputIter2>
    bool
    includes(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2, _InputIter2 __last2)
    {

     
     
     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first2 < *__first1)
          return false;
        else if(*__first1 < *__first2)
          ++__first1;
        else
          ++__first1, ++__first2;

      return __first2 == __last2;
    }

  template<typename _InputIter1, typename _InputIter2, typename _Compare>
    bool
    includes(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2, _InputIter2 __last2, _Compare __comp)
    {

     
     
     


     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first2, *__first1))
          return false;
        else if(__comp(*__first1, *__first2))
          ++__first1;
        else
          ++__first1, ++__first2;

      return __first2 == __last2;
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_union(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2,
              _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2) {
        if (*__first1 < *__first2) {
          *__result = *__first1;
          ++__first1;
        }
        else if (*__first2 < *__first1) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_union(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2,
              _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2) {
        if (__comp(*__first1, *__first2)) {
          *__result = *__first1;
          ++__first1;
        }
        else if (__comp(*__first2, *__first1)) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2, _InputIter2 __last2,
                     _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first1 < *__first2)
          ++__first1;
        else if (*__first2 < *__first1)
          ++__first2;
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
          ++__result;
        }
      return __result;
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2, _InputIter2 __last2,
                     _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first1, *__first2))
          ++__first1;
        else if (__comp(*__first2, *__first1))
          ++__first2;
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
          ++__result;
        }
      return __result;
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_difference(_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first1 < *__first2) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (*__first2 < *__first1)
          ++__first2;
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first1, __last1, __result);
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_difference(_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first1, *__first2)) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (__comp(*__first2, *__first1))
          ++__first2;
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first1, __last1, __result);
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first1 < *__first2) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (*__first2 < *__first1) {
          *__result = *__first2;
          ++__first2;
          ++__result;
        }
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result,
                             _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first1, *__first2)) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (__comp(*__first2, *__first1)) {
          *__result = *__first2;
          ++__first2;
          ++__result;
        }
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }




  template<typename _ForwardIter>
    _ForwardIter
    max_element(_ForwardIter __first, _ForwardIter __last)
    {

     
     


      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (*__result < *__first)
          __result = __first;
      return __result;
    }

  template<typename _ForwardIter, typename _Compare>
    _ForwardIter
    max_element(_ForwardIter __first, _ForwardIter __last,
                _Compare __comp)
    {

     
     



      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }

  template<typename _ForwardIter>
    _ForwardIter
    min_element(_ForwardIter __first, _ForwardIter __last)
    {

     
     


      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (*__first < *__result)
          __result = __first;
      return __result;
    }

  template<typename _ForwardIter, typename _Compare>
    _ForwardIter
    min_element(_ForwardIter __first, _ForwardIter __last,
                _Compare __comp)
    {

     
     



      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (__comp(*__first, *__result))
          __result = __first;
      return __result;
    }




  template<typename _BidirectionalIter>
    bool
    next_permutation(_BidirectionalIter __first, _BidirectionalIter __last)
    {

     
     


      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (*__i < *__ii) {
          _BidirectionalIter __j = __last;
          while (!(*__i < *--__j))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }

  template<typename _BidirectionalIter, typename _Compare>
    bool
    next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                     _Compare __comp)
    {

     
     



      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (__comp(*__i, *__ii)) {
          _BidirectionalIter __j = __last;
          while (!__comp(*__i, *--__j))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }

  template<typename _BidirectionalIter>
    bool
    prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last)
    {

     
     


      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (*__ii < *__i) {
          _BidirectionalIter __j = __last;
          while (!(*--__j < *__i))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }

  template<typename _BidirectionalIter, typename _Compare>
    bool
    prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                     _Compare __comp)
    {

     
     



      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (__comp(*__ii, *__i)) {
          _BidirectionalIter __j = __last;
          while (!__comp(*--__j, *__i))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }



  template<typename _InputIter, typename _ForwardIter>
    _InputIter
    find_first_of(_InputIter __first1, _InputIter __last1,
                  _ForwardIter __first2, _ForwardIter __last2)
    {

     
     
     



      for ( ; __first1 != __last1; ++__first1)
        for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
          if (*__first1 == *__iter)
            return __first1;
      return __last1;
    }

  template<typename _InputIter, typename _ForwardIter, typename _BinaryPredicate>
    _InputIter
    find_first_of(_InputIter __first1, _InputIter __last1,
                  _ForwardIter __first2, _ForwardIter __last2,
                  _BinaryPredicate __comp)
    {

     
     
     


     



      for ( ; __first1 != __last1; ++__first1)
        for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
          if (__comp(*__first1, *__iter))
            return __first1;
      return __last1;
    }
# 4201 "/usr/include/c++/3.3/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    _ForwardIter1
    __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
               _ForwardIter2 __first2, _ForwardIter2 __last2,
               forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
        return __last1;
      else {
        _ForwardIter1 __result = __last1;
        while (1) {
          _ForwardIter1 __new_result
            = search(__first1, __last1, __first2, __last2);
          if (__new_result == __last1)
            return __result;
          else {
            __result = __new_result;
            __first1 = __new_result;
            ++__first1;
          }
        }
      }
    }

  template<typename _ForwardIter1, typename _ForwardIter2,
           typename _BinaryPredicate>
    _ForwardIter1
    __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
               _ForwardIter2 __first2, _ForwardIter2 __last2,
               forward_iterator_tag, forward_iterator_tag,
               _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
        return __last1;
      else {
        _ForwardIter1 __result = __last1;
        while (1) {
          _ForwardIter1 __new_result
            = search(__first1, __last1, __first2, __last2, __comp);
          if (__new_result == __last1)
            return __result;
          else {
            __result = __new_result;
            __first1 = __new_result;
            ++__first1;
          }
        }
      }
    }


  template<typename _BidirectionalIter1, typename _BidirectionalIter2>
    _BidirectionalIter1
    __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
               _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
               bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     
     

      typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
      typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

      _RevIter1 __rlast1(__first1);
      _RevIter2 __rlast2(__first2);
      _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                                   _RevIter2(__last2), __rlast2);

      if (__rresult == __rlast1)
        return __last1;
      else {
        _BidirectionalIter1 __result = __rresult.base();
        advance(__result, -distance(__first2, __last2));
        return __result;
      }
    }

  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BinaryPredicate>
    _BidirectionalIter1
    __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
               _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
               bidirectional_iterator_tag, bidirectional_iterator_tag,
               _BinaryPredicate __comp)
    {

     
     

      typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
      typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

      _RevIter1 __rlast1(__first1);
      _RevIter2 __rlast2(__first2);
      _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                                   _RevIter2(__last2), __rlast2,
                                   __comp);

      if (__rresult == __rlast1)
        return __last1;
      else {
        _BidirectionalIter1 __result = __rresult.base();
        advance(__result, -distance(__first2, __last2));
        return __result;
      }
    }



  template<typename _ForwardIter1, typename _ForwardIter2>
    inline _ForwardIter1
    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
             _ForwardIter2 __first2, _ForwardIter2 __last2)
    {

     
     
     



      return __find_end(__first1, __last1, __first2, __last2,
                        __iterator_category(__first1),
                        __iterator_category(__first2));
    }

  template<typename _ForwardIter1, typename _ForwardIter2,
           typename _BinaryPredicate>
    inline _ForwardIter1
    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
             _ForwardIter2 __first2, _ForwardIter2 __last2,
             _BinaryPredicate __comp)
    {

     
     
     



      return __find_end(__first1, __last1, __first2, __last2,
                        __iterator_category(__first1),
                        __iterator_category(__first2),
                        __comp);
    }

}
# 70 "/usr/include/c++/3.3/algorithm" 2 3
# 57 "/usr/include/c++/3.3/string" 2 3
# 1 "/usr/include/c++/3.3/bits/basic_string.tcc" 1 3
# 44 "/usr/include/c++/3.3/bits/basic_string.tcc" 3
       
# 45 "/usr/include/c++/3.3/bits/basic_string.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_S_empty_rep_storage[
    (sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIter>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,
                   input_iterator_tag)
      {
        if (__beg == __end && __a == _Alloc())
          return _S_empty_rep()._M_refcopy();

        _CharT __buf[100];
        size_type __i = 0;
        while (__beg != __end && __i < sizeof(__buf) / sizeof(_CharT))
          {
            __buf[__i++] = *__beg;
            ++__beg;
          }
        _Rep* __r = _Rep::_S_create(__i, __a);
        traits_type::copy(__r->_M_refdata(), __buf, __i);
        __r->_M_length = __i;
        if (true)
          {



            for (;;)
              {
                _CharT* __p = __r->_M_refdata() + __r->_M_length;
                _CharT* __last = __r->_M_refdata() + __r->_M_capacity;
                for (;;)
                  {
                    if (__beg == __end)
                      {
                        __r->_M_length = __p - __r->_M_refdata();
                        *__p = _Rep::_S_terminal;
                        return __r->_M_refdata();
                      }
                    if (__p == __last)
                      break;
                    *__p++ = *__beg;
                    ++__beg;
                  }

                size_type __len = __p - __r->_M_refdata();
                _Rep* __another = _Rep::_S_create(__len + 1, __a);
                traits_type::copy(__another->_M_refdata(),
                                  __r->_M_refdata(), __len);
                __r->_M_destroy(__a);
                __r = __another;
                __r->_M_length = __len;
              }
          }
        if (false)
          {
            __r->_M_destroy(__a);
            ;
          }
        return 0;
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <class _InIter>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,
                   forward_iterator_tag)
      {
        if (__beg == __end && __a == _Alloc())
          return _S_empty_rep()._M_refcopy();


        if (__builtin_expect(__beg == _InIter(), 0))
          __throw_logic_error("attempt to create string with null pointer");

        size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));


        _Rep* __r = _Rep::_S_create(__dnew, __a);
        if (true)
          { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
        if (false)
          {
            __r->_M_destroy(__a);
            ;
          }
        __r->_M_length = __dnew;

        __r->_M_refdata()[__dnew] = _Rep::_S_terminal;
        return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {
      if (__n == 0 && __a == _Alloc())
        return _S_empty_rep()._M_refcopy();


      _Rep* __r = _Rep::_S_create(__n, __a);
      if (true)
        {
          if (__n)
            traits_type::assign(__r->_M_refdata(), __n, __c);
        }
      if (false)
        {
          __r->_M_destroy(__a);
          ;
        }
      __r->_M_length = __n;
      __r->_M_refdata()[__n] = _Rep::_S_terminal;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(), __str.get_allocator()),
                 __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_check(__pos),
                               __str._M_fold(__pos, __n), _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
                 size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_check(__pos),
                               __str._M_fold(__pos, __n), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
                               __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIter>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIter __beg, _InputIter __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
        {

          allocator_type __a = this->get_allocator();
          _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
          _M_rep()->_M_dispose(__a);
          _M_data(__tmp);
        }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     assign(const basic_string& __str, size_type __pos, size_type __n)
     {
       const size_type __strsize = __str.size();
       if (__pos > __strsize)
         __throw_out_of_range("basic_string::assign");
       const bool __testn = __n < __strsize - __pos;
       const size_type __newsize = __testn ? __n : __strsize - __pos;
       return this->assign(__str._M_data() + __pos, __newsize);
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     assign(const _CharT* __s, size_type __n)
     {
       if (__n > this->max_size())
         __throw_length_error("basic_string::assign");
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
           || less<const _CharT*>()(_M_data() + this->size(), __s))
         return _M_replace_safe(_M_ibegin(), _M_iend(), __s, __s + __n);
       else
         {

           const size_type __pos = __s - _M_data();
           if (__pos >= __n)
             traits_type::copy(_M_data(), __s, __n);
           else if (__pos)
             traits_type::move(_M_data(), __s, __n);
           _M_rep()->_M_length = __n;
           _M_data()[__n] = _Rep::_S_terminal;
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos1, const basic_string& __str,
            size_type __pos2, size_type __n)
     {
       const size_type __strsize = __str.size();
       if (__pos2 > __strsize)
         __throw_out_of_range("basic_string::insert");
       const bool __testn = __n < __strsize - __pos2;
       const size_type __newsize = __testn ? __n : __strsize - __pos2;
       return this->insert(__pos1, __str._M_data() + __pos2, __newsize);
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       const size_type __size = this->size();
       if (__pos > __size)
         __throw_out_of_range("basic_string::insert");
       if (__size > this->max_size() - __n)
         __throw_length_error("basic_string::insert");
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
           || less<const _CharT*>()(_M_data() + __size, __s))
         return _M_replace_safe(_M_ibegin() + __pos, _M_ibegin() + __pos,
                                __s, __s + __n);
       else
         {



           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             traits_type::copy(__p, __s, __n);
           else if (__s >= __p)
             traits_type::copy(__p, __s + __n, __n);
           else
             {
               traits_type::copy(__p, __s, __p - __s);
               traits_type::copy(__p + (__p-__s), __p + __n, __n - (__p-__s));
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
             size_type __n2)
     {
       const size_type __size = this->size();
       if (__pos > __size)
         __throw_out_of_range("basic_string::replace");
       const bool __testn1 = __n1 < __size - __pos;
       const size_type __foldn1 = __testn1 ? __n1 : __size - __pos;
       if (__size - __foldn1 > this->max_size() - __n2)
         __throw_length_error("basic_string::replace");
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
           || less<const _CharT*>()(_M_data() + __size, __s))
         return _M_replace_safe(_M_ibegin() + __pos,
                                _M_ibegin() + __pos + __foldn1, __s, __s + __n2);

       else
         return _M_replace(_M_ibegin() + __pos, _M_ibegin() + __pos + __foldn1,
                           __s, __s + __n2,
                           typename iterator_traits<const _CharT*>::iterator_category());
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a)
    {
      size_type __size = sizeof(_Rep) + (_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_M_leak_hard()
    {
      if (_M_rep()->_M_is_shared())
        _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const _CharT* __src = _M_data() + __pos + __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (_M_rep()->_M_is_shared() || __new_size > capacity())
        {

          allocator_type __a = get_allocator();


          const size_type __pagesize = 4096;
          const size_type __malloc_header_size = 4 * sizeof (void*);

          const size_type __page_capacity = (__pagesize - __malloc_header_size
                                             - sizeof(_Rep) - sizeof(_CharT))
                                             / sizeof(_CharT);
          _Rep* __r;
          if (__new_size > capacity() && __new_size > __page_capacity)

            __r = _Rep::_S_create(__new_size > 2*capacity() ?
                                  __new_size : 2*capacity(), __a);
          else
            __r = _Rep::_S_create(__new_size, __a);
          if (true)
            {
              if (__pos)
                traits_type::copy(__r->_M_refdata(), _M_data(), __pos);
              if (__how_much)
                traits_type::copy(__r->_M_refdata() + __pos + __len2,
                                  __src, __how_much);
            }
          if (false)
            {
              __r->_M_dispose(get_allocator());
              ;
            }
          _M_rep()->_M_dispose(__a);
          _M_data(__r->_M_refdata());
      }
      else if (__how_much && __len1 != __len2)
        {

          traits_type::move(_M_data() + __pos + __len2, __src, __how_much);
        }
      _M_rep()->_M_set_sharable();
      _M_rep()->_M_length = __new_size;
      _M_data()[__new_size] = _Rep::_S_terminal;

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::reserve(size_type __res)
    {
      if (__res > this->capacity() || _M_rep()->_M_is_shared())
        {
          if (__res > this->max_size())
            __throw_length_error("basic_string::reserve");

          if (__res < this->size())
            __res = this->size();
          allocator_type __a = get_allocator();
          _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
          _M_rep()->_M_dispose(__a);
          _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
        _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
        __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
        {
          _CharT* __tmp = _M_data();
          _M_data(__s._M_data());
          __s._M_data(__tmp);
        }

      else
        {
          basic_string __tmp1(_M_ibegin(), _M_iend(), __s.get_allocator());
          basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
                              this->get_allocator());
          *this = __tmp2;
          __s = __tmp1;
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_t __capacity, const _Alloc& __alloc)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;


      if (__capacity > _S_max_size)



        __throw_length_error("basic_string::_S_create");




      size_t __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
# 532 "/usr/include/c++/3.3/bits/basic_string.tcc" 3
      const size_t __pagesize = 4096;
      const size_t __subpagesize = 128;
      const size_t __malloc_header_size = 4 * sizeof (void*);
      if ((__size + __malloc_header_size) > __pagesize)
        {
          size_t __extra =
            (__pagesize - ((__size + __malloc_header_size) % __pagesize))
            % __pagesize;
          __capacity += __extra / sizeof(_CharT);
          __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
        }
      else if (__size > __subpagesize)
        {
          size_t __extra =
            (__subpagesize - ((__size + __malloc_header_size) % __subpagesize))
            % __subpagesize;
          __capacity += __extra / sizeof(_CharT);
          __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
        }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      __p->_M_set_sharable();
      __p->_M_length = 0;
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = _M_length + __res;

      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof (void*);

      const size_type __page_capacity =
        (__pagesize - __malloc_header_size - sizeof(_Rep) - sizeof(_CharT))
        / sizeof(_CharT);
      _Rep* __r;
      if (__requested_cap > _M_capacity && __requested_cap > __page_capacity)

        __r = _Rep::_S_create(__requested_cap > 2*_M_capacity ?
                              __requested_cap : 2*_M_capacity, __alloc);
      else
        __r = _Rep::_S_create(__requested_cap, __alloc);

      if (_M_length)
        {
          if (true)
            { traits_type::copy(__r->_M_refdata(), _M_refdata(), _M_length); }
          if (false)
            {
              __r->_M_destroy(__alloc);
              ;
            }
        }
      __r->_M_length = _M_length;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n, _CharT __c)
    {
      if (__n > max_size())
        __throw_length_error("basic_string::resize");
      size_type __size = this->size();
      if (__size < __n)
        this->append(__n - __size, __c);
      else if (__n < __size)
        this->erase(__n);

    }




  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIter>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace(iterator __i1, iterator __i2, _InputIter __k1,
                 _InputIter __k2, input_iterator_tag)
      {

        basic_string __s(__k1, __k2);
        return _M_replace_safe(__i1, __i2, __s._M_ibegin(), __s._M_iend());
      }




  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _ForwardIter>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_safe(iterator __i1, iterator __i2, _ForwardIter __k1,
                      _ForwardIter __k2)
      {
        size_type __dnew = static_cast<size_type>(std::distance(__k1, __k2));
        size_type __dold = __i2 - __i1;
        size_type __dmax = this->max_size();

        if (__dmax <= __dnew)
          __throw_length_error("basic_string::_M_replace");
        size_type __off = __i1 - _M_ibegin();
        _M_mutate(__off, __dold, __dnew);


        if (__dnew)
          _S_copy_chars(_M_data() + __off, __k1, __k2);

        return *this;
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    replace(size_type __pos1, size_type __n1, const basic_string& __str,
            size_type __pos2, size_type __n2)
    {
      const size_type __strsize = __str.size();
      if (__pos2 > __strsize)
        __throw_out_of_range("basic_string::replace");
      const bool __testn2 = __n2 < __strsize - __pos2;
      const size_type __foldn2 = __testn2 ? __n2 : __strsize - __pos2;
      return this->replace(__pos1, __n1,
                           __str._M_data() + __pos2, __foldn2);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {



      size_type __size = __str.size();
      size_type __len = __size + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
      return _M_replace_safe(_M_iend(), _M_iend(), __str._M_ibegin(),
                             __str._M_iend());
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {



      size_type __len = std::min(size_type(__str.size() - __pos),
                                 __n) + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
      return _M_replace_safe(_M_iend(), _M_iend(), __str._M_check(__pos),
                             __str._M_fold(__pos, __n));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      size_type __len = __n + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
      return _M_replace_safe(_M_iend(), _M_iend(), __s, __s + __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      size_type __len = __n + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
       return this->replace(_M_iend(), _M_iend(), __n, __c);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __lhs + __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    replace(iterator __i1, iterator __i2, size_type __n2, _CharT __c)
    {
      size_type __n1 = __i2 - __i1;
      size_type __off1 = __i1 - _M_ibegin();
      if (max_size() - (this->size() - __n1) <= __n2)
        __throw_length_error("basic_string::replace");
      _M_mutate (__off1, __n1, __n2);

      if (__n2)
        traits_type::assign(_M_data() + __off1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      if (__pos > this->size())
        __throw_out_of_range("basic_string::copy");

      if (__n > this->size() - __pos)
        __n = this->size() - __pos;

      traits_type::copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      size_t __xpos = __pos;
      const _CharT* __data = _M_data();
      for (; __xpos + __n <= __size; ++__xpos)
        if (traits_type::compare(__data + __xpos, __s, __n) == 0)
          return __xpos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      size_type __ret = npos;
      if (__pos < __size)
        {
          const _CharT* __data = _M_data();
          size_type __n = __size - __pos;
          const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
          if (__p)
            __ret = __p - __data;
        }
      return __ret;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      if (__n <= __size)
        {
          __pos = std::min(size_type(__size - __n), __pos);
          const _CharT* __data = _M_data();
          do
            {
              if (traits_type::compare(__data + __pos, __s, __n) == 0)
                return __pos;
            }
          while (__pos-- > 0);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
        {
          size_t __xpos = __size - 1;
          if (__xpos > __pos)
            __xpos = __pos;

          for (++__xpos; __xpos-- > 0; )
            if (traits_type::eq(_M_data()[__xpos], __c))
              return __xpos;
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      for (; __n && __pos < this->size(); ++__pos)
        {
          const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
          if (__p)
            return __pos;
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      if (__size && __n)
        {
          if (--__size > __pos)
            __size = __pos;
          do
            {
              if (traits_type::find(__s, __n, _M_data()[__size]))
                return __size;
            }
          while (__size-- != 0);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_t __xpos = __pos;
      for (; __xpos < this->size(); ++__xpos)
        if (!traits_type::find(__s, __n, _M_data()[__xpos]))
          return __xpos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      size_t __xpos = __pos;
      for (; __xpos < this->size(); ++__xpos)
        if (!traits_type::eq(_M_data()[__xpos], __c))
          return __xpos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      if (__size)
        {
          if (--__size > __pos)
            __size = __pos;
          do
            {
              if (!traits_type::find(__s, __n, _M_data()[__size]))
                return __size;
            }
          while (__size--);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
        {
          if (--__size > __pos)
            __size = __pos;
          do
            {
              if (!traits_type::eq(_M_data()[__size], __c))
                return __size;
            }
          while (__size--);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      size_type __size = this->size();
      size_type __osize = __str.size();
      if (__pos > __size)
        __throw_out_of_range("basic_string::compare");

      size_type __rsize= std::min(size_type(__size - __pos), __n);
      size_type __len = std::min(__rsize, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
        __r = __rsize - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
            size_type __pos2, size_type __n2) const
    {
      size_type __size = this->size();
      size_type __osize = __str.size();
      if (__pos1 > __size || __pos2 > __osize)
        __throw_out_of_range("basic_string::compare");

      size_type __rsize = std::min(size_type(__size - __pos1), __n1);
      size_type __rosize = std::min(size_type(__osize - __pos2), __n2);
      size_type __len = std::min(__rsize, __rosize);
      int __r = traits_type::compare(_M_data() + __pos1,
                                     __str.data() + __pos2, __len);
      if (!__r)
        __r = __rsize - __rosize;
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      size_type __size = this->size();
      size_type __osize = traits_type::length(__s);
      size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
        __r = __size - __osize;
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      size_type __size = this->size();
      if (__pos > __size)
        __throw_out_of_range("basic_string::compare");

      size_type __osize = traits_type::length(__s);
      size_type __rsize = std::min(size_type(__size - __pos), __n1);
      size_type __len = std::min(__rsize, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
        __r = __rsize - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
            size_type __n2) const
    {
      size_type __size = this->size();
      if (__pos > __size)
        __throw_out_of_range("basic_string::compare");

      size_type __osize = std::min(traits_type::length(__s), __n2);
      size_type __rsize = std::min(size_type(__size - __pos), __n1);
      size_type __len = std::min(__rsize, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
        __r = __rsize - __osize;
      return __r;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    _S_string_copy(const basic_string<_CharT, _Traits, _Alloc>& __str,
                   _CharT* __buf, typename _Alloc::size_type __bufsiz)
    {
      typedef typename _Alloc::size_type size_type;
      size_type __strsize = __str.size();
      size_type __bytes = std::min(__strsize, __bufsiz - 1);
      _Traits::copy(__buf, __str.data(), __bytes);
      __buf[__bytes] = _CharT();
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);


}
# 58 "/usr/include/c++/3.3/string" 2 3
# 36 "/usr/include/gtk++/gtypedefs.hpp" 2 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 67 "/usr/include/assert.h" 3 4



extern void __assert_fail (const char *__assertion, const char *__file,
                           unsigned int __line, const char *__function)
     ;


extern void __assert_perror_fail (int __errnum, const char *__file,
                                  unsigned int __line,
                                  const char *__function)
     ;




extern void __assert (const char *__assertion, const char *__file, int __line)
     ;



# 37 "/usr/include/gtk++/gtypedefs.hpp" 2 3 4
# 1 "/usr/include/c++/3.3/iostream" 1 3 4
# 42 "/usr/include/c++/3.3/iostream" 3 4
       
# 43 "/usr/include/c++/3.3/iostream" 3


# 1 "/usr/include/c++/3.3/ostream" 1 3
# 43 "/usr/include/c++/3.3/ostream" 3
       
# 44 "/usr/include/c++/3.3/ostream" 3

# 1 "/usr/include/c++/3.3/ios" 1 3
# 42 "/usr/include/c++/3.3/ios" 3
       
# 43 "/usr/include/c++/3.3/ios" 3





# 1 "/usr/include/c++/3.3/bits/localefwd.h" 1 3
# 43 "/usr/include/c++/3.3/bits/localefwd.h" 3
       
# 44 "/usr/include/c++/3.3/bits/localefwd.h" 3




# 1 "/usr/include/c++/3.3/bits/functexcept.h" 1 3
# 34 "/usr/include/c++/3.3/bits/functexcept.h" 3
# 1 "/usr/include/c++/3.3/exception_defines.h" 1 3
# 35 "/usr/include/c++/3.3/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 49 "/usr/include/c++/3.3/bits/localefwd.h" 2 3

namespace std
{

  class locale;


  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;


  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) ;
}
# 49 "/usr/include/c++/3.3/ios" 2 3
# 1 "/usr/include/c++/3.3/bits/ios_base.h" 1 3
# 43 "/usr/include/c++/3.3/bits/ios_base.h" 3
       
# 44 "/usr/include/c++/3.3/bits/ios_base.h" 3



# 1 "/usr/include/c++/3.3/bits/locale_classes.h" 1 3
# 43 "/usr/include/c++/3.3/bits/locale_classes.h" 3
       
# 44 "/usr/include/c++/3.3/bits/locale_classes.h" 3






namespace std
{
  class __locale_cache_base;
  template<typename _Facet> class __locale_cache;


  class locale
  {
  public:

    typedef unsigned int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) ;

    template<typename _Facet>
      friend const __locale_cache<_Facet>&
      __use_cache(const locale&);



    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
                                           time | monetary | messages);


    locale() ;

    locale(const locale& __other) ;

    explicit
    locale(const char* __s);

    locale(const locale& __base, const char* __s, category __cat);

    locale(const locale& __base, const locale& __add, category __cat);

    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);

    ~locale() ;

    const locale&
    operator=(const locale& __other) ;

    template<typename _Facet>
      locale
      combine(const locale& __other) const;


    string
    name() const;

    bool
    operator==(const locale& __other) const ;

    inline bool
    operator!=(const locale& __other) const
    { return !(this->operator==(__other)); }

    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
                 const basic_string<_Char, _Traits, _Alloc>& __s2) const;


    static locale
    global(const locale&);

    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;






    static const size_t _S_categories_size = 6;






    static const size_t _S_extra_categories_size = 6;





    static const char* _S_categories[_S_categories_size
                                      + _S_extra_categories_size];

    explicit
    locale(_Impl*) ;

    static inline void
    _S_initialize()
    {
      if (!_S_classic)
        classic();
    }

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) ;

    template<typename _Facet>
      friend const __locale_cache<_Facet>&
      __use_cache(const locale&);

  private:

    _Atomic_word _M_references;
    facet** _M_facets;
    size_t _M_facets_size;

    char* _M_names[_S_categories_size
                                                 + _S_extra_categories_size];
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    inline void
    _M_add_reference()
    { __atomic_add(&_M_references, 1); }

    inline void
    _M_remove_reference()
    {
      if (__exchange_and_add(&_M_references, -1) == 1)
        {
          if (true)
            { delete this; }
          if (false)
            { }
        }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(facet**, size_t, bool);

   ~_Impl() ;

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      for (size_t __i = 0;
           __ret && __i < _S_categories_size + _S_extra_categories_size - 1;
           ++__i)
        __ret &= (strcmp(_M_names[__i], _M_names[__i + 1]) == 0);
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, facet*);

    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }




    inline __locale_cache_base*
      _M_get_cache(size_t __index)
      {
        return (__locale_cache_base*)_M_facets[__index + _M_facets_size];
      }



    void
    _M_install_cache(__locale_cache_base* __cache, int __id)
    {
      _M_facets[__id + _M_facets_size] =
        reinterpret_cast<locale::facet*>(__cache);
    }

  };

  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);
      _M_impl->_M_install_facet(&_Facet::id, __f);
      for (size_t __i = 0;
           __i < _S_categories_size + _S_extra_categories_size; ++__i)
        {
          delete [] _M_impl->_M_names[__i];
          char* __new = new char[2];
          strcpy(__new, "*");
          _M_impl->_M_names[__i] = __new;
        }
    }



  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    _Atomic_word _M_references;

  protected:

    static __c_locale _S_c_locale;


    static char _S_c_name[2];

    explicit
    facet(size_t __refs = 0) ;

    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
                       __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

  private:
    void
    _M_add_reference() ;

    void
    _M_remove_reference() ;

    facet(const facet&);

    void
    operator=(const facet&);
  };



  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
    template<typename _Facet>
      friend bool
      has_facet(const locale&) ;




    mutable size_t _M_index;


    static _Atomic_word _S_highwater;

    void
    operator=(const id&);

    id(const id&);

  public:


    id();

    inline size_t
    _M_id() const
    {
      if (!_M_index)
        _M_index = 1 + __exchange_and_add(&_S_highwater, 1);
      return _M_index - 1;
    }
  };
}
# 48 "/usr/include/c++/3.3/bits/ios_base.h" 2 3

namespace std
{




  enum _Ios_Fmtflags { _M_ios_fmtflags_end = 1L << 16 };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode { _M_ios_openmode_end = 1L << 16 };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate { _M_ios_iostate_end = 1L << 16 };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir { _M_ios_seekdir_end = 1L << 16 };
# 158 "/usr/include/c++/3.3/bits/ios_base.h" 3
  class ios_base
  {
  public:



    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) ;



      virtual
      ~failure() ;

      virtual const char*
      what() const ;

    private:
      enum { _M_bufsize = 256 };
      char _M_name[_M_bufsize];

    };
# 212 "/usr/include/c++/3.3/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;

    static const fmtflags boolalpha = fmtflags(__ios_flags::_S_boolalpha);

    static const fmtflags dec = fmtflags(__ios_flags::_S_dec);

    static const fmtflags fixed = fmtflags(__ios_flags::_S_fixed);

    static const fmtflags hex = fmtflags(__ios_flags::_S_hex);



    static const fmtflags internal = fmtflags(__ios_flags::_S_internal);


    static const fmtflags left = fmtflags(__ios_flags::_S_left);

    static const fmtflags oct = fmtflags(__ios_flags::_S_oct);


    static const fmtflags right = fmtflags(__ios_flags::_S_right);

    static const fmtflags scientific = fmtflags(__ios_flags::_S_scientific);


    static const fmtflags showbase = fmtflags(__ios_flags::_S_showbase);


    static const fmtflags showpoint = fmtflags(__ios_flags::_S_showpoint);

    static const fmtflags showpos = fmtflags(__ios_flags::_S_showpos);

    static const fmtflags skipws = fmtflags(__ios_flags::_S_skipws);

    static const fmtflags unitbuf = fmtflags(__ios_flags::_S_unitbuf);


    static const fmtflags uppercase = fmtflags(__ios_flags::_S_uppercase);

    static const fmtflags adjustfield = fmtflags(__ios_flags::_S_adjustfield);

    static const fmtflags basefield = fmtflags(__ios_flags::_S_basefield);

    static const fmtflags floatfield = fmtflags(__ios_flags::_S_floatfield);
# 269 "/usr/include/c++/3.3/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;


    static const iostate badbit = iostate(__ios_flags::_S_badbit);

    static const iostate eofbit = iostate(__ios_flags::_S_eofbit);



    static const iostate failbit = iostate(__ios_flags::_S_failbit);

    static const iostate goodbit = iostate(0);
# 296 "/usr/include/c++/3.3/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;

    static const openmode app = openmode(__ios_flags::_S_app);

    static const openmode ate = openmode(__ios_flags::_S_ate);




    static const openmode binary = openmode(__ios_flags::_S_bin);

    static const openmode in = openmode(__ios_flags::_S_in);

    static const openmode out = openmode(__ios_flags::_S_out);

    static const openmode trunc = openmode(__ios_flags::_S_trunc);
# 323 "/usr/include/c++/3.3/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;

    static const seekdir beg = seekdir(0);

    static const seekdir cur = seekdir(1);

    static const seekdir end = seekdir(2);
# 345 "/usr/include/c++/3.3/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };




    typedef void (*event_callback) (event, ios_base&, int);




    void
    register_callback(event_callback __fn, int __index);

  protected:






    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
                     _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __atomic_add(&_M_refcount, 1); }


      int
      _M_remove_reference() { return __exchange_and_add(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) ;

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    static const int _S_local_word_size = 8;
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

      static void
      _S_ios_create(bool __sync);

      static void
      _S_ios_destroy();




      static bool
      _S_initialized() { return _S_ios_base_init; }

    private:
      static int _S_ios_base_init;
      static bool _S_synced_with_stdio;
    };






    inline fmtflags
    flags() const { return _M_flags; }
# 481 "/usr/include/c++/3.3/bits/ios_base.h" 3
    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 497 "/usr/include/c++/3.3/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 514 "/usr/include/c++/3.3/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
# 541 "/usr/include/c++/3.3/bits/ios_base.h" 3
    inline streamsize
    precision() const { return _M_precision; }






    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    inline streamsize
    width() const { return _M_width; }






    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 590 "/usr/include/c++/3.3/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 602 "/usr/include/c++/3.3/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 613 "/usr/include/c++/3.3/bits/ios_base.h" 3
    inline locale
    getloc() const { return _M_ios_locale; }
# 623 "/usr/include/c++/3.3/bits/ios_base.h" 3
    inline const locale&
    _M_getloc() const { return _M_ios_locale; }





    static int
    xalloc() ;




    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
                        ? _M_word[__ix] : _M_grow_words(__ix);
      return __word._M_iword;
    }




    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
                        ? _M_word[__ix] : _M_grow_words(__ix);
      return __word._M_pword;
    }






    ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 50 "/usr/include/c++/3.3/ios" 2 3
# 1 "/usr/include/c++/3.3/streambuf" 1 3
# 43 "/usr/include/c++/3.3/streambuf" 3
       
# 44 "/usr/include/c++/3.3/streambuf" 3







namespace std
{





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_ios<_CharT, _Traits>& _ios,
                      basic_streambuf<_CharT, _Traits>* __sbin,
                      basic_streambuf<_CharT, _Traits>* __sbout);
# 124 "/usr/include/c++/3.3/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
# 147 "/usr/include/c++/3.3/streambuf" 3
      typedef ctype<char_type> __ctype_type;
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef typename traits_type::state_type __state_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs<>(basic_ios<char_type, traits_type>& __ios,
                          __streambuf_type* __sbin,__streambuf_type* __sbout);

    protected:
# 171 "/usr/include/c++/3.3/streambuf" 3
      char_type* _M_buf;






      size_t _M_buf_size;






      size_t _M_buf_size_opt;







      bool _M_buf_unified;
# 205 "/usr/include/c++/3.3/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;







      ios_base::openmode _M_mode;






      locale _M_buf_locale;






      bool _M_buf_locale_init;
# 245 "/usr/include/c++/3.3/streambuf" 3
      static const size_t _S_pback_size = 1;
      char_type _M_pback[_S_pback_size];
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;







      fpos<__state_type> _M_pos;




      void
      _M_pback_create()
      {
        if (!_M_pback_init)
          {
            size_t __dist = _M_in_end - _M_in_cur;
            size_t __len = min(_S_pback_size, __dist);
            traits_type::copy(_M_pback, _M_in_cur, __len);
            _M_pback_cur_save = _M_in_cur;
            _M_pback_end_save = _M_in_end;
            this->setg(_M_pback, _M_pback, _M_pback + __len);
            _M_pback_init = true;
          }
      }




      void
      _M_pback_destroy()
      {
        if (_M_pback_init)
          {

            size_t __off_cur = _M_in_cur - _M_pback;


            size_t __off_end = 0;
            size_t __pback_len = _M_in_end - _M_pback;
            size_t __save_len = _M_pback_end_save - _M_buf;
            if (__pback_len > __save_len)
              __off_end = __pback_len - __save_len;

            this->setg(_M_buf, _M_pback_cur_save + __off_cur,
                       _M_pback_end_save + __off_end);
            _M_pback_cur_save = ((void *)0);
            _M_pback_end_save = ((void *)0);
            _M_pback_init = false;
          }
      }



      void
      _M_in_cur_move(off_type __n)
      {
        bool __testout = _M_out_cur;
        _M_in_cur += __n;
        if (__testout && _M_buf_unified)
          _M_out_cur += __n;
      }
# 322 "/usr/include/c++/3.3/streambuf" 3
      void
      _M_out_cur_move(off_type __n)
      {
        bool __testin = _M_in_cur;

        _M_out_cur += __n;
        if (__testin && _M_buf_unified)
          _M_in_cur += __n;
        if (_M_out_cur > _M_out_end)
          {
            _M_out_end = _M_out_cur;

            if (__testin)
              _M_in_end += __n;
          }
      }




      off_type
      _M_out_buf_size()
      {
        off_type __ret = 0;
        if (_M_out_cur)
          {

            if (_M_out_beg == _M_buf)
              __ret = _M_out_beg + _M_buf_size - _M_out_cur;

            else
              __ret = _M_out_end - _M_out_cur;
          }
        return __ret;
      }

  public:

      virtual
      ~basic_streambuf()
      {
        _M_buf_unified = false;
        _M_buf_size = 0;
        _M_buf_size_opt = 0;
        _M_mode = ios_base::openmode(0);
      }
# 377 "/usr/include/c++/3.3/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
        locale __tmp(this->getloc());
        this->imbue(__loc);
        return __tmp;
      }
# 393 "/usr/include/c++/3.3/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 406 "/usr/include/c++/3.3/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
                 ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
                 ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 433 "/usr/include/c++/3.3/streambuf" 3
      streamsize
      in_avail()
      {
        streamsize __ret;
        if (_M_in_cur && _M_in_cur < _M_in_end)
          {
            if (_M_pback_init)
              {
                size_t __save_len = _M_pback_end_save - _M_pback_cur_save;
                size_t __pback_len = _M_in_cur - _M_pback;
                __ret = __save_len - __pback_len;
              }
            else
              __ret = this->egptr() - this->gptr();
          }
        else
          __ret = this->showmanyc();
        return __ret;
      }
# 460 "/usr/include/c++/3.3/streambuf" 3
      int_type
      snextc()
      {
        int_type __eof = traits_type::eof();
        return (traits_type::eq_int_type(this->sbumpc(), __eof)
                ? __eof : this->sgetc());
      }
# 476 "/usr/include/c++/3.3/streambuf" 3
      int_type
      sbumpc();
# 487 "/usr/include/c++/3.3/streambuf" 3
      int_type
      sgetc()
      {
        int_type __ret;
        if (_M_in_cur && _M_in_cur < _M_in_end)
          __ret = traits_type::to_int_type(*(this->gptr()));
        else
          __ret = this->underflow();
        return __ret;
      }
# 506 "/usr/include/c++/3.3/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 520 "/usr/include/c++/3.3/streambuf" 3
      int_type
      sputbackc(char_type __c);
# 532 "/usr/include/c++/3.3/streambuf" 3
      int_type
      sungetc();
# 548 "/usr/include/c++/3.3/streambuf" 3
      int_type
      sputc(char_type __c);
# 562 "/usr/include/c++/3.3/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 576 "/usr/include/c++/3.3/streambuf" 3
      basic_streambuf()
      : _M_buf(((void *)0)), _M_buf_size(0), _M_buf_size_opt(8192),
      _M_buf_unified(false), _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_mode(ios_base::openmode(0)), _M_buf_locale(locale()),
      _M_pback_cur_save(0), _M_pback_end_save(0),
      _M_pback_init(false)
      { }
# 597 "/usr/include/c++/3.3/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 613 "/usr/include/c++/3.3/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 624 "/usr/include/c++/3.3/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
        _M_in_beg = __gbeg;
        _M_in_cur = __gnext;
        _M_in_end = __gend;
        if (!(_M_mode & ios_base::in) && __gbeg && __gnext && __gend)
          _M_mode = _M_mode | ios_base::in;
      }
# 646 "/usr/include/c++/3.3/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 662 "/usr/include/c++/3.3/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 672 "/usr/include/c++/3.3/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
        _M_out_beg = _M_out_cur = __pbeg;
        _M_out_end = __pend;
        if (!(_M_mode & ios_base::out) && __pbeg && __pend)
          _M_mode = _M_mode | ios_base::out;
      }
# 694 "/usr/include/c++/3.3/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      {
        if (_M_buf_locale != __loc)
          _M_buf_locale = __loc;
      }
# 712 "/usr/include/c++/3.3/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 723 "/usr/include/c++/3.3/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
              ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 735 "/usr/include/c++/3.3/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
              ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 748 "/usr/include/c++/3.3/streambuf" 3
      virtual int
      sync() { return 0; }
# 770 "/usr/include/c++/3.3/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 786 "/usr/include/c++/3.3/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 808 "/usr/include/c++/3.3/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 821 "/usr/include/c++/3.3/streambuf" 3
      virtual int_type
      uflow()
      {
        int_type __ret = traits_type::eof();
        bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
        bool __testpending = _M_in_cur && _M_in_cur < _M_in_end;
        if (!__testeof && __testpending)
          {
            __ret = traits_type::to_int_type(*_M_in_cur);
            ++_M_in_cur;
            if (_M_buf_unified && _M_mode & ios_base::out)
              ++_M_out_cur;
          }
        return __ret;
      }
# 847 "/usr/include/c++/3.3/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 865 "/usr/include/c++/3.3/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 890 "/usr/include/c++/3.3/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 921 "/usr/include/c++/3.3/streambuf" 3
    private:
      basic_streambuf(const __streambuf_type&) { };

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };

    };
}





# 1 "/usr/include/c++/3.3/bits/streambuf.tcc" 1 3
# 38 "/usr/include/c++/3.3/bits/streambuf.tcc" 3
       
# 39 "/usr/include/c++/3.3/bits/streambuf.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    const size_t
    basic_streambuf<_CharT, _Traits>::_S_pback_size;

  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sbumpc()
    {
      int_type __ret;
      if (_M_in_cur && _M_in_cur < _M_in_end)
        {
          char_type __c = *(this->gptr());
          _M_in_cur_move(1);
          __ret = traits_type::to_int_type(__c);
        }
      else
        __ret = this->uflow();
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sputbackc(char_type __c)
    {
      int_type __ret;
      bool __testpos = _M_in_cur && _M_in_beg < _M_in_cur;
      if (!__testpos || !traits_type::eq(__c, this->gptr()[-1]))
        __ret = this->pbackfail(traits_type::to_int_type(__c));
      else
        {
          _M_in_cur_move(-1);
          __ret = traits_type::to_int_type(*this->gptr());
        }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sungetc()
    {
      int_type __ret;
      if (_M_in_cur && _M_in_beg < _M_in_cur)
        {
          _M_in_cur_move(-1);
          __ret = traits_type::to_int_type(*_M_in_cur);
        }
      else
        __ret = this->pbackfail();
      return __ret;
    }






  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sputc(char_type __c)
    {
      int_type __ret;
      if (_M_out_buf_size())
        {
          *_M_out_cur = __c;
          _M_out_cur_move(1);
          __ret = traits_type::to_int_type(__c);
        }
      else
        __ret = this->overflow(traits_type::to_int_type(__c));
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
        {
          size_t __buf_len = _M_in_end - _M_in_cur;
          if (__buf_len > 0)
            {
              size_t __remaining = __n - __ret;
              size_t __len = min(__buf_len, __remaining);
              traits_type::copy(__s, _M_in_cur, __len);
              __ret += __len;
              __s += __len;
              _M_in_cur_move(__len);
            }

          if (__ret < __n)
            {
              int_type __c = this->uflow();
              if (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                  traits_type::assign(*__s++, traits_type::to_char_type(__c));
                  ++__ret;
                }
              else
                break;
            }
        }
      return __ret;
    }






  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
        {
          off_type __buf_len = _M_out_buf_size();
          if (__buf_len > 0)
            {
              off_type __remaining = __n - __ret;
              off_type __len = min(__buf_len, __remaining);
              traits_type::copy(_M_out_cur, __s, __len);
              __ret += __len;
              __s += __len;
              _M_out_cur_move(__len);
            }

          if (__ret < __n)
            {
              int_type __c = this->overflow(traits_type::to_int_type(*__s));
              if (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                  ++__ret;
                  ++__s;
                }
              else
                break;
            }
        }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_ios<_CharT, _Traits>& __ios,
                      basic_streambuf<_CharT, _Traits>* __sbin,
                      basic_streambuf<_CharT, _Traits>* __sbout)
  {
    streamsize __ret = 0;
    if (true)
      {
        typename _Traits::int_type __c = __sbin->sgetc();
        while (!_Traits::eq_int_type(__c, _Traits::eof()))
          {
            const size_t __n = __sbin->_M_in_end - __sbin->_M_in_cur;
            if (__n > 1)
              {
                const size_t __wrote = __sbout->sputn(__sbin->_M_in_cur,
                                                      __n);
                __sbin->_M_in_cur_move(__wrote);
                __ret += __wrote;
                if (__wrote < __n)
                  break;
                __c = __sbin->underflow();
              }
            else
              {
                __c = __sbout->sputc(_Traits::to_char_type(__c));
                if (_Traits::eq_int_type(__c, _Traits::eof()))
                  break;
                ++__ret;
                __c = __sbin->snextc();
              }
          }
      }
    if (false)
      {
        __ios.setstate(ios_base::failbit);
        if ((__ios.exceptions() & ios_base::failbit) != 0)
          ;
      }
    return __ret;
  }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_ios<char>&, basic_streambuf<char>*,
                      basic_streambuf<char>*);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_ios<wchar_t>&, basic_streambuf<wchar_t>*,
                      basic_streambuf<wchar_t>*);


}
# 935 "/usr/include/c++/3.3/streambuf" 2 3
# 51 "/usr/include/c++/3.3/ios" 2 3
# 1 "/usr/include/c++/3.3/bits/basic_ios.h" 1 3
# 39 "/usr/include/c++/3.3/bits/basic_ios.h" 3
       
# 40 "/usr/include/c++/3.3/bits/basic_ios.h" 3

# 1 "/usr/include/c++/3.3/bits/streambuf_iterator.h" 1 3
# 39 "/usr/include/c++/3.3/bits/streambuf_iterator.h" 3
       
# 40 "/usr/include/c++/3.3/bits/streambuf_iterator.h" 3





namespace std
{

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*, _CharT&>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:
      istreambuf_iterator()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }

      istreambuf_iterator(istream_type& __s)
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }

      istreambuf_iterator(streambuf_type* __s)
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }


      char_type
      operator*() const
      { return traits_type::to_char_type(_M_get()); }

      istreambuf_iterator&
      operator++()
      {
        const int_type __eof = traits_type::eof();
        if (_M_sbuf && traits_type::eq_int_type(_M_sbuf->sbumpc(), __eof))
          _M_sbuf = 0;
        else
          _M_c = __eof;
        return *this;
      }

      istreambuf_iterator
      operator++(int)
      {
        const int_type __eof = traits_type::eof();
        istreambuf_iterator __old = *this;
        if (_M_sbuf
            && traits_type::eq_int_type((__old._M_c = _M_sbuf->sbumpc()),
                                        __eof))
          _M_sbuf = 0;
        else
          _M_c = __eof;
        return __old;
      }




      bool
      equal(const istreambuf_iterator& __b) const
      {
        const int_type __eof = traits_type::eof();
        bool __thiseof = traits_type::eq_int_type(_M_get(), __eof);
        bool __beof = traits_type::eq_int_type(__b._M_get(), __eof);
        return (__thiseof && __beof || (!__thiseof && !__beof));
      }


    private:
      int_type
      _M_get() const
      {
        const int_type __eof = traits_type::eof();
        int_type __ret = __eof;
        if (_M_sbuf)
          {
            if (!traits_type::eq_int_type(_M_c, __eof))
              __ret = _M_c;
            else
              if (traits_type::eq_int_type((__ret = _M_sbuf->sgetc()), __eof))
                _M_sbuf = 0;
          }
        return __ret;
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
               const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
               const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:
      ostreambuf_iterator(ostream_type& __s)
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }

      ostreambuf_iterator(streambuf_type* __s)
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }

      ostreambuf_iterator&
      operator=(_CharT __c)
      {
        if (!_M_failed &&
            _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
          _M_failed = true;
        return *this;
      }

      ostreambuf_iterator&
      operator*()
      { return *this; }

      ostreambuf_iterator&
      operator++(int)
      { return *this; }

      ostreambuf_iterator&
      operator++()
      { return *this; }

      bool
      failed() const
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
        if (__builtin_expect(!_M_failed, true) &&
            __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
          _M_failed = true;
        return *this;
      }
    };
}
# 42 "/usr/include/c++/3.3/bits/basic_ios.h" 2 3


# 1 "/usr/include/c++/3.3/bits/locale_facets.h" 1 3
# 43 "/usr/include/c++/3.3/bits/locale_facets.h" 3
       
# 44 "/usr/include/c++/3.3/bits/locale_facets.h" 3


# 1 "/usr/include/c++/3.3/cwctype" 1 3
# 47 "/usr/include/c++/3.3/cwctype" 3
       
# 48 "/usr/include/c++/3.3/cwctype" 3




# 1 "/usr/include/wctype.h" 1 3 4
# 35 "/usr/include/wctype.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 36 "/usr/include/wctype.h" 2 3 4
# 45 "/usr/include/wctype.h" 3 4



# 64 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 86 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};












extern int iswalnum (wint_t __wc) ;





extern int iswalpha (wint_t __wc) ;


extern int iswcntrl (wint_t __wc) ;



extern int iswdigit (wint_t __wc) ;



extern int iswgraph (wint_t __wc) ;




extern int iswlower (wint_t __wc) ;


extern int iswprint (wint_t __wc) ;




extern int iswpunct (wint_t __wc) ;




extern int iswspace (wint_t __wc) ;




extern int iswupper (wint_t __wc) ;




extern int iswxdigit (wint_t __wc) ;





extern int iswblank (wint_t __wc) ;
# 186 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) ;



extern int iswctype (wint_t __wc, wctype_t __desc) ;










typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) ;


extern wint_t towupper (wint_t __wc) ;



# 228 "/usr/include/wctype.h" 3 4





extern wctrans_t wctrans (const char *__property) ;


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) ;








extern int iswalnum_l (wint_t __wc, __locale_t __locale) ;





extern int iswalpha_l (wint_t __wc, __locale_t __locale) ;


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) ;



extern int iswdigit_l (wint_t __wc, __locale_t __locale) ;



extern int iswgraph_l (wint_t __wc, __locale_t __locale) ;




extern int iswlower_l (wint_t __wc, __locale_t __locale) ;


extern int iswprint_l (wint_t __wc, __locale_t __locale) ;




extern int iswpunct_l (wint_t __wc, __locale_t __locale) ;




extern int iswspace_l (wint_t __wc, __locale_t __locale) ;




extern int iswupper_l (wint_t __wc, __locale_t __locale) ;




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) ;




extern int iswblank_l (wint_t __wc, __locale_t __locale) ;



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     ;



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     ;







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) ;


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) ;



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     ;


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
                           __locale_t __locale) ;




# 53 "/usr/include/c++/3.3/cwctype" 2 3
# 77 "/usr/include/c++/3.3/cwctype" 3
namespace std
{
  using ::wint_t;

  using ::wctype_t;
  using ::wctrans_t;

  using ::iswalnum;
  using ::iswalpha;
  using ::iswblank;
  using ::iswcntrl;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::iswctype;
  using ::towlower;
  using ::towupper;
  using ::towctrans;
  using ::wctrans;
  using ::wctype;
}
# 47 "/usr/include/c++/3.3/bits/locale_facets.h" 2 3




namespace std
{
# 63 "/usr/include/c++/3.3/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
                   const __c_locale& __cloc, int __base = 10);


  template<>
    void
    __convert_to_v(const char*, long&, ios_base::iostate&,
                   const __c_locale&, int);

  template<>
    void
    __convert_to_v(const char*, unsigned long&, ios_base::iostate&,
                   const __c_locale&, int);


  template<>
    void
    __convert_to_v(const char*, long long&, ios_base::iostate&,
                   const __c_locale&, int);

  template<>
    void
    __convert_to_v(const char*, unsigned long long&, ios_base::iostate&,
                   const __c_locale&, int);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
                   const __c_locale&, int);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
                   const __c_locale&, int);

 template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
                   const __c_locale&, int);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
             const _CharT* __olds, const streamsize __newlen,
             const streamsize __oldlen, const bool __num);
    };
# 125 "/usr/include/c++/3.3/bits/locale_facets.h" 3
  template<typename _CharT>
    bool
    __verify_grouping(const basic_string<_CharT>& __grouping,
                      basic_string<_CharT>& __grouping_tmp);






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
                   const char* __gbeg, const char* __gend,
                   const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
        *__s = __ws[__j];
      return __s;
    }



# 1 "/usr/include/c++/3.3/i486-linux/bits/ctype_base.h" 1 3
# 36 "/usr/include/c++/3.3/i486-linux/bits/ctype_base.h" 3
  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISgraph;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalnum;
  };
# 167 "/usr/include/c++/3.3/bits/locale_facets.h" 2 3


  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:

      typedef _CharT char_type;

      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }

      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }

      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }

      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }

      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }

      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }

      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }

      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }

      char_type
      widen(char __c) const
      { return this->do_widen(__c); }

      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }

      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }

      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
              char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): locale::facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }

      virtual bool
      do_is(mask __m, char_type __c) const = 0;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
            mask* __vec) const = 0;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
                 const char_type* __hi) const = 0;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const = 0;

      virtual char_type
      do_toupper(char_type) const = 0;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;

      virtual char_type
      do_tolower(char_type) const = 0;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;

      virtual char_type
      do_widen(char) const = 0;

      virtual const char*
      do_widen(const char* __lo, const char* __hi,
               char_type* __dest) const = 0;

      virtual char
      do_narrow(char_type, char __dfault) const = 0;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                 char __dfault, char* __dest) const = 0;
    };


  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename ctype::mask mask;

      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;


  template<>
    class ctype<char> : public __ctype_abstract_base<char>
    {
    public:

      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;

    public:
      static locale::id id;
      static const size_t table_size = 1 + static_cast<unsigned char>(-1);

      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);

      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
            size_t __refs = 0);

      inline bool
      is(mask __m, char __c) const;

      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;

      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;

      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;

    protected:
      const mask*
      table() const
      { return _M_table; }

      static const mask*
      classic_table() ;

      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                char __dfault, char* __dest) const;
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);



  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:

      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;

    public:

      static locale::id id;

      explicit
      ctype(size_t __refs = 0);

      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;

      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                char __dfault, char* __dest) const;

    };

  template<>
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale& __loc);



# 1 "/usr/include/c++/3.3/i486-linux/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/3.3/i486-linux/bits/ctype_inline.h" 3
  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
           && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
           && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }
# 504 "/usr/include/c++/3.3/bits/locale_facets.h" 2 3


  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);

  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);


# 1 "/usr/include/c++/3.3/bits/codecvt.h" 1 3
# 44 "/usr/include/c++/3.3/bits/codecvt.h" 3
       
# 45 "/usr/include/c++/3.3/bits/codecvt.h" 3


  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;


      result
      out(state_type& __state, const intern_type* __from,
          const intern_type* __from_end, const intern_type*& __from_next,
          extern_type* __to, extern_type* __to_end,
          extern_type*& __to_next) const
      {
        return this->do_out(__state, __from, __from_end, __from_next,
                            __to, __to_end, __to_next);
      }

      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
              extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }

      result
      in(state_type& __state, const extern_type* __from,
         const extern_type* __from_end, const extern_type*& __from_next,
         intern_type* __to, intern_type* __to_end,
         intern_type*& __to_next) const
      {
        return this->do_in(__state, __from, __from_end, __from_next,
                           __to, __to_end, __to_next);
      }

      int
      encoding() const
      { return this->do_encoding(); }

      bool
      always_noconv() const
      { return this->do_always_noconv(); }

      int
      length(const state_type& __state, const extern_type* __from,
             const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const = 0;

      virtual bool
      do_always_noconv() const = 0;

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const;

      virtual int
      do_encoding() const ;

      virtual bool
      do_always_noconv() const ;

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const ;
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const;

      virtual int
      do_encoding() const ;

      virtual bool
      do_always_noconv() const ;

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const ;
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
                 extern_type* __to, extern_type* __to_end,
                 extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
             const extern_type* __from, const extern_type* __from_end,
             const extern_type*& __from_next,
             intern_type* __to, intern_type* __to_end,
             intern_type*& __to_next) const;

      virtual
      int do_encoding() const ;

      virtual
      bool do_always_noconv() const ;

      virtual
      int do_length(const state_type&, const extern_type* __from,
                    const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const ;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };




# 1 "/usr/include/c++/3.3/i486-linux/bits/codecvt_specializations.h" 1 3
# 46 "/usr/include/c++/3.3/i486-linux/bits/codecvt_specializations.h" 3
  class __enc_traits
  {
  public:



    typedef iconv_t __desc_type;

  protected:


    static const int _S_max_size = 32;

    char _M_int_enc[_S_max_size];

    char _M_ext_enc[_S_max_size];


    __desc_type _M_in_desc;

    __desc_type _M_out_desc;


    int _M_ext_bom;


    int _M_int_bom;

  public:
    explicit __enc_traits()
    : _M_in_desc(0), _M_out_desc(0), _M_ext_bom(0), _M_int_bom(0)
    {
      memset(_M_int_enc, 0, _S_max_size);
      memset(_M_ext_enc, 0, _S_max_size);
    }

    explicit __enc_traits(const char* __int, const char* __ext,
                          int __ibom = 0, int __ebom = 0)
    : _M_in_desc(0), _M_out_desc(0), _M_ext_bom(0), _M_int_bom(0)
    {
      strncpy(_M_int_enc, __int, _S_max_size);
      strncpy(_M_ext_enc, __ext, _S_max_size);
    }






    __enc_traits(const __enc_traits& __obj): _M_in_desc(0), _M_out_desc(0)
    {
      strncpy(_M_int_enc, __obj._M_int_enc, _S_max_size);
      strncpy(_M_ext_enc, __obj._M_ext_enc, _S_max_size);
      _M_ext_bom = __obj._M_ext_bom;
      _M_int_bom = __obj._M_int_bom;
    }


    __enc_traits&
    operator=(const __enc_traits& __obj)
    {
      strncpy(_M_int_enc, __obj._M_int_enc, _S_max_size);
      strncpy(_M_ext_enc, __obj._M_ext_enc, _S_max_size);
      _M_in_desc = 0;
      _M_out_desc = 0;
      _M_ext_bom = __obj._M_ext_bom;
      _M_int_bom = __obj._M_int_bom;
      return *this;
    }

    ~__enc_traits()
    {
      __desc_type __err = reinterpret_cast<iconv_t>(-1);
      if (_M_in_desc && _M_in_desc != __err)
        iconv_close(_M_in_desc);
      if (_M_out_desc && _M_out_desc != __err)
        iconv_close(_M_out_desc);
    }

    void
    _M_init()
    {
      const __desc_type __err = reinterpret_cast<iconv_t>(-1);
      if (!_M_in_desc)
        {
          _M_in_desc = iconv_open(_M_int_enc, _M_ext_enc);
          if (_M_in_desc == __err)
            __throw_runtime_error("creating iconv input descriptor failed.");
        }
      if (!_M_out_desc)
        {
          _M_out_desc = iconv_open(_M_ext_enc, _M_int_enc);
          if (_M_out_desc == __err)
            __throw_runtime_error("creating iconv output descriptor failed.");
        }
    }

    bool
    _M_good()
    {
      const __desc_type __err = reinterpret_cast<iconv_t>(-1);
      bool __test = _M_in_desc && _M_in_desc != __err;
      __test &= _M_out_desc && _M_out_desc != __err;
      return __test;
    }

    const __desc_type*
    _M_get_in_descriptor()
    { return &_M_in_desc; }

    const __desc_type*
    _M_get_out_descriptor()
    { return &_M_out_desc; }

    int
    _M_get_external_bom()
    { return _M_ext_bom; }

    int
    _M_get_internal_bom()
    { return _M_int_bom; }

    const char*
    _M_get_internal_enc()
    { return _M_int_enc; }

    const char*
    _M_get_external_enc()
    { return _M_ext_enc; }
  };




  template<typename _InternT, typename _ExternT>
    class codecvt<_InternT, _ExternT, __enc_traits>
    : public __codecvt_abstract_base<_InternT, _ExternT, __enc_traits>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef __enc_traits state_type;
      typedef __enc_traits::__desc_type __desc_type;
      typedef __enc_traits __enc_type;


      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<intern_type, extern_type, state_type>(__refs)
      { }

      explicit
      codecvt(__enc_type* __enc, size_t __refs = 0)
      : __codecvt_abstract_base<intern_type, extern_type, state_type>(__refs)
      { }

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const;

      virtual int
      do_encoding() const ;

      virtual bool
      do_always_noconv() const ;

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const ;
    };

  template<typename _InternT, typename _ExternT>
    locale::id
    codecvt<_InternT, _ExternT, __enc_traits>::id;





  template<typename _T>
    inline size_t
    __iconv_adaptor(size_t(*__func)(iconv_t, _T, size_t*, char**, size_t*),
                    iconv_t __cd, char** __inbuf, size_t* __inbytes,
                    char** __outbuf, size_t* __outbytes)
    { return __func(__cd, (_T)__inbuf, __inbytes, __outbuf, __outbytes); }

  template<typename _InternT, typename _ExternT>
    codecvt_base::result
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_out(state_type& __state, const intern_type* __from,
           const intern_type* __from_end, const intern_type*& __from_next,
           extern_type* __to, extern_type* __to_end,
           extern_type*& __to_next) const
    {
      result __ret = codecvt_base::error;
      if (__state._M_good())
        {
          typedef state_type::__desc_type __desc_type;
          const __desc_type* __desc = __state._M_get_out_descriptor();
          const size_t __fmultiple = sizeof(intern_type);
          size_t __fbytes = __fmultiple * (__from_end - __from);
          const size_t __tmultiple = sizeof(extern_type);
          size_t __tbytes = __tmultiple * (__to_end - __to);



          char* __cto = reinterpret_cast<char*>(__to);
          char* __cfrom;
          size_t __conv;






          int __int_bom = __state._M_get_internal_bom();
          if (__int_bom)
            {
              size_t __size = __from_end - __from;
              intern_type* __cfixed = static_cast<intern_type*>(__builtin_alloca(sizeof(intern_type) * (__size + 1)));
              __cfixed[0] = static_cast<intern_type>(__int_bom);
              char_traits<intern_type>::copy(__cfixed + 1, __from, __size);
              __cfrom = reinterpret_cast<char*>(__cfixed);
              __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,
                                        &__fbytes, &__cto, &__tbytes);
            }
          else
            {
              intern_type* __cfixed = const_cast<intern_type*>(__from);
              __cfrom = reinterpret_cast<char*>(__cfixed);
              __conv = __iconv_adaptor(iconv, *__desc, &__cfrom, &__fbytes,
                                       &__cto, &__tbytes);
            }

          if (__conv != size_t(-1))
            {
              __from_next = reinterpret_cast<const intern_type*>(__cfrom);
              __to_next = reinterpret_cast<extern_type*>(__cto);
              __ret = codecvt_base::ok;
            }
          else
            {
              if (__fbytes < __fmultiple * (__from_end - __from))
                {
                  __from_next = reinterpret_cast<const intern_type*>(__cfrom);
                  __to_next = reinterpret_cast<extern_type*>(__cto);
                  __ret = codecvt_base::partial;
                }
              else
                __ret = codecvt_base::error;
            }
        }
      return __ret;
    }

  template<typename _InternT, typename _ExternT>
    codecvt_base::result
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_unshift(state_type& __state, extern_type* __to,
               extern_type* __to_end, extern_type*& __to_next) const
    {
      result __ret = codecvt_base::error;
      if (__state._M_good())
        {
          typedef state_type::__desc_type __desc_type;
          const __desc_type* __desc = __state._M_get_in_descriptor();
          const size_t __tmultiple = sizeof(intern_type);
          size_t __tlen = __tmultiple * (__to_end - __to);



          char* __cto = reinterpret_cast<char*>(__to);
          size_t __conv = __iconv_adaptor(iconv,*__desc, ((void *)0), ((void *)0),
                                          &__cto, &__tlen);

          if (__conv != size_t(-1))
            {
              __to_next = reinterpret_cast<extern_type*>(__cto);
              if (__tlen == __tmultiple * (__to_end - __to))
                __ret = codecvt_base::noconv;
              else if (__tlen == 0)
                __ret = codecvt_base::ok;
              else
                __ret = codecvt_base::partial;
            }
          else
            __ret = codecvt_base::error;
        }
      return __ret;
    }

  template<typename _InternT, typename _ExternT>
    codecvt_base::result
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_in(state_type& __state, const extern_type* __from,
          const extern_type* __from_end, const extern_type*& __from_next,
          intern_type* __to, intern_type* __to_end,
          intern_type*& __to_next) const
    {
      result __ret = codecvt_base::error;
      if (__state._M_good())
        {
          typedef state_type::__desc_type __desc_type;
          const __desc_type* __desc = __state._M_get_in_descriptor();
          const size_t __fmultiple = sizeof(extern_type);
          size_t __flen = __fmultiple * (__from_end - __from);
          const size_t __tmultiple = sizeof(intern_type);
          size_t __tlen = __tmultiple * (__to_end - __to);



          char* __cto = reinterpret_cast<char*>(__to);
          char* __cfrom;
          size_t __conv;






          int __ext_bom = __state._M_get_external_bom();
          if (__ext_bom)
            {
              size_t __size = __from_end - __from;
              extern_type* __cfixed = static_cast<extern_type*>(__builtin_alloca(sizeof(extern_type) * (__size + 1)));
              __cfixed[0] = static_cast<extern_type>(__ext_bom);
              char_traits<extern_type>::copy(__cfixed + 1, __from, __size);
              __cfrom = reinterpret_cast<char*>(__cfixed);
              __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,
                                       &__flen, &__cto, &__tlen);
            }
          else
            {
              extern_type* __cfixed = const_cast<extern_type*>(__from);
              __cfrom = reinterpret_cast<char*>(__cfixed);
              __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,
                                       &__flen, &__cto, &__tlen);
            }


          if (__conv != size_t(-1))
            {
              __from_next = reinterpret_cast<const extern_type*>(__cfrom);
              __to_next = reinterpret_cast<intern_type*>(__cto);
              __ret = codecvt_base::ok;
            }
          else
            {
              if (__flen < static_cast<size_t>(__from_end - __from))
                {
                  __from_next = reinterpret_cast<const extern_type*>(__cfrom);
                  __to_next = reinterpret_cast<intern_type*>(__cto);
                  __ret = codecvt_base::partial;
                }
              else
                __ret = codecvt_base::error;
            }
        }
      return __ret;
    }

  template<typename _InternT, typename _ExternT>
    int
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_encoding() const
    {
      int __ret = 0;
      if (sizeof(_ExternT) <= sizeof(_InternT))
        __ret = sizeof(_InternT)/sizeof(_ExternT);
      return __ret;
    }

  template<typename _InternT, typename _ExternT>
    bool
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_always_noconv() const
    { return false; }

  template<typename _InternT, typename _ExternT>
    int
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_length(const state_type&, const extern_type* __from,
              const extern_type* __end, size_t __max) const
    { return min(__max, static_cast<size_t>(__end - __from)); }



  template<typename _InternT, typename _ExternT>
    int
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_max_length() const
    { return 1; }
# 335 "/usr/include/c++/3.3/bits/codecvt.h" 2 3
# 529 "/usr/include/c++/3.3/bits/locale_facets.h" 2 3


  class __num_base
  {
  public:


    enum
      {
        _S_minus,
        _S_plus,
        _S_x,
        _S_X,
        _S_digits,
        _S_digits_end = _S_digits + 16,
        _S_udigits = _S_digits_end,
        _S_udigits_end = _S_udigits + 16,
        _S_e = _S_digits + 14,
        _S_E = _S_udigits + 14,
        _S_end = _S_udigits_end
      };






    static const char* _S_atoms_out;

  protected:


    static const char* _S_atoms_in;

    enum
    {
      _M_zero,
      _M_e = _M_zero + 10,
      _M_E = _M_zero + 11,
      _M_size = 21 + 1
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod,
                    streamsize __prec);


    static void
    _S_format_int(const ios_base& __io, char* __fptr, char __mod, char __modl);
  };


  template<typename _CharT>
    class __locale_cache;

  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      friend class __locale_cache<numpunct<_CharT> >;

      static locale::id id;

    private:
      char_type _M_decimal_point;
      char_type _M_thousands_sep;
      const char* _M_grouping;
      const char_type* _M_truename;
      const char_type* _M_falsename;

    public:
      explicit
      numpunct(size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_numpunct(); }

      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_numpunct(__cloc); }

      char_type
      decimal_point() const
      { return this->do_decimal_point(); }

      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }

      string
      grouping() const
      { return this->do_grouping(); }

      string_type
      truename() const
      { return this->do_truename(); }

      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:
      virtual
      ~numpunct();

      virtual char_type
      do_decimal_point() const
      { return _M_decimal_point; }

      virtual char_type
      do_thousands_sep() const
      { return _M_thousands_sep; }

      virtual string
      do_grouping() const
      { return _M_grouping; }

      virtual string_type
      do_truename() const
      { return _M_truename; }

      virtual string_type
      do_falsename() const
      { return _M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = ((void *)0));
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);


  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {

      __c_locale _M_c_locale_numpunct;

    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
        _S_create_c_locale(_M_c_locale_numpunct, __s);
        _M_initialize_numpunct(_M_c_locale_numpunct);
      }

    protected:
      virtual
      ~numpunct_byname()
      { _S_destroy_c_locale(_M_c_locale_numpunct); }
    };

  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet, public __num_base
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      static locale::id id;

      explicit
      num_get(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:
      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
                       string& __xtrc) const;

      iter_type
      _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
                     string& __xtrc, int& __base) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
              unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             long double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             void*&) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 853 "/usr/include/c++/3.3/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet, public __num_base
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static locale::id id;

      explicit
      num_put(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_convert_float(iter_type, ios_base& __io, char_type __fill,
                         char __mod, _ValueT __v) const;

      void
      _M_group_float(const string& __grouping, char_type __sep,
                     const char_type* __p, char_type* __new, char_type* __cs,
                     int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_convert_int(iter_type, ios_base& __io, char_type __fill,
                       _ValueT __v) const;

      void
      _M_group_int(const string& __grouping, char_type __sep,
                   ios_base& __io, char_type* __new, char_type* __cs,
                   int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
             char_type* __new, const char_type* __cs, int& __len) const;



      template<typename _ValueT>
        iter_type
        _M_convert_int(iter_type, ios_base& __io, char_type __fill,
                       char __mod, char __modl, _ValueT __v) const;

      iter_type
      _M_widen_float(iter_type, ios_base& __io, char_type __fill, char* __cs,
                     int __len) const;

      iter_type
      _M_widen_int(iter_type, ios_base& __io, char_type __fill, char* __cs,
                   int __len) const;

      iter_type
      _M_insert(iter_type, ios_base& __io, char_type __fill,
                const char_type* __ws, int __len) const;


     virtual
      ~num_put() { };

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;
    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;


  template<typename _CharT>
    class collate : public locale::facet
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

    protected:


      __c_locale _M_c_locale_collate;

    public:
      static locale::id id;

      explicit
      collate(size_t __refs = 0)
      : locale::facet(__refs)
      { _M_c_locale_collate = _S_c_locale; }

      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : locale::facet(__refs)
      { _M_c_locale_collate = _S_clone_c_locale(__cloc); }

      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
              const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }

      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }

      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:
      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }

      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
                 const _CharT* __lo2, const _CharT* __hi2) const;

      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;

      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;


  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
        _S_destroy_c_locale(_M_c_locale_collate);
        _S_create_c_locale(_M_c_locale_collate, __s);
      }

    protected:
      virtual
      ~collate_byname() { }
    };


  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;

      static locale::id id;


      static const _CharT* _S_timezones[14];

    protected:
      __c_locale _M_c_locale_timepunct;
      char* _M_name_timepunct;
      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_day_a1;
      const _CharT* _M_day_a2;
      const _CharT* _M_day_a3;
      const _CharT* _M_day_a4;
      const _CharT* _M_day_a5;
      const _CharT* _M_day_a6;
      const _CharT* _M_day_a7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_month_a01;
      const _CharT* _M_month_a02;
      const _CharT* _M_month_a03;
      const _CharT* _M_month_a04;
      const _CharT* _M_month_a05;
      const _CharT* _M_month_a06;
      const _CharT* _M_month_a07;
      const _CharT* _M_month_a08;
      const _CharT* _M_month_a09;
      const _CharT* _M_month_a10;
      const _CharT* _M_month_a11;
      const _CharT* _M_month_a12;

    public:
      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);

      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
             const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

        __date[0] = _M_date_format;
        __date[1] = _M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

        __time[0] = _M_time_format;
        __time[1] = _M_time_era_format;
      }

      void
      _M_ampm(const _CharT** __ampm) const
      {
        __ampm[0] = _M_am;
        __ampm[1] = _M_pm;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

        __dt[0] = _M_date_time_format;
        __dt[1] = _M_date_time_era_format;
      }

      void
      _M_days(const _CharT** __days) const
      {
        __days[0] = _M_day1;
        __days[1] = _M_day2;
        __days[2] = _M_day3;
        __days[3] = _M_day4;
        __days[4] = _M_day5;
        __days[5] = _M_day6;
        __days[6] = _M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
        __days[0] = _M_day_a1;
        __days[1] = _M_day_a2;
        __days[2] = _M_day_a3;
        __days[3] = _M_day_a4;
        __days[4] = _M_day_a5;
        __days[5] = _M_day_a6;
        __days[6] = _M_day_a7;
      }

      void
      _M_months(const _CharT** __months) const
      {
        __months[0] = _M_month01;
        __months[1] = _M_month02;
        __months[2] = _M_month03;
        __months[3] = _M_month04;
        __months[4] = _M_month05;
        __months[5] = _M_month06;
        __months[6] = _M_month07;
        __months[7] = _M_month08;
        __months[8] = _M_month09;
        __months[9] = _M_month10;
        __months[10] = _M_month11;
        __months[11] = _M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
        __months[0] = _M_month_a01;
        __months[1] = _M_month_a02;
        __months[2] = _M_month_a03;
        __months[3] = _M_month_a04;
        __months[4] = _M_month_a05;
        __months[5] = _M_month_a06;
        __months[6] = _M_month_a07;
        __months[7] = _M_month_a08;
        __months[8] = _M_month_a09;
        __months[9] = _M_month_a10;
        __months[10] = _M_month_a11;
        __months[11] = _M_month_a12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = ((void *)0));
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    const char*
    __timepunct<char>::_S_timezones[14];

  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;


  template<>
    const wchar_t*
    __timepunct<wchar_t>::_S_timezones[14];

  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
                                 const tm*) const;



  template<typename _CharT>
    const _CharT* __timepunct<_CharT>::_S_timezones[14];


# 1 "/usr/include/c++/3.3/i486-linux/bits/time_members.h" 1 3
# 37 "/usr/include/c++/3.3/i486-linux/bits/time_members.h" 3
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : locale::facet(__refs)
    {



      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc,
                                     const char* __s,
                                     size_t __refs)
    : locale::facet(__refs)
    {




      _M_initialize_timepunct(__cloc);
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {




      _S_destroy_c_locale(_M_c_locale_timepunct);
    }
# 1311 "/usr/include/c++/3.3/bits/locale_facets.h" 2 3

  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> __string_type;

      static locale::id id;

      explicit
      time_get(size_t __refs = 0)
      : locale::facet (__refs) { }

      dateorder
      date_order() const
      { return this->do_date_order(); }

      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
               ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }

      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
               ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }

      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }

      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }

      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
               ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:
      virtual
      ~time_get() { }

      virtual dateorder
      do_date_order() const;

      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
                     ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
                       ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const;


      void
      _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,
                     int __min, int __max, size_t __len,
                     const ctype<_CharT>& __ctype,
                     ios_base::iostate& __err) const;



      void
      _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,
                      const _CharT** __names, size_t __indexlen,
                      ios_base::iostate& __err) const;


      void
      _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,
                            ios_base::iostate& __err, tm* __tm,
                            const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;

  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };

  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet, public time_base
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      static locale::id id;

      explicit
      time_put(size_t __refs = 0)
      : locale::facet(__refs) { }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
          const _CharT* __beg, const _CharT* __end) const;

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
          const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:
      virtual
      ~time_put()
      { }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
             char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;

  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char* , size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };


  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;
      static locale::id id;

    private:
      const char* _M_grouping;
      char_type _M_decimal_point;
      char_type _M_thousands_sep;
      const char_type* _M_curr_symbol;
      const char_type* _M_positive_sign;
      const char_type* _M_negative_sign;
      int _M_frac_digits;
      pattern _M_pos_format;
      pattern _M_neg_format;

    public:
      explicit
      moneypunct(size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_moneypunct(); }

      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : locale::facet(__refs)
      { _M_initialize_moneypunct(__cloc, __s); }

      char_type
      decimal_point() const
      { return this->do_decimal_point(); }

      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }

      string
      grouping() const
      { return this->do_grouping(); }

      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }

      string_type
      positive_sign() const
      { return this->do_positive_sign(); }

      string_type
      negative_sign() const
      { return this->do_negative_sign(); }

      int
      frac_digits() const
      { return this->do_frac_digits(); }

      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }

    protected:
      virtual
      ~moneypunct();

      virtual char_type
      do_decimal_point() const
      { return _M_decimal_point; }

      virtual char_type
      do_thousands_sep() const
      { return _M_thousands_sep; }

      virtual string
      do_grouping() const
      { return _M_grouping; }

      virtual string_type
      do_curr_symbol() const
      { return _M_curr_symbol; }

      virtual string_type
      do_positive_sign() const
      { return _M_positive_sign; }

      virtual string_type
      do_negative_sign() const
      { return _M_negative_sign; }

      virtual int
      do_frac_digits() const
      { return _M_frac_digits; }

      virtual pattern
      do_pos_format() const
      { return _M_pos_format; }

      virtual pattern
      do_neg_format() const
      { return _M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = ((void *)0),
                                const char* __name = ((void *)0));
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
                                                        const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
                                                         const char*);


  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
      __c_locale _M_c_locale_moneypunct;

    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
        _S_create_c_locale(_M_c_locale_moneypunct, __s);
        _M_initialize_moneypunct(_M_c_locale_moneypunct);
      }

    protected:
      virtual
      ~moneypunct_byname()
      { _S_destroy_c_locale(_M_c_locale_moneypunct); }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;

      static locale::id id;

      explicit
      money_get(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
          ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }

      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
          ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:
      virtual
      ~money_get() { }

      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
             ios_base::iostate& __err, long double& __units) const;

      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
             ios_base::iostate& __err, string_type& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;

  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;

      static locale::id id;

      explicit
      money_put(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
          char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }

      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
          char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:
      virtual
      ~money_put() { }

      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
             long double __units) const;

      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
             const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;


  struct messages_base
  {
    typedef int catalog;
  };

  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

    protected:


      __c_locale _M_c_locale_messages;
      char* _M_name_messages;

    public:
      static locale::id id;

      explicit
      messages(size_t __refs = 0);


      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);

      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }


      catalog
      open(const basic_string<char>&, const locale&, const char*) const;

      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }

      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:
      virtual
      ~messages();

      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;

      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;

      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

        return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char* __msg) const
      {

        size_t __len = char_traits<char>::length(__msg) - 1;
# 1856 "/usr/include/c++/3.3/bits/locale_facets.h" 3
        return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;


  template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };


# 1 "/usr/include/c++/3.3/i486-linux/bits/messages_members.h" 1 3
# 37 "/usr/include/c++/3.3/i486-linux/bits/messages_members.h" 3
  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : locale::facet(__refs)
     {



       _M_c_locale_messages = _S_c_locale;
     }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale __cloc,
                                const char* __s, size_t __refs)
     : locale::facet(__refs)
     {




       _M_c_locale_messages = _S_clone_c_locale(__cloc);
     }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
                           const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }


  template<typename _CharT>
    messages<_CharT>::~messages()
    {




      _S_destroy_c_locale(_M_c_locale_messages);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
                              const locale&) const
    {


      textdomain(__s.c_str());
      return 0;
    }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {






       _S_destroy_c_locale(_M_c_locale_messages);
       _S_create_c_locale(_M_c_locale_messages, __s);
     }
# 1892 "/usr/include/c++/3.3/bits/locale_facets.h" 2 3






  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }

  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }

  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }

  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }

  template<typename _CharT>
    inline bool islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }

  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }

  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }

  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }

  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }

  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }

  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }

  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }

  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }
# 1973 "/usr/include/c++/3.3/bits/locale_facets.h" 3
  class __locale_cache_base
  {
    friend class std::locale::_Impl;
    friend class locale;

  public:
    virtual
    ~__locale_cache_base() { }

  };



  template<typename _Facet>
    class __locale_cache : public __locale_cache_base
    {

      __locale_cache(const locale&) {}
    };

  template<typename _CharT>
    class __locale_cache<numpunct<_CharT> > : public __locale_cache_base
    {

      typedef _CharT char_type;
      typedef char_traits<_CharT> traits_type;
      typedef basic_string<_CharT> string_type;

    public:





      _CharT _M_decimal_point;





      _CharT _M_thousands_sep;



      const _CharT* _M_truename;
      const _CharT* _M_falsename;



      bool _M_use_grouping;



      const char* _M_grouping;
# 2035 "/usr/include/c++/3.3/bits/locale_facets.h" 3
      _CharT _M_atoms_out[__num_base::_S_end];


      __locale_cache(const locale& __loc);
      __locale_cache(const locale& __loc, bool);

      ~__locale_cache()
      {
        delete [] _M_truename;
        delete [] _M_falsename;
        delete [] _M_grouping;
      }
    };
}
# 45 "/usr/include/c++/3.3/bits/basic_ios.h" 2 3

namespace std
{







  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
# 78 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      typedef ctype<_CharT> __ctype_type;
      typedef ostreambuf_iterator<_CharT, _Traits> __ostreambuf_iter;
      typedef num_put<_CharT, __ostreambuf_iter> __numput_type;
      typedef istreambuf_iterator<_CharT, _Traits> __istreambuf_iter;
      typedef num_get<_CharT, __istreambuf_iter> __numget_type;


      friend void ios_base::Init::_S_ios_create(bool);


    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_fctype;

      const __numput_type* _M_fnumput;

      const __numget_type* _M_fnumget;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 124 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 135 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 175 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 196 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 231 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb) : ios_base()
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 267 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 279 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 312 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);




      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
        if (!_M_fill_init)
          {
            _M_fill = this->widen(' ');
            _M_fill_init = true;
          }
        return _M_fill;
      }
# 347 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
        char_type __old = this->fill();
        _M_fill = __ch;
        return __old;
      }
# 367 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 387 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const;
# 405 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      char_type
      widen(char __c) const;

    protected:







      basic_ios() : ios_base()
      { }
# 427 "/usr/include/c++/3.3/bits/basic_ios.h" 3
      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      bool
      _M_check_facet(const locale::facet* __f) const
      {
        if (!__f)
          __throw_bad_cast();
        return true;
      }

      void
      _M_cache_locale(const locale& __loc);



      void
      _M_cache_facets(const locale& __loc);




       void
       _M_setstate(iostate __state) { _M_streambuf_state |= __state; }
    };
}



# 1 "/usr/include/c++/3.3/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/3.3/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/3.3/bits/basic_ios.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
        _M_streambuf_state = __state;
      else
          _M_streambuf_state = __state | badbit;
      if ((this->rdstate() & this->exceptions()))
        __throw_ios_failure("basic_ios::clear(iostate) caused exception");
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {




      _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
        _M_local_word : new _Words[__rhs._M_word_size];


      _Callback_list* __cb = __rhs._M_callbacks;
      if (__cb)
        __cb->_M_add_reference();
      _M_call_callbacks(erase_event);
      if (_M_word != _M_local_word)
        {
          delete [] _M_word;
          _M_word = 0;
        }
      _M_dispose_callbacks();

      _M_callbacks = __cb;
      for (int __i = 0; __i < __rhs._M_word_size; ++__i)
        __words[__i] = __rhs._M_word[__i];
      if (_M_word != _M_local_word)
        {
          delete [] _M_word;
          _M_word = 0;
        }
      _M_word = __words;
      _M_word_size = __rhs._M_word_size;

      this->flags(__rhs.flags());
      this->width(__rhs.width());
      this->precision(__rhs.precision());
      this->tie(__rhs.tie());
      this->fill(__rhs.fill());
      _M_ios_locale = __rhs.getloc();


      _M_call_callbacks(copyfmt_event);

      _M_cache_locale(_M_ios_locale);



      this->exceptions(__rhs.exceptions());

      return *this;
    }

  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    {
      char __ret = __dfault;
      if (_M_check_facet(_M_fctype))
        __ret = _M_fctype->narrow(__c, __dfault);
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    {
      char_type __ret = char_type();
      if (_M_check_facet(_M_fctype))
        __ret = _M_fctype->widen(__c);
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
        this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();
      _M_cache_locale(_M_ios_locale);
      _M_tie = 0;
# 166 "/usr/include/c++/3.3/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
        _M_fctype = &use_facet<__ctype_type>(__loc);
      else
        _M_fctype = 0;
      if (__builtin_expect(has_facet<__numput_type>(__loc), true))
        _M_fnumput = &use_facet<__numput_type>(__loc);
      else
        _M_fnumput = 0;
      if (__builtin_expect(has_facet<__numget_type>(__loc), true))
        _M_fnumget = &use_facet<__numget_type>(__loc);
      else
        _M_fnumget = 0;
    }



  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_facets(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
        _M_fctype = &use_facet<__ctype_type>(__loc);
      if (__builtin_expect(has_facet<__numput_type>(__loc), true))
        _M_fnumput = &use_facet<__numput_type>(__loc);
      if (__builtin_expect(has_facet<__numget_type>(__loc), true))
        _M_fnumget = &use_facet<__numget_type>(__loc);
    }






  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;


}
# 457 "/usr/include/c++/3.3/bits/basic_ios.h" 2 3
# 52 "/usr/include/c++/3.3/ios" 2 3
# 46 "/usr/include/c++/3.3/ostream" 2 3

namespace std
{
# 57 "/usr/include/c++/3.3/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef ostreambuf_iterator<_CharT, _Traits> __ostreambuf_iter;
      typedef num_put<_CharT, __ostreambuf_iter> __numput_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, _CharT2);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, char);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const _CharT2*);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, const char*);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const char*);
# 104 "/usr/include/c++/3.3/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 130 "/usr/include/c++/3.3/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&));

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&));

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&));
# 167 "/usr/include/c++/3.3/ostream" 3
      __ostream_type&
      operator<<(long __n);

      __ostream_type&
      operator<<(unsigned long __n);

      __ostream_type&
      operator<<(bool __n);

      __ostream_type&
      operator<<(short __n)
      {
        ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt & ios_base::oct || __fmt & ios_base::hex)
          return this->operator<<(static_cast<unsigned long>
                                  (static_cast<unsigned short>(__n)));
        else
          return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned short __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }

      __ostream_type&
      operator<<(int __n)
      {
        ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt & ios_base::oct || __fmt & ios_base::hex)
          return this->operator<<(static_cast<unsigned long>
                                  (static_cast<unsigned int>(__n)));
        else
          return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned int __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }


      __ostream_type&
      operator<<(long long __n);

      __ostream_type&
      operator<<(unsigned long long __n);


      __ostream_type&
      operator<<(double __f);

      __ostream_type&
      operator<<(float __f)
      { return this->operator<<(static_cast<double>(__f)); }

      __ostream_type&
      operator<<(long double __f);

      __ostream_type&
      operator<<(const void* __p);
# 248 "/usr/include/c++/3.3/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 281 "/usr/include/c++/3.3/ostream" 3
      __ostream_type&
      put(char_type __c);
# 300 "/usr/include/c++/3.3/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 313 "/usr/include/c++/3.3/ostream" 3
      __ostream_type&
      flush();
# 324 "/usr/include/c++/3.3/ostream" 3
      pos_type
      tellp();
# 335 "/usr/include/c++/3.3/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 347 "/usr/include/c++/3.3/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);
    };
# 361 "/usr/include/c++/3.3/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT,_Traits>& _M_os;

    public:
# 380 "/usr/include/c++/3.3/ostream" 3
      explicit
      sentry(basic_ostream<_CharT,_Traits>& __os);
# 390 "/usr/include/c++/3.3/ostream" 3
      ~sentry()
      {

        if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
          {

            if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
              _M_os.setstate(ios_base::badbit);
          }
      }
# 408 "/usr/include/c++/3.3/ostream" 3
      operator bool()
      { return _M_ok; }
    };
# 429 "/usr/include/c++/3.3/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 469 "/usr/include/c++/3.3/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 503 "/usr/include/c++/3.3/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}





# 1 "/usr/include/c++/3.3/bits/ostream.tcc" 1 3
# 35 "/usr/include/c++/3.3/bits/ostream.tcc" 3
       
# 36 "/usr/include/c++/3.3/bits/ostream.tcc" 3

# 1 "/usr/include/c++/3.3/locale" 1 3
# 42 "/usr/include/c++/3.3/locale" 3
       
# 43 "/usr/include/c++/3.3/locale" 3




# 1 "/usr/include/c++/3.3/bits/locale_facets.tcc" 1 3
# 36 "/usr/include/c++/3.3/bits/locale_facets.tcc" 3
       
# 37 "/usr/include/c++/3.3/bits/locale_facets.tcc" 3

# 1 "/usr/include/c++/3.3/cerrno" 1 3
# 46 "/usr/include/c++/3.3/cerrno" 3
       
# 47 "/usr/include/c++/3.3/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 32 "/usr/include/errno.h" 3 4




# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/asm/errno.h" 1 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4
# 38 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) ;
# 37 "/usr/include/errno.h" 2 3 4
# 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;




# 69 "/usr/include/errno.h" 3 4
typedef int error_t;
# 49 "/usr/include/c++/3.3/cerrno" 2 3
# 39 "/usr/include/c++/3.3/bits/locale_facets.tcc" 2 3


# 1 "/usr/include/c++/3.3/cmath" 1 3
# 47 "/usr/include/c++/3.3/cmath" 3
       
# 48 "/usr/include/c++/3.3/cmath" 3



# 1 "/usr/include/math.h" 1 3 4
# 29 "/usr/include/math.h" 3 4




# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 39 "/usr/include/bits/huge_val.h" 3 4
static union { unsigned char __c[8]; double __d; } __huge_val = { { 0, 0, 0, 0, 0, 0, 0xf0, 0x7f } };
# 63 "/usr/include/bits/huge_val.h" 3 4
static union { unsigned char __c[4]; float __f; } __huge_valf = { { 0, 0, 0x80, 0x7f } };
# 75 "/usr/include/bits/huge_val.h" 3 4
static union { unsigned char __c[12]; long double __ld; } __huge_vall = { { 0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0 } };
# 34 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/nan.h" 1 3 4
# 45 "/usr/include/bits/nan.h" 3 4
static union { unsigned char __c[4]; float __d; } __nan_union = { { 0, 0, 0xc0, 0x7f } };
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 29 "/usr/include/bits/mathdef.h" 3 4
typedef long double float_t;

typedef long double double_t;
# 41 "/usr/include/math.h" 2 3 4
# 65 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) ; extern double __acos (double __x) ;

extern double asin (double __x) ; extern double __asin (double __x) ;

extern double atan (double __x) ; extern double __atan (double __x) ;

extern double atan2 (double __y, double __x) ; extern double __atan2 (double __y, double __x) ;


extern double cos (double __x) ; extern double __cos (double __x) ;

extern double sin (double __x) ; extern double __sin (double __x) ;

extern double tan (double __x) ; extern double __tan (double __x) ;




extern double cosh (double __x) ; extern double __cosh (double __x) ;

extern double sinh (double __x) ; extern double __sinh (double __x) ;

extern double tanh (double __x) ; extern double __tanh (double __x) ;




extern void sincos (double __x, double *__sinx, double *__cosx) ; extern void __sincos (double __x, double *__sinx, double *__cosx) ;






extern double acosh (double __x) ; extern double __acosh (double __x) ;

extern double asinh (double __x) ; extern double __asinh (double __x) ;

extern double atanh (double __x) ; extern double __atanh (double __x) ;







extern double exp (double __x) ; extern double __exp (double __x) ;


extern double frexp (double __x, int *__exponent) ; extern double __frexp (double __x, int *__exponent) ;


extern double ldexp (double __x, int __exponent) ; extern double __ldexp (double __x, int __exponent) ;


extern double log (double __x) ; extern double __log (double __x) ;


extern double log10 (double __x) ; extern double __log10 (double __x) ;


extern double modf (double __x, double *__iptr) ; extern double __modf (double __x, double *__iptr) ;




extern double exp10 (double __x) ; extern double __exp10 (double __x) ;

extern double pow10 (double __x) ; extern double __pow10 (double __x) ;





extern double expm1 (double __x) ; extern double __expm1 (double __x) ;


extern double log1p (double __x) ; extern double __log1p (double __x) ;


extern double logb (double __x) ; extern double __logb (double __x) ;






extern double exp2 (double __x) ; extern double __exp2 (double __x) ;


extern double log2 (double __x) ; extern double __log2 (double __x) ;








extern double pow (double __x, double __y) ; extern double __pow (double __x, double __y) ;


extern double sqrt (double __x) ; extern double __sqrt (double __x) ;





extern double hypot (double __x, double __y) ; extern double __hypot (double __x, double __y) ;






extern double cbrt (double __x) ; extern double __cbrt (double __x) ;








extern double ceil (double __x) ; extern double __ceil (double __x) ;


extern double fabs (double __x) ; extern double __fabs (double __x) ;


extern double floor (double __x) ; extern double __floor (double __x) ;


extern double fmod (double __x, double __y) ; extern double __fmod (double __x, double __y) ;




extern int __isinf (double __value) ;


extern int __finite (double __value) ;





extern int isinf (double __value) ;


extern int finite (double __value) ;


extern double drem (double __x, double __y) ; extern double __drem (double __x, double __y) ;



extern double significand (double __x) ; extern double __significand (double __x) ;





extern double copysign (double __x, double __y) ; extern double __copysign (double __x, double __y) ;






extern double nan (const char *__tagb) ; extern double __nan (const char *__tagb) ;





extern int __isnan (double __value) ;



extern int isnan (double __value) ;


extern double j0 (double) ; extern double __j0 (double) ;
extern double j1 (double) ; extern double __j1 (double) ;
extern double jn (int, double) ; extern double __jn (int, double) ;
extern double y0 (double) ; extern double __y0 (double) ;
extern double y1 (double) ; extern double __y1 (double) ;
extern double yn (int, double) ; extern double __yn (int, double) ;






extern double erf (double) ; extern double __erf (double) ;
extern double erfc (double) ; extern double __erfc (double) ;
extern double lgamma (double) ; extern double __lgamma (double) ;






extern double tgamma (double) ; extern double __tgamma (double) ;





extern double gamma (double) ; extern double __gamma (double) ;






extern double lgamma_r (double, int *__signgamp) ; extern double __lgamma_r (double, int *__signgamp) ;







extern double rint (double __x) ; extern double __rint (double __x) ;


extern double nextafter (double __x, double __y) ; extern double __nextafter (double __x, double __y) ;

extern double nexttoward (double __x, long double __y) ; extern double __nexttoward (double __x, long double __y) ;



extern double remainder (double __x, double __y) ; extern double __remainder (double __x, double __y) ;



extern double scalbn (double __x, int __n) ; extern double __scalbn (double __x, int __n) ;



extern int ilogb (double __x) ; extern int __ilogb (double __x) ;




extern double scalbln (double __x, long int __n) ; extern double __scalbln (double __x, long int __n) ;



extern double nearbyint (double __x) ; extern double __nearbyint (double __x) ;



extern double round (double __x) ; extern double __round (double __x) ;



extern double trunc (double __x) ; extern double __trunc (double __x) ;




extern double remquo (double __x, double __y, int *__quo) ; extern double __remquo (double __x, double __y, int *__quo) ;






extern long int lrint (double __x) ; extern long int __lrint (double __x) ;
extern long long int llrint (double __x) ; extern long long int __llrint (double __x) ;



extern long int lround (double __x) ; extern long int __lround (double __x) ;
extern long long int llround (double __x) ; extern long long int __llround (double __x) ;



extern double fdim (double __x, double __y) ; extern double __fdim (double __x, double __y) ;


extern double fmax (double __x, double __y) ; extern double __fmax (double __x, double __y) ;


extern double fmin (double __x, double __y) ; extern double __fmin (double __x, double __y) ;



extern int __fpclassify (double __value)
     ;


extern int __signbit (double __value)
     ;



extern double fma (double __x, double __y, double __z) ; extern double __fma (double __x, double __y, double __z) ;




extern double scalb (double __x, double __n) ; extern double __scalb (double __x, double __n) ;
# 66 "/usr/include/math.h" 2 3 4
# 88 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) ; extern float __acosf (float __x) ;

extern float asinf (float __x) ; extern float __asinf (float __x) ;

extern float atanf (float __x) ; extern float __atanf (float __x) ;

extern float atan2f (float __y, float __x) ; extern float __atan2f (float __y, float __x) ;


extern float cosf (float __x) ; extern float __cosf (float __x) ;

extern float sinf (float __x) ; extern float __sinf (float __x) ;

extern float tanf (float __x) ; extern float __tanf (float __x) ;




extern float coshf (float __x) ; extern float __coshf (float __x) ;

extern float sinhf (float __x) ; extern float __sinhf (float __x) ;

extern float tanhf (float __x) ; extern float __tanhf (float __x) ;




extern void sincosf (float __x, float *__sinx, float *__cosx) ; extern void __sincosf (float __x, float *__sinx, float *__cosx) ;






extern float acoshf (float __x) ; extern float __acoshf (float __x) ;

extern float asinhf (float __x) ; extern float __asinhf (float __x) ;

extern float atanhf (float __x) ; extern float __atanhf (float __x) ;







extern float expf (float __x) ; extern float __expf (float __x) ;


extern float frexpf (float __x, int *__exponent) ; extern float __frexpf (float __x, int *__exponent) ;


extern float ldexpf (float __x, int __exponent) ; extern float __ldexpf (float __x, int __exponent) ;


extern float logf (float __x) ; extern float __logf (float __x) ;


extern float log10f (float __x) ; extern float __log10f (float __x) ;


extern float modff (float __x, float *__iptr) ; extern float __modff (float __x, float *__iptr) ;




extern float exp10f (float __x) ; extern float __exp10f (float __x) ;

extern float pow10f (float __x) ; extern float __pow10f (float __x) ;





extern float expm1f (float __x) ; extern float __expm1f (float __x) ;


extern float log1pf (float __x) ; extern float __log1pf (float __x) ;


extern float logbf (float __x) ; extern float __logbf (float __x) ;






extern float exp2f (float __x) ; extern float __exp2f (float __x) ;


extern float log2f (float __x) ; extern float __log2f (float __x) ;








extern float powf (float __x, float __y) ; extern float __powf (float __x, float __y) ;


extern float sqrtf (float __x) ; extern float __sqrtf (float __x) ;





extern float hypotf (float __x, float __y) ; extern float __hypotf (float __x, float __y) ;






extern float cbrtf (float __x) ; extern float __cbrtf (float __x) ;








extern float ceilf (float __x) ; extern float __ceilf (float __x) ;


extern float fabsf (float __x) ; extern float __fabsf (float __x) ;


extern float floorf (float __x) ; extern float __floorf (float __x) ;


extern float fmodf (float __x, float __y) ; extern float __fmodf (float __x, float __y) ;




extern int __isinff (float __value) ;


extern int __finitef (float __value) ;





extern int isinff (float __value) ;


extern int finitef (float __value) ;


extern float dremf (float __x, float __y) ; extern float __dremf (float __x, float __y) ;



extern float significandf (float __x) ; extern float __significandf (float __x) ;





extern float copysignf (float __x, float __y) ; extern float __copysignf (float __x, float __y) ;






extern float nanf (const char *__tagb) ; extern float __nanf (const char *__tagb) ;





extern int __isnanf (float __value) ;



extern int isnanf (float __value) ;


extern float j0f (float) ; extern float __j0f (float) ;
extern float j1f (float) ; extern float __j1f (float) ;
extern float jnf (int, float) ; extern float __jnf (int, float) ;
extern float y0f (float) ; extern float __y0f (float) ;
extern float y1f (float) ; extern float __y1f (float) ;
extern float ynf (int, float) ; extern float __ynf (int, float) ;






extern float erff (float) ; extern float __erff (float) ;
extern float erfcf (float) ; extern float __erfcf (float) ;
extern float lgammaf (float) ; extern float __lgammaf (float) ;






extern float tgammaf (float) ; extern float __tgammaf (float) ;





extern float gammaf (float) ; extern float __gammaf (float) ;






extern float lgammaf_r (float, int *__signgamp) ; extern float __lgammaf_r (float, int *__signgamp) ;







extern float rintf (float __x) ; extern float __rintf (float __x) ;


extern float nextafterf (float __x, float __y) ; extern float __nextafterf (float __x, float __y) ;

extern float nexttowardf (float __x, long double __y) ; extern float __nexttowardf (float __x, long double __y) ;



extern float remainderf (float __x, float __y) ; extern float __remainderf (float __x, float __y) ;



extern float scalbnf (float __x, int __n) ; extern float __scalbnf (float __x, int __n) ;



extern int ilogbf (float __x) ; extern int __ilogbf (float __x) ;




extern float scalblnf (float __x, long int __n) ; extern float __scalblnf (float __x, long int __n) ;



extern float nearbyintf (float __x) ; extern float __nearbyintf (float __x) ;



extern float roundf (float __x) ; extern float __roundf (float __x) ;



extern float truncf (float __x) ; extern float __truncf (float __x) ;




extern float remquof (float __x, float __y, int *__quo) ; extern float __remquof (float __x, float __y, int *__quo) ;






extern long int lrintf (float __x) ; extern long int __lrintf (float __x) ;
extern long long int llrintf (float __x) ; extern long long int __llrintf (float __x) ;



extern long int lroundf (float __x) ; extern long int __lroundf (float __x) ;
extern long long int llroundf (float __x) ; extern long long int __llroundf (float __x) ;



extern float fdimf (float __x, float __y) ; extern float __fdimf (float __x, float __y) ;


extern float fmaxf (float __x, float __y) ; extern float __fmaxf (float __x, float __y) ;


extern float fminf (float __x, float __y) ; extern float __fminf (float __x, float __y) ;



extern int __fpclassifyf (float __value)
     ;


extern int __signbitf (float __value)
     ;



extern float fmaf (float __x, float __y, float __z) ; extern float __fmaf (float __x, float __y, float __z) ;




extern float scalbf (float __x, float __n) ; extern float __scalbf (float __x, float __n) ;
# 89 "/usr/include/math.h" 2 3 4
# 109 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) ; extern long double __acosl (long double __x) ;

extern long double asinl (long double __x) ; extern long double __asinl (long double __x) ;

extern long double atanl (long double __x) ; extern long double __atanl (long double __x) ;

extern long double atan2l (long double __y, long double __x) ; extern long double __atan2l (long double __y, long double __x) ;


extern long double cosl (long double __x) ; extern long double __cosl (long double __x) ;

extern long double sinl (long double __x) ; extern long double __sinl (long double __x) ;

extern long double tanl (long double __x) ; extern long double __tanl (long double __x) ;




extern long double coshl (long double __x) ; extern long double __coshl (long double __x) ;

extern long double sinhl (long double __x) ; extern long double __sinhl (long double __x) ;

extern long double tanhl (long double __x) ; extern long double __tanhl (long double __x) ;




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) ; extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) ;






extern long double acoshl (long double __x) ; extern long double __acoshl (long double __x) ;

extern long double asinhl (long double __x) ; extern long double __asinhl (long double __x) ;

extern long double atanhl (long double __x) ; extern long double __atanhl (long double __x) ;







extern long double expl (long double __x) ; extern long double __expl (long double __x) ;


extern long double frexpl (long double __x, int *__exponent) ; extern long double __frexpl (long double __x, int *__exponent) ;


extern long double ldexpl (long double __x, int __exponent) ; extern long double __ldexpl (long double __x, int __exponent) ;


extern long double logl (long double __x) ; extern long double __logl (long double __x) ;


extern long double log10l (long double __x) ; extern long double __log10l (long double __x) ;


extern long double modfl (long double __x, long double *__iptr) ; extern long double __modfl (long double __x, long double *__iptr) ;




extern long double exp10l (long double __x) ; extern long double __exp10l (long double __x) ;

extern long double pow10l (long double __x) ; extern long double __pow10l (long double __x) ;





extern long double expm1l (long double __x) ; extern long double __expm1l (long double __x) ;


extern long double log1pl (long double __x) ; extern long double __log1pl (long double __x) ;


extern long double logbl (long double __x) ; extern long double __logbl (long double __x) ;






extern long double exp2l (long double __x) ; extern long double __exp2l (long double __x) ;


extern long double log2l (long double __x) ; extern long double __log2l (long double __x) ;








extern long double powl (long double __x, long double __y) ; extern long double __powl (long double __x, long double __y) ;


extern long double sqrtl (long double __x) ; extern long double __sqrtl (long double __x) ;





extern long double hypotl (long double __x, long double __y) ; extern long double __hypotl (long double __x, long double __y) ;






extern long double cbrtl (long double __x) ; extern long double __cbrtl (long double __x) ;








extern long double ceill (long double __x) ; extern long double __ceill (long double __x) ;


extern long double fabsl (long double __x) ; extern long double __fabsl (long double __x) ;


extern long double floorl (long double __x) ; extern long double __floorl (long double __x) ;


extern long double fmodl (long double __x, long double __y) ; extern long double __fmodl (long double __x, long double __y) ;




extern int __isinfl (long double __value) ;


extern int __finitel (long double __value) ;





extern int isinfl (long double __value) ;


extern int finitel (long double __value) ;


extern long double dreml (long double __x, long double __y) ; extern long double __dreml (long double __x, long double __y) ;



extern long double significandl (long double __x) ; extern long double __significandl (long double __x) ;





extern long double copysignl (long double __x, long double __y) ; extern long double __copysignl (long double __x, long double __y) ;






extern long double nanl (const char *__tagb) ; extern long double __nanl (const char *__tagb) ;





extern int __isnanl (long double __value) ;



extern int isnanl (long double __value) ;


extern long double j0l (long double) ; extern long double __j0l (long double) ;
extern long double j1l (long double) ; extern long double __j1l (long double) ;
extern long double jnl (int, long double) ; extern long double __jnl (int, long double) ;
extern long double y0l (long double) ; extern long double __y0l (long double) ;
extern long double y1l (long double) ; extern long double __y1l (long double) ;
extern long double ynl (int, long double) ; extern long double __ynl (int, long double) ;






extern long double erfl (long double) ; extern long double __erfl (long double) ;
extern long double erfcl (long double) ; extern long double __erfcl (long double) ;
extern long double lgammal (long double) ; extern long double __lgammal (long double) ;






extern long double tgammal (long double) ; extern long double __tgammal (long double) ;





extern long double gammal (long double) ; extern long double __gammal (long double) ;






extern long double lgammal_r (long double, int *__signgamp) ; extern long double __lgammal_r (long double, int *__signgamp) ;







extern long double rintl (long double __x) ; extern long double __rintl (long double __x) ;


extern long double nextafterl (long double __x, long double __y) ; extern long double __nextafterl (long double __x, long double __y) ;

extern long double nexttowardl (long double __x, long double __y) ; extern long double __nexttowardl (long double __x, long double __y) ;



extern long double remainderl (long double __x, long double __y) ; extern long double __remainderl (long double __x, long double __y) ;



extern long double scalbnl (long double __x, int __n) ; extern long double __scalbnl (long double __x, int __n) ;



extern int ilogbl (long double __x) ; extern int __ilogbl (long double __x) ;




extern long double scalblnl (long double __x, long int __n) ; extern long double __scalblnl (long double __x, long int __n) ;



extern long double nearbyintl (long double __x) ; extern long double __nearbyintl (long double __x) ;



extern long double roundl (long double __x) ; extern long double __roundl (long double __x) ;



extern long double truncl (long double __x) ; extern long double __truncl (long double __x) ;




extern long double remquol (long double __x, long double __y, int *__quo) ; extern long double __remquol (long double __x, long double __y, int *__quo) ;






extern long int lrintl (long double __x) ; extern long int __lrintl (long double __x) ;
extern long long int llrintl (long double __x) ; extern long long int __llrintl (long double __x) ;



extern long int lroundl (long double __x) ; extern long int __lroundl (long double __x) ;
extern long long int llroundl (long double __x) ; extern long long int __llroundl (long double __x) ;



extern long double fdiml (long double __x, long double __y) ; extern long double __fdiml (long double __x, long double __y) ;


extern long double fmaxl (long double __x, long double __y) ; extern long double __fmaxl (long double __x, long double __y) ;


extern long double fminl (long double __x, long double __y) ; extern long double __fminl (long double __x, long double __y) ;



extern int __fpclassifyl (long double __value)
     ;


extern int __signbitl (long double __value)
     ;



extern long double fmal (long double __x, long double __y, long double __z) ; extern long double __fmal (long double __x, long double __y, long double __z) ;




extern long double scalbl (long double __x, long double __n) ; extern long double __scalbl (long double __x, long double __n) ;
# 110 "/usr/include/math.h" 2 3 4
# 125 "/usr/include/math.h" 3 4
extern int signgam;
# 166 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 252 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 277 "/usr/include/math.h" 3 4
struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);
# 423 "/usr/include/math.h" 3 4

# 52 "/usr/include/c++/3.3/cmath" 2 3
# 80 "/usr/include/c++/3.3/cmath" 3
namespace __gnu_cxx
{
  namespace __c99_binding
  {
# 107 "/usr/include/c++/3.3/cmath" 3
    using ::acosf;


    using ::asinf;


    using ::atanf;


    using ::atan2f;


    using ::ceilf;


    using ::coshf;


    using ::expf;


    using ::floorf;


    using ::fmodf;


    using ::frexpf;


    using ::ldexpf;


    using ::logf;


    using ::log10f;


    using ::modff;


    using ::powf;


    using ::sinhf;


    using ::tanf;


    using ::tanhf;


  }
}

namespace std
{


  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  inline float
  acos(float __x) { return __gnu_cxx::__c99_binding::acosf(__x); }





  using ::acos;


  inline long double
  acos(long double __x) { return ::acosl(__x); }





  using ::asin;


  inline float
  asin(float __x) { return __gnu_cxx::__c99_binding::asinf(__x); }






  inline long double
  asin(long double __x) { return ::asinl(__x); }





  using ::atan;


  inline float
  atan(float __x) { return __gnu_cxx::__c99_binding::atanf(__x); }






  inline long double
  atan(long double __x) { return ::atanl(__x); }





  using ::atan2;


  inline float
  atan2(float __y, float __x) { return __gnu_cxx::__c99_binding::atan2f(__y, __x); }







  inline long double
  atan2(long double __y, long double __x) { return ::atan2l(__y, __x); }






  using ::ceil;


  inline float
  ceil(float __x) { return __gnu_cxx::__c99_binding::ceilf(__x); }






  inline long double
  ceil(long double __x) { return ::ceill(__x); }





  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  using ::cosh;


  inline float
  cosh(float __x) { return __gnu_cxx::__c99_binding::coshf(__x); }






  inline long double
  cosh(long double __x) { return ::coshl(__x); }





  using ::exp;


  inline float
  exp(float __x) { return __gnu_cxx::__c99_binding::expf(__x); }






  inline long double
  exp(long double __x) { return ::expl(__x); }





  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  using ::floor;


  inline float
  floor(float __x) { return __gnu_cxx::__c99_binding::floorf(__x); }






  inline long double
  floor(long double __x) { return ::floorl(__x); }





  using ::fmod;


  inline float
  fmod(float __x, float __y) { return __gnu_cxx::__c99_binding::fmodf(__x, __y); }







  inline long double
  fmod(long double __x, long double __y) { return ::fmodl(__x, __y); }






  using ::frexp;


  inline float
  frexp(float __x, int* __exp) { return __gnu_cxx::__c99_binding::frexpf(__x, __exp); }






  inline long double
  frexp(long double __x, int* __exp) { return ::frexpl(__x, __exp); }






  using ::ldexp;


  inline float
  ldexp(float __x, int __exp) { return __gnu_cxx::__c99_binding::ldexpf(__x, __exp); }







  inline long double
  ldexp(long double __x, int __exp) { return ::ldexpl(__x, __exp); }






  using ::log;


  inline float
  log(float __x) { return __gnu_cxx::__c99_binding::logf(__x); }






  inline long double
  log(long double __x) { return ::logl(__x); }





  using ::log10;


  inline float
  log10(float __x) { return __gnu_cxx::__c99_binding::log10f(__x); }






  inline long double
  log10(long double __x) { return ::log10l(__x); }





  using ::modf;


  inline float
  modf(float __x, float* __iptr) { return __gnu_cxx::__c99_binding::modff(__x, __iptr); }
# 460 "/usr/include/c++/3.3/cmath" 3
  inline long double
  modf(long double __x, long double* __iptr) { return ::modfl(__x, __iptr); }
# 473 "/usr/include/c++/3.3/cmath" 3
  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  using ::pow;


  inline float
  pow(float __x, float __y) { return __gnu_cxx::__c99_binding::powf(__x, __y); }







  inline long double
  pow(long double __x, long double __y) { return ::powl(__x, __y); }






  inline double
  pow(double __x, int __i)
  { return __pow_helper(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __pow_helper(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __pow_helper(__x, __n); }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  using ::sinh;


  inline float
  sinh(float __x) { return __gnu_cxx::__c99_binding::sinhf(__x); }






  inline long double
  sinh(long double __x) { return ::sinhl(__x); }





  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  using ::tan;


  inline float
  tan(float __x) { return __gnu_cxx::__c99_binding::tanf(__x); }






  inline long double
  tan(long double __x) { return ::tanl(__x); }





  using ::tanh;


  inline float
  tanh(float __x) { return __gnu_cxx::__c99_binding::tanhf(__x); }






  inline long double
  tanh(long double __x) { return ::tanhl(__x); }




}







namespace __gnu_cxx
{
  template<typename _Tp>
    int
    __capture_fpclassify(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __fpclassifyf (__f) : sizeof (__f) == sizeof (double) ? __fpclassify (__f) : __fpclassifyl (__f)); }

  template<typename _Tp>
    int
    __capture_isfinite(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __finitef (__f) : sizeof (__f) == sizeof (double) ? __finite (__f) : __finitel (__f)); }

  template<typename _Tp>
    int
    __capture_isinf(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __isinff (__f) : sizeof (__f) == sizeof (double) ? __isinf (__f) : __isinfl (__f)); }

  template<typename _Tp>
    int
    __capture_isnan(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __isnanf (__f) : sizeof (__f) == sizeof (double) ? __isnan (__f) : __isnanl (__f)); }

  template<typename _Tp>
    int
    __capture_isnormal(_Tp __f) { return ((sizeof (__f) == sizeof (float) ? __fpclassifyf (__f) : sizeof (__f) == sizeof (double) ? __fpclassify (__f) : __fpclassifyl (__f)) == FP_NORMAL); }

  template<typename _Tp>
    int
    __capture_signbit(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __signbitf (__f) : sizeof (__f) == sizeof (double) ? __signbit (__f) : __signbitl (__f)); }

  template<typename _Tp>
    int
    __capture_isgreater(_Tp __f1, _Tp __f2)
    { return ( ({ __typeof__(__f1) __x = (__f1); __typeof__(__f2) __y = (__f2); !( ({ __typeof__(__x) __u = (__x); __typeof__(__y) __v = (__y); (sizeof (__u) == sizeof (float) ? __fpclassifyf (__u) : sizeof (__u) == sizeof (double) ? __fpclassify (__u) : __fpclassifyl (__u)) == FP_NAN || (sizeof (__v) == sizeof (float) ? __fpclassifyf (__v) : sizeof (__v) == sizeof (double) ? __fpclassify (__v) : __fpclassifyl (__v)) == FP_NAN; })) && __x > __y; })); }

  template<typename _Tp>
     int
     __capture_isgreaterequal(_Tp __f1, _Tp __f2)
     { return ( ({ __typeof__(__f1) __x = (__f1); __typeof__(__f2) __y = (__f2); !( ({ __typeof__(__x) __u = (__x); __typeof__(__y) __v = (__y); (sizeof (__u) == sizeof (float) ? __fpclassifyf (__u) : sizeof (__u) == sizeof (double) ? __fpclassify (__u) : __fpclassifyl (__u)) == FP_NAN || (sizeof (__v) == sizeof (float) ? __fpclassifyf (__v) : sizeof (__v) == sizeof (double) ? __fpclassify (__v) : __fpclassifyl (__v)) == FP_NAN; })) && __x >= __y; })); }

  template<typename _Tp>
     int
     __capture_isless(_Tp __f1, _Tp __f2) { return ( ({ __typeof__(__f1) __x = (__f1); __typeof__(__f2) __y = (__f2); !( ({ __typeof__(__x) __u = (__x); __typeof__(__y) __v = (__y); (sizeof (__u) == sizeof (float) ? __fpclassifyf (__u) : sizeof (__u) == sizeof (double) ? __fpclassify (__u) : __fpclassifyl (__u)) == FP_NAN || (sizeof (__v) == sizeof (float) ? __fpclassifyf (__v) : sizeof (__v) == sizeof (double) ? __fpclassify (__v) : __fpclassifyl (__v)) == FP_NAN; })) && __x < __y; })); }

  template<typename _Tp>
     int
     __capture_islessequal(_Tp __f1, _Tp __f2)
     { return ( ({ __typeof__(__f1) __x = (__f1); __typeof__(__f2) __y = (__f2); !( ({ __typeof__(__x) __u = (__x); __typeof__(__y) __v = (__y); (sizeof (__u) == sizeof (float) ? __fpclassifyf (__u) : sizeof (__u) == sizeof (double) ? __fpclassify (__u) : __fpclassifyl (__u)) == FP_NAN || (sizeof (__v) == sizeof (float) ? __fpclassifyf (__v) : sizeof (__v) == sizeof (double) ? __fpclassify (__v) : __fpclassifyl (__v)) == FP_NAN; })) && __x <= __y; })); }

  template<typename _Tp>
     int
     __capture_islessgreater(_Tp __f1, _Tp __f2)
     { return ( ({ __typeof__(__f1) __x = (__f1); __typeof__(__f2) __y = (__f2); !( ({ __typeof__(__x) __u = (__x); __typeof__(__y) __v = (__y); (sizeof (__u) == sizeof (float) ? __fpclassifyf (__u) : sizeof (__u) == sizeof (double) ? __fpclassify (__u) : __fpclassifyl (__u)) == FP_NAN || (sizeof (__v) == sizeof (float) ? __fpclassifyf (__v) : sizeof (__v) == sizeof (double) ? __fpclassify (__v) : __fpclassifyl (__v)) == FP_NAN; })) && (__x < __y || __y < __x); })); }

  template<typename _Tp>
     int
     __capture_isunordered(_Tp __f1, _Tp __f2)
     { return ( ({ __typeof__(__f1) __u = (__f1); __typeof__(__f2) __v = (__f2); (sizeof (__u) == sizeof (float) ? __fpclassifyf (__u) : sizeof (__u) == sizeof (double) ? __fpclassify (__u) : __fpclassifyl (__u)) == FP_NAN || (sizeof (__v) == sizeof (float) ? __fpclassifyf (__v) : sizeof (__v) == sizeof (double) ? __fpclassify (__v) : __fpclassifyl (__v)) == FP_NAN; })); }
}
# 668 "/usr/include/c++/3.3/cmath" 3
namespace __gnu_cxx
{
  template<typename _Tp>
    int
    fpclassify(_Tp __f) { return __capture_fpclassify(__f); }

  template<typename _Tp>
    int
    isfinite(_Tp __f) { return __capture_isfinite(__f); }

  template<typename _Tp>
    int
    isinf(_Tp __f) { return __capture_isinf(__f); }

  template<typename _Tp>
    int
    isnan(_Tp __f) { return __capture_isnan(__f); }

  template<typename _Tp>
    int
    isnormal(_Tp __f) { return __capture_isnormal(__f); }

  template<typename _Tp>
    int
    signbit(_Tp __f) { return __capture_signbit(__f); }

  template<typename _Tp>
    int
    isgreater(_Tp __f1, _Tp __f2) { return __capture_isgreater(__f1, __f2); }

  template<typename _Tp>
    int
    isgreaterequal(_Tp __f1, _Tp __f2)
    { return __capture_isgreaterequal(__f1, __f2); }

  template<typename _Tp>
    int
    isless(_Tp __f1, _Tp __f2) { return __capture_isless(__f1, __f2); }

  template<typename _Tp>
    int
    islessequal(_Tp __f1, _Tp __f2)
    { return __capture_islessequal(__f1, __f2); }

  template<typename _Tp>
    int
    islessgreater(_Tp __f1, _Tp __f2)
    { return __capture_islessgreater(__f1, __f2); }

  template<typename _Tp>
    int
    isunordered(_Tp __f1, _Tp __f2)
    { return __capture_isunordered(__f1, __f2); }
}

namespace std
{
  using __gnu_cxx::fpclassify;
  using __gnu_cxx::isfinite;
  using __gnu_cxx::isinf;
  using __gnu_cxx::isnan;
  using __gnu_cxx::isnormal;
  using __gnu_cxx::signbit;
  using __gnu_cxx::isgreater;
  using __gnu_cxx::isgreaterequal;
  using __gnu_cxx::isless;
  using __gnu_cxx::islessequal;
  using __gnu_cxx::islessgreater;
  using __gnu_cxx::isunordered;
}





# 1 "/usr/include/c++/3.3/bits/cmath.tcc" 1 3
# 35 "/usr/include/c++/3.3/bits/cmath.tcc" 3
namespace std
{
  template<typename _Tp>
    _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : 1;

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }
}
# 744 "/usr/include/c++/3.3/cmath" 2 3
# 42 "/usr/include/c++/3.3/bits/locale_facets.tcc" 2 3

# 1 "/usr/include/c++/3.3/limits" 1 3
# 46 "/usr/include/c++/3.3/limits" 3
       
# 47 "/usr/include/c++/3.3/limits" 3
# 150 "/usr/include/c++/3.3/limits" 3
namespace std
{
  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };

  enum float_denorm_style
  {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
  };




  struct __numeric_limits_base
  {
    static const bool is_specialized = false;

    static const int digits = 0;
    static const int digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
  };

  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
      static _Tp min() { return static_cast<_Tp>(0); }
      static _Tp max() { return static_cast<_Tp>(0); }
      static _Tp epsilon() { return static_cast<_Tp>(0); }
      static _Tp round_error() { return static_cast<_Tp>(0); }
      static _Tp infinity() { return static_cast<_Tp>(0); }
      static _Tp quiet_NaN() { return static_cast<_Tp>(0); }
      static _Tp signaling_NaN() { return static_cast<_Tp>(0); }
      static _Tp denorm_min() { return static_cast<_Tp>(0); }
    };



  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min()
      { return false; }
      static bool max()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon()
      { return false; }
      static bool round_error()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity()
      { return false; }
      static bool quiet_NaN()
      { return false; }
      static bool signaling_NaN()
      { return false; }
      static bool denorm_min()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon()
      { return 0; }
      static char round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity()
      { return char(); }
      static char quiet_NaN()
      { return char(); }
      static char signaling_NaN()
      { return char(); }
      static char denorm_min()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min()
      { return -127 - 1; }
      static signed char max()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon()
      { return 0; }
      static signed char round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN()
      { return static_cast<signed char>(0); }
      static signed char denorm_min()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min()
      { return 0; }
      static unsigned char max()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon()
      { return 0; }
      static unsigned char round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon()
      { return 0; }
      static wchar_t round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity()
      { return wchar_t(); }
      static wchar_t quiet_NaN()
      { return wchar_t(); }
      static wchar_t signaling_NaN()
      { return wchar_t(); }
      static wchar_t denorm_min()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min()
      { return -32767 - 1; }
      static short max()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon()
      { return 0; }
      static short round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity()
      { return short(); }
      static short quiet_NaN()
      { return short(); }
      static short signaling_NaN()
      { return short(); }
      static short denorm_min()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min()
      { return 0; }
      static unsigned short max()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon()
      { return 0; }
      static unsigned short round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min()
      { return -2147483647 - 1; }
      static int max()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon()
      { return 0; }
      static int round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity()
      { return static_cast<int>(0); }
      static int quiet_NaN()
      { return static_cast<int>(0); }
      static int signaling_NaN()
      { return static_cast<int>(0); }
      static int denorm_min()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min()
      { return 0; }
      static unsigned int max()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon()
      { return 0; }
      static unsigned int round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min()
      { return -2147483647L - 1; }
      static long max()
      { return 2147483647L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon()
      { return 0; }
      static long round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity()
      { return static_cast<long>(0); }
      static long quiet_NaN()
      { return static_cast<long>(0); }
      static long signaling_NaN()
      { return static_cast<long>(0); }
      static long denorm_min()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min()
      { return 0; }
      static unsigned long max()
      { return 2147483647L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon()
      { return 0; }
      static unsigned long round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min()
      { return -9223372036854775807LL - 1; }
      static long long max()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon()
      { return 0; }
      static long long round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity()
      { return static_cast<long long>(0); }
      static long long quiet_NaN()
      { return static_cast<long long>(0); }
      static long long signaling_NaN()
      { return static_cast<long long>(0); }
      static long long denorm_min()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min()
      { return 0; }
      static unsigned long long max()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon()
      { return 0; }
      static unsigned long long round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min()
      { return 1.17549435e-38F; }
      static float max()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon()
      { return 1.19209290e-7F; }
      static float round_error()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity
        = __builtin_huge_valf () / 2 == __builtin_huge_valf ();
      static const bool has_quiet_NaN
        = __builtin_nanf ("") != __builtin_nanf ("");
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
        = 1.40129846e-45F ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity()
      { return __builtin_huge_valf (); }
      static float quiet_NaN()
      { return __builtin_nanf (""); }
      static float signaling_NaN()
      { return __builtin_nansf (""); }
      static float denorm_min()
      { return 1.40129846e-45F; }

      static const bool is_iec559
        = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min()
      { return 2.2250738585072014e-308; }
      static double max()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon()
      { return 2.2204460492503131e-16; }
      static double round_error()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity
        = __builtin_huge_val () / 2 == __builtin_huge_val ();
      static const bool has_quiet_NaN
        = __builtin_nan ("") != __builtin_nan ("");
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
        = 4.9406564584124654e-324 ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity()
      { return __builtin_huge_val(); }
      static double quiet_NaN()
      { return __builtin_nan (""); }
      static double signaling_NaN()
      { return __builtin_nans (""); }
      static double denorm_min()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
        = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min()
      { return 3.36210314311209350626e-4932L; }
      static long double max()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon()
      { return 1.08420217248550443401e-19L; }
      static long double round_error()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity
        = __builtin_huge_vall () / 2 == __builtin_huge_vall ();
      static const bool has_quiet_NaN
        = __builtin_nanl ("") != __builtin_nanl ("");
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
        = 3.64519953188247460253e-4951L ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;

      static long double infinity()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN()
      { return __builtin_nanl (""); }
      static long double signaling_NaN()
      { return __builtin_nansl (""); }
      static long double denorm_min()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
        = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 44 "/usr/include/c++/3.3/bits/locale_facets.tcc" 2 3
# 1 "/usr/include/c++/3.3/typeinfo" 1 3
# 40 "/usr/include/c++/3.3/typeinfo" 3
extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 55 "/usr/include/c++/3.3/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const
    { return __name; }


    bool before(const type_info& __arg) const;



    bool operator==(const type_info& __arg) const;
# 106 "/usr/include/c++/3.3/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:

    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
                            unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
                             void **__obj_ptr) const;
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() { }


    virtual ~bad_cast() ;
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () { }


    virtual ~bad_typeid() ;
  };
}

}
# 45 "/usr/include/c++/3.3/bits/locale_facets.tcc" 2 3


namespace std
{
  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
                                __s2.data(), __s2.data() + __s2.length()) < 0);
    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      size_t __i = _Facet::id._M_id();
      locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }

  template<typename _Facet>
    bool
    has_facet(const locale& __loc)
    {
      size_t __i = _Facet::id._M_id();
      locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }



  template<typename _Facet>
    inline const __locale_cache<_Facet>&
    __use_cache(const locale& __loc)
    {
      size_t __i = _Facet::id._M_id();
      if (__builtin_expect(__i >= __loc._M_impl->_M_facets_size,false))
        __throw_bad_cast();
      __locale_cache_base* __cache = __loc._M_impl->_M_get_cache(__i);
      if (__builtin_expect(!__cache, false))
        {
          __cache = new __locale_cache<_Facet>(__loc);
          __loc._M_impl->_M_install_cache(__cache, __i);
        }
      return static_cast<const __locale_cache<_Facet>&>(*__cache);
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
                     ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);


      const char_type __plus = __ctype.widen('+');
      const char_type __minus = __ctype.widen('-');
      int __pos = 0;
      char_type __c = *__beg;
      if ((__traits_type::eq(__c, __plus) || __traits_type::eq(__c, __minus))
          && __beg != __end)
        {
          __xtrc += __ctype.narrow(__c, char());
          ++__pos;
          __c = *(++__beg);
        }


      const char_type __zero = __ctype.widen(_S_atoms_in[_M_zero]);
      bool __found_zero = false;
      while (__traits_type::eq(__c, __zero) && __beg != __end)
        {
          __c = *(++__beg);
          __found_zero = true;
        }
      if (__found_zero)
        {
          __xtrc += _S_atoms_in[_M_zero];
          ++__pos;
        }


      const size_t __len = _M_E - _M_zero + 1;
      char_type __watoms[__len];
      __ctype.widen(_S_atoms_in, _S_atoms_in + __len, __watoms);
      bool __found_dec = false;
      bool __found_sci = false;
      const char_type __dec = __np.decimal_point();

      string __found_grouping;
      const string __grouping = __np.grouping();
      bool __check_grouping = __grouping.size();
      int __sep_pos = 0;
      const char_type __sep = __np.thousands_sep();

      while (__beg != __end)
        {

          const char_type* __p = __traits_type::find(__watoms, 10, __c);


          if (__p && !__traits_type::eq(__c, char_type()))
            {

              ++__pos;
              __xtrc += _S_atoms_in[__p - __watoms];
              ++__sep_pos;
              __c = *(++__beg);
            }
          else if (__traits_type::eq(__c, __sep)
                   && __check_grouping && !__found_dec)
            {


              if (__sep_pos)
                {
                  __found_grouping += static_cast<char>(__sep_pos);
                  __sep_pos = 0;
                  __c = *(++__beg);
                }
              else
                {
                  __err |= ios_base::failbit;
                  break;
                }
            }
          else if (__traits_type::eq(__c, __dec) && !__found_dec)
            {



              if (__found_grouping.size())
                __found_grouping += static_cast<char>(__sep_pos);
              ++__pos;
              __xtrc += '.';
              __c = *(++__beg);
              __found_dec = true;
            }
          else if ((__traits_type::eq(__c, __watoms[_M_e])
                    || __traits_type::eq(__c, __watoms[_M_E]))
                   && !__found_sci && __pos)
            {

              ++__pos;
              __xtrc += __ctype.narrow(__c, char());
              __c = *(++__beg);


              if (__traits_type::eq(__c, __plus)
                  || __traits_type::eq(__c, __minus))
                {
                  ++__pos;
                  __xtrc += __ctype.narrow(__c, char());
                  __c = *(++__beg);
                }
              __found_sci = true;
            }
          else

            break;
        }



      if (__check_grouping && __found_grouping.size())
        {

          if (!__found_dec)
            __found_grouping += static_cast<char>(__sep_pos);
          if (!__verify_grouping(__grouping, __found_grouping))
            __err |= ios_base::failbit;
        }


      __xtrc += char();
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
                   ios_base::iostate& __err, string& __xtrc, int& __base) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);


      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
      if (__basefield == ios_base::oct)
        __base = 8;
      else if (__basefield == ios_base::hex)
        __base = 16;
      else
        __base = 10;


      int __pos = 0;
      char_type __c = *__beg;
      const char_type __plus = __ctype.widen('+');
      const char_type __minus = __ctype.widen('-');

      if ((__traits_type::eq(__c, __plus) || __traits_type::eq(__c, __minus))
          && __beg != __end)
        {
          __xtrc += __ctype.narrow(__c, char());
          ++__pos;
          __c = *(++__beg);
        }


      const char_type __zero = __ctype.widen(_S_atoms_in[_M_zero]);
      const char_type __x = __ctype.widen('x');
      const char_type __X = __ctype.widen('X');
      if (__base == 10)
        {
          bool __found_zero = false;
          while (__traits_type::eq(__c, __zero) && __beg != __end)
            {
              __c = *(++__beg);
              __found_zero = true;
            }
          if (__found_zero)
            {
              __xtrc += _S_atoms_in[_M_zero];
              ++__pos;
              if (__basefield == 0)
                {
                  if ((__traits_type::eq(__c, __x)
                       || __traits_type::eq(__c, __X))
                      && __beg != __end)
                    {
                      __xtrc += __ctype.narrow(__c, char());
                      ++__pos;
                      __c = *(++__beg);
                      __base = 16;
                    }
                  else
                    __base = 8;
                }
            }
        }
      else if (__base == 16)
        {
          if (__traits_type::eq(__c, __zero) && __beg != __end)
            {
              __xtrc += _S_atoms_in[_M_zero];
              ++__pos;
              __c = *(++__beg);
              if ((__traits_type::eq(__c, __x) || __traits_type::eq(__c, __X))
                  && __beg != __end)
                {
                  __xtrc += __ctype.narrow(__c, char());
                  ++__pos;
                  __c = *(++__beg);
                }
            }
        }



      size_t __len;
      if (__base == 16)
        __len = _M_size;
      else
        __len = __base;


      char_type __watoms[_M_size];
      __ctype.widen(_S_atoms_in, _S_atoms_in + __len, __watoms);
      string __found_grouping;
      const string __grouping = __np.grouping();
      bool __check_grouping = __grouping.size();
      int __sep_pos = 0;
      const char_type __sep = __np.thousands_sep();
      while (__beg != __end)
        {
          const char_type* __p = __traits_type::find(__watoms, __len, __c);


          if (__p && !__traits_type::eq(__c, char_type()))
            {

              __xtrc += _S_atoms_in[__p - __watoms];
              ++__pos;
              ++__sep_pos;
              __c = *(++__beg);
            }
          else if (__traits_type::eq(__c, __sep) && __check_grouping)
            {


              if (__sep_pos)
                {
                  __found_grouping += static_cast<char>(__sep_pos);
                  __sep_pos = 0;
                  __c = *(++__beg);
                }
              else
                {
                  __err |= ios_base::failbit;
                  break;
                }
            }
          else

            break;
        }



      if (__check_grouping && __found_grouping.size())
        {

          __found_grouping += static_cast<char>(__sep_pos);
          if (!__verify_grouping(__grouping, __found_grouping))
            __err |= ios_base::failbit;
        }


      __xtrc += char();
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {

      if (!(__io.flags() & ios_base::boolalpha))
        {


          string __xtrc;
          int __base;
          __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);

          unsigned long __ul;
          __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
          if (!(__err & ios_base::failbit) && __ul <= 1)
            __v = __ul;
          else
            __err |= ios_base::failbit;
        }


      else
        {
          typedef char_traits<_CharT> __traits_type;
          typedef basic_string<_CharT> __string_type;

          locale __loc = __io.getloc();
          const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
          const __string_type __true = __np.truename();
          const __string_type __false = __np.falsename();
          const char_type* __trues = __true.c_str();
          const char_type* __falses = __false.c_str();
          const size_t __truen = __true.size() - 1;
          const size_t __falsen = __false.size() - 1;

          for (size_t __n = 0; __beg != __end; ++__n)
            {
              char_type __c = *__beg++;
              bool __testf = __n <= __falsen
                             ? __traits_type::eq(__c, __falses[__n]) : false;
              bool __testt = __n <= __truen
                             ? __traits_type::eq(__c, __trues[__n]) : false;
              if (!(__testf || __testt))
                {
                  __err |= ios_base::failbit;
                  break;
                }
              else if (__testf && __n == __falsen)
                {
                  __v = 0;
                  break;
                }
              else if (__testt && __n == __truen)
                {
                  __v = 1;
                  break;
                }
            }
          if (__beg == __end)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      unsigned long __ul;
      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
      if (!(__err & ios_base::failbit)
          && __ul <= numeric_limits<unsigned short>::max())
        __v = static_cast<unsigned short>(__ul);
      else
        __err |= ios_base::failbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      unsigned long __ul;
      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
      if (!(__err & ios_base::failbit)
          && __ul <= numeric_limits<unsigned int>::max())
        __v = static_cast<unsigned int>(__ul);
      else
        __err |= ios_base::failbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      fmtflags __fmt = __io.flags();
      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield
                             | ios_base::uppercase | ios_base::internal);
      __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));

      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);


      __io.flags(__fmt);

      unsigned long __ul;
      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
      if (!(__err & ios_base::failbit))
        __v = reinterpret_cast<void*>(__ul);
      else
        __err |= ios_base::failbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
           _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,
                                                  __w, __len, true);
      __len = static_cast<int>(__w);
    }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __out, const int __size, long __v,
                       const _CharT* __lit, ios_base::fmtflags __flags)
    {
      unsigned long __ul = static_cast<unsigned long>(__v);
      bool __neg = false;
      if (__v < 0)
        {
          __ul = -__ul;
          __neg = true;
        }
      return __int_to_char(__out, __size, __ul, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __out, const int __size, unsigned long __v,
                       const _CharT* __lit, ios_base::fmtflags __flags)
    { return __int_to_char(__out, __size, __v, __lit, __flags, false); }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __out, const int __size, long long __v,
                       const _CharT* __lit, ios_base::fmtflags __flags)
    {
      unsigned long long __ull = static_cast<unsigned long long>(__v);
      bool __neg = false;
      if (__v < 0)
        {
          __ull = -__ull;
          __neg = true;
        }
      return __int_to_char(__out, __size, __ull, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __out, const int __size, unsigned long long __v,
                       const _CharT* __lit, ios_base::fmtflags __flags)
    { return __int_to_char(__out, __size, __v, __lit, __flags, false); }


  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __out, const int __size, _ValueT __v,
                  const _CharT* __lit, ios_base::fmtflags __flags, bool __neg)
    {

      const bool __showbase = (__flags & ios_base::showbase) && __v;
      const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
      _CharT* __buf = __out + __size - 1;
      _CharT* __bufend = __out + __size;

      if (__builtin_expect(__basefield != ios_base::oct &&
                           __basefield != ios_base::hex, true))
        {

          do
            {
              *__buf-- = __lit[(__v % 10) + __num_base::_S_digits];
              __v /= 10;
            }
          while (__v != 0);
          if (__neg)
            *__buf-- = __lit[__num_base::_S_minus];
          else if (__flags & ios_base::showpos)
            *__buf-- = __lit[__num_base::_S_plus];
        }
      else if (__basefield == ios_base::oct)
        {

          do
            {
              *__buf-- = __lit[(__v & 0x7) + __num_base::_S_digits];
              __v >>= 3;
            }
          while (__v != 0);
          if (__showbase)
            *__buf-- = __lit[__num_base::_S_digits];
        }
      else
        {

          const bool __uppercase = __flags & ios_base::uppercase;
          int __case_offset = __uppercase
                              ? __num_base::_S_udigits : __num_base::_S_digits;
          do
            {
              *__buf-- = __lit[(__v & 0xf) + __case_offset];
              __v >>= 4;
            }
          while (__v != 0);
          if (__showbase)
            {

              *__buf-- = __lit[__num_base::_S_x + __uppercase];

              *__buf-- = __lit[__num_base::_S_digits];
            }
        }
      int __ret = __bufend - __buf - 1;
      return __ret;
    }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const string& __grouping, _CharT __sep, ios_base& __io,
                 _CharT* __new, _CharT* __cs, int& __len) const
    {





      streamsize __off = 0;
      const ios_base::fmtflags __basefield = __io.flags()
                                             & ios_base::basefield;
      if ((__io.flags() & ios_base::showbase) && __len > 1)
        if (__basefield == ios_base::oct)
          {
            __off = 1;
            *__new = *__cs;
          }
        else if (__basefield == ios_base::hex)
          {
            __off = 2;
            *__new = *__cs;
            *(__new + 1) = *(__cs + 1);
          }
      _CharT* __p;
      __p = __add_grouping(__new + __off, __sep,
                           __grouping.c_str(),
                           __grouping.c_str() + __grouping.size(),
                           __cs + __off, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_convert_int(_OutIter __s, ios_base& __io, _CharT __fill,
                     _ValueT __v) const
      {
        typedef numpunct<_CharT> __facet_type;
        typedef __locale_cache<numpunct<_CharT> > __cache_type;
        const locale& __loc = __io._M_getloc();
        const __cache_type& __lc = __use_cache<__facet_type>(__loc);
        const _CharT* __lit = __lc._M_atoms_out;


        int __ilen = 4 * sizeof(_ValueT);
        _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                             * __ilen));


        int __len;
        __len = __int_to_char(&__cs[0], __ilen, __v, __lit, __io.flags());
        __cs = __cs + __ilen - __len;


        _CharT* __cs2;
        if (__lc._M_use_grouping)
          {


            __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                          * __len * 2));
            _M_group_int(__lc._M_grouping, __lc._M_thousands_sep, __io,
                         __cs2, __cs, __len);
            __cs = __cs2;
          }


        _CharT* __cs3;
        streamsize __w = __io.width();
        if (__w > static_cast<streamsize>(__len))
          {
            __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                          * __w));
            _M_pad(__fill, __w, __io, __cs3, __cs, __len);
            __cs = __cs3;
          }
        __io.width(0);



        return __write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const string& __grouping, _CharT __sep, const _CharT* __p,
                   _CharT* __new, _CharT* __cs, int& __len) const
    {



      _CharT* __p2;
      int __declen = __p ? __p - __cs : __len;
      __p2 = __add_grouping(__new, __sep,
                            __grouping.c_str(),
                            __grouping.c_str() + __grouping.size(),
                            __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
        {
          char_traits<_CharT>::copy(__p2, __p, __len - __declen);
          __newlen += __len - __declen;
        }
      __len = __newlen;

    }
# 872 "/usr/include/c++/3.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_convert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
                       _ValueT __v) const
      {







        const int __max_digits = numeric_limits<_ValueT>::digits10 + 2;


        streamsize __prec = __io.precision();
        if (__prec > static_cast<streamsize>(__max_digits))
          __prec = static_cast<streamsize>(__max_digits);
        else if (__prec < static_cast<streamsize>(0))
          __prec = static_cast<streamsize>(6);

        typedef numpunct<_CharT> __facet_type;
        typedef __locale_cache<numpunct<_CharT> > __cache_type;
        const locale __loc = __io._M_getloc();
        const __cache_type& __lc = __use_cache<__facet_type>(__loc);


        int __len;

        char __fbuf[16];




        int __cs_size = __max_digits * 3;
        char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));

        _S_format_float(__io, __fbuf, __mod, __prec);
        __len = __convert_from_v(__cs, __cs_size, __fbuf, __v,
                                 _S_c_locale, __prec);


        if (__len >= __cs_size)
          {
            __cs_size = __len + 1;
            __cs = static_cast<char*>(__builtin_alloca(__cs_size));
            __len = __convert_from_v(__cs, __cs_size, __fbuf, __v,
                                     _S_c_locale, __prec);
          }
# 943 "/usr/include/c++/3.3/bits/locale_facets.tcc" 3
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __len));
      __ctype.widen(__cs, __cs + __len, __ws);


      const _CharT __cdec = __ctype.widen('.');
      const _CharT __dec = __lc._M_decimal_point;
      const _CharT* __p;
      if (__p = char_traits<_CharT>::find(__ws, __len, __cdec))
        __ws[__p - __ws] = __dec;


      _CharT* __ws2;
      if (__lc._M_use_grouping)
        {


            __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                          * __len * 2));
            _M_group_float(__lc._M_grouping, __lc._M_thousands_sep, __p,
                           __ws2, __ws, __len);
            __ws = __ws2;
        }


      _CharT* __ws3;
      streamsize __w = __io.width();
      if (__w > static_cast<streamsize>(__len))
        {
          __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
          _M_pad(__fill, __w, __io, __ws3, __ws, __len);
          __ws = __ws3;
        }
      __io.width(0);



      return __write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          unsigned long __uv = __v;
          __s = _M_convert_int(__s, __io, __fill, __uv);
        }
      else
        {
          typedef numpunct<_CharT> __facet_type;
          typedef __locale_cache<numpunct<_CharT> > __cache_type;
          const locale __loc = __io._M_getloc();
          const __cache_type& __lc = __use_cache<__facet_type>(__loc);

          typedef basic_string<_CharT> __string_type;
          __string_type __name;
          if (__v)
            __name = __lc._M_truename;
          else
            __name = __lc._M_falsename;

          const _CharT* __cs = __name.c_str();
          int __len = __name.size();
          _CharT* __cs3;
          streamsize __w = __io.width();
          if (__w > static_cast<streamsize>(__len))
            {
              __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __w));
              _M_pad(__fill, __w, __io, __cs3, __cs, __len);
              __cs = __cs3;
            }
          __io.width(0);
          __s = __write(__s, __cs, __len);
        }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_convert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_convert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const
    { return _M_convert_int(__s, __b, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_convert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_convert_float(__s, __io, __fill, char(), __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           long double __v) const
    { return _M_convert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      ios_base::fmtflags __flags = __io.flags();
      ios_base::fmtflags __fmt = ~(ios_base::showpos | ios_base::basefield
                                   | ios_base::uppercase | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));
      if (true)
        {
          __s = _M_convert_int(__s, __io, __fill,
                               reinterpret_cast<unsigned long>(__v));
          __io.flags(__flags);
        }
      if (false)
        {
          __io.flags(__flags);
          ;
        }
      return __s;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
           ios_base::iostate& __err, long double& __units) const
    {
      string_type __str;
      __beg = this->do_get(__beg, __end, __intl, __io, __err, __str);

      const int __n = numeric_limits<long double>::digits10;
      char* __cs = static_cast<char*>(__builtin_alloca(__n));
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const _CharT* __wcs = __str.c_str();
      __ctype.narrow(__wcs, __wcs + __str.size() + 1, char(), __cs);
      __convert_to_v(__cs, __units, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
           ios_base::iostate& __err, string_type& __units) const
    {

      typedef moneypunct<_CharT, true> __money_true;
      typedef moneypunct<_CharT, false> __money_false;
      typedef money_base::part part;
      typedef typename string_type::size_type size_type;

      const locale __loc = __io.getloc();
      const __money_true& __mpt = use_facet<__money_true>(__loc);
      const __money_false& __mpf = use_facet<__money_false>(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      const money_base::pattern __p = __intl ? __mpt.neg_format()
                                             : __mpf.neg_format();

      const string_type __pos_sign =__intl ? __mpt.positive_sign()
                                           : __mpf.positive_sign();
      const string_type __neg_sign =__intl ? __mpt.negative_sign()
                                           : __mpf.negative_sign();
      const char_type __d = __intl ? __mpt.decimal_point()
                                   : __mpf.decimal_point();
      const char_type __sep = __intl ? __mpt.thousands_sep()
                                     : __mpf.thousands_sep();

      const string __grouping = __intl ? __mpt.grouping() : __mpf.grouping();


      string_type __sign;

      string __grouping_tmp;

      int __sep_pos = 0;

      bool __testvalid = true;

      bool __testdecfound = false;


      string_type __temp_units;

      char_type __c = *__beg;
      char_type __eof = static_cast<char_type>(char_traits<char_type>::eof());
      for (int __i = 0; __beg != __end && __i < 4 && __testvalid; ++__i)
        {
          part __which = static_cast<part>(__p.field[__i]);
          switch (__which)
                {
                case money_base::symbol:
                  if (__io.flags() & ios_base::showbase
                      || __i < 2 || __sign.size() > 1
                      || ((static_cast<part>(__p.field[3]) != money_base::none)
                          && __i == 2))
                    {





                      const string_type __symbol = __intl ? __mpt.curr_symbol()
                                                         : __mpf.curr_symbol();
                      size_type __len = __symbol.size();
                      size_type __j = 0;
                      while (__beg != __end
                             && __j < __len && __symbol[__j] == __c)
                        {
                          __c = *(++__beg);
                          ++__j;
                        }


                      if (__j != __len && (__io.flags() & ios_base::showbase))
                        __testvalid = false;
                    }
                  break;
                case money_base::sign:

                  if (__pos_sign.size() && __neg_sign.size())
                  {

                    if (__c == __pos_sign[0])
                      {
                        __sign = __pos_sign;
                        __c = *(++__beg);
                      }
                    else if (__c == __neg_sign[0])
                      {
                        __sign = __neg_sign;
                        __c = *(++__beg);
                      }
                    else
                      __testvalid = false;
                  }
                  else if (__pos_sign.size() && __c == __pos_sign[0])
                    {
                      __sign = __pos_sign;
                      __c = *(++__beg);
                    }
                  else if (__neg_sign.size() && __c == __neg_sign[0])
                    {
                      __sign = __neg_sign;
                      __c = *(++__beg);
                    }
                  break;
                case money_base::value:


                  while (__beg != __end
                         && (__ctype.is(ctype_base::digit, __c)
                             || (__c == __d && !__testdecfound)
                             || __c == __sep))
                    {
                      if (__c == __d)
                        {
                          __grouping_tmp += static_cast<char>(__sep_pos);
                          __sep_pos = 0;
                          __testdecfound = true;
                        }
                      else if (__c == __sep)
                        {
                          if (__grouping.size())
                            {

                              __grouping_tmp += static_cast<char>(__sep_pos);
                              __sep_pos = 0;
                            }
                          else
                            {
                              __testvalid = false;
                              break;
                            }
                        }
                      else
                        {
                          __temp_units += __c;
                          ++__sep_pos;
                        }
                      __c = *(++__beg);
                    }
                  break;
                case money_base::space:
                case money_base::none:

                  if (__i != 3)
                    while (__beg != __end
                           && __ctype.is(ctype_base::space, __c))
                      __c = *(++__beg);
                  break;
                }
        }


      if (__sign.size() > 1)
        {
          size_type __len = __sign.size();
          size_type __i = 1;
          for (; __c != __eof && __i < __len; ++__i)
            while (__beg != __end && __c != __sign[__i])
              __c = *(++__beg);

          if (__i != __len)
            __testvalid = false;
        }


      while (__temp_units.size() > 1 && __temp_units[0] == __ctype.widen('0'))
        __temp_units.erase(__temp_units.begin());

      if (__sign.size() && __sign == __neg_sign)
        __temp_units.insert(__temp_units.begin(), __ctype.widen('-'));


      if (__grouping.size() && __grouping_tmp.size())
        {
          if (!__verify_grouping(__grouping, __grouping_tmp))
            __testvalid = false;
        }


      if (__c == __eof)
        __err |= ios_base::eofbit;


      if (!__testvalid || !__temp_units.size())
        __err |= ios_base::failbit;
      else

        __temp_units.swap(__units);

      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
           long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
      int __len = __convert_from_v(__cs, __cs_size, "%.01Lf", __units,
                                   _S_c_locale);

      if (__len >= __cs_size)
        {
          __cs_size = __len + 1;
          __cs = static_cast<char*>(__builtin_alloca(__cs_size));
          __len = __convert_from_v(__cs, __cs_size, "%.01Lf", __units,
                                   _S_c_locale);
        }







      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __cs_size));
      __ctype.widen(__cs, __cs + __len, __ws);
      string_type __digits(__ws);
      return this->do_put(__s, __intl, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
           const string_type& __digits) const
    {
      typedef typename string_type::size_type size_type;
      typedef money_base::part part;

      const locale __loc = __io.getloc();
      const size_type __width = static_cast<size_type>(__io.width());


      typedef moneypunct<_CharT, true> __money_true;
      typedef moneypunct<_CharT, false> __money_false;
      const __money_true& __mpt = use_facet<__money_true>(__loc);
      const __money_false& __mpf = use_facet<__money_false>(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);



      const char_type* __beg = __digits.data();
      const char_type* __end = __beg + __digits.size();
      money_base::pattern __p;
      string_type __sign;
      if (*__beg != __ctype.widen('-'))
        {
          __p = __intl ? __mpt.pos_format() : __mpf.pos_format();
          __sign =__intl ? __mpt.positive_sign() : __mpf.positive_sign();
        }
      else
        {
          __p = __intl ? __mpt.neg_format() : __mpf.neg_format();
          __sign =__intl ? __mpt.negative_sign() : __mpf.negative_sign();
          ++__beg;
        }


      __end = __ctype.scan_not(ctype_base::digit, __beg, __end);
      if (__beg != __end)
        {



          string_type __res;
          string_type __value;
          const string_type __symbol = __intl ? __mpt.curr_symbol()
                                              : __mpf.curr_symbol();


          const int __frac = __intl ? __mpt.frac_digits()
                                    : __mpf.frac_digits();
          if (__frac > 0)
            {
              const char_type __d = __intl ? __mpt.decimal_point()
                                           : __mpf.decimal_point();
              if (__end - __beg >= __frac)
                {
                  __value = string_type(__end - __frac, __end);
                  __value.insert(__value.begin(), __d);
                  __end -= __frac;
                }
              else
                {

                  __value = string_type(__beg, __end);
                  int __paddec = __frac - (__end - __beg);
                  char_type __zero = __ctype.widen('0');
                  __value.insert(__value.begin(), __paddec, __zero);
                  __value.insert(__value.begin(), __d);
                  __beg = __end;
                }
            }



          if (__beg != __end)
            {
              const string __grouping = __intl ? __mpt.grouping()
                                               : __mpf.grouping();
              if (__grouping.size())
                {
                  const char_type __sep = __intl ? __mpt.thousands_sep()
                                                 : __mpf.thousands_sep();
                  const char* __gbeg = __grouping.c_str();
                  const char* __gend = __gbeg + __grouping.size();
                  const int __n = (__end - __beg) * 2;
                  _CharT* __ws2 =
                  static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));
                  _CharT* __ws_end = __add_grouping(__ws2, __sep, __gbeg,
                                                    __gend, __beg, __end);
                  __value.insert(0, __ws2, __ws_end - __ws2);
                }
              else
                __value.insert(0, string_type(__beg, __end));
            }


          ios_base::fmtflags __f = __io.flags() & ios_base::adjustfield;
          size_type __len = __value.size() + __sign.size();
          __len += (__io.flags() & ios_base::showbase) ? __symbol.size() : 0;
          bool __testipad = __f == ios_base::internal && __len < __width;


          for (int __i = 0; __i < 4; ++__i)
            {
              part __which = static_cast<part>(__p.field[__i]);
              switch (__which)
                {
                case money_base::symbol:
                  if (__io.flags() & ios_base::showbase)
                    __res += __symbol;
                  break;
                case money_base::sign:



                  if (__sign.size())
                    __res += __sign[0];
                  break;
                case money_base::value:
                  __res += __value;
                  break;
                case money_base::space:



                  if (__testipad)
                    __res += string_type(__width - __len, __fill);
                  else
                    __res += __ctype.widen(__fill);
                  break;
                case money_base::none:
                  if (__testipad)
                    __res += string_type(__width - __len, __fill);
                  break;
                }
            }


          if (__sign.size() > 1)
            __res += string_type(__sign.begin() + 1, __sign.end());


          __len = __res.size();
          if (__width > __len)
            {
              if (__f == ios_base::left)

                __res.append(__width - __len, __fill);
              else

                __res.insert(0, string_type(__width - __len, __fill));
              __len = __width;
            }


          __s = __write(__s, __res.c_str(), __len);
        }
      __io.width(0);
      return __s;
    }





  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }

  template<typename _CharT, typename _InIter>
    void
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,
                          ios_base::iostate& __err, tm* __tm,
                          const _CharT* __format) const
    {
      locale __loc = __io.getloc();
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      size_t __len = char_traits<_CharT>::length(__format);

      for (size_t __i = 0; __beg != __end && __i < __len && !__err; ++__i)
        {
          char __c = __format[__i];
          if (__c == '%')
            {

              __c = __format[++__i];
              char __mod = 0;
              int __mem = 0;
              if (__c == 'E' || __c == 'O')
                {
                  __mod = __c;
                  __c = __format[++__i];
                }
              switch (__c)
                {
                  const char* __cs;
                  _CharT __wcs[10];
                case 'a':

                  const char_type* __days1[7];
                  __tp._M_days_abbreviated(__days1);
                  _M_extract_name(__beg, __end, __tm->tm_wday, __days1, 7,
                                  __err);
                  break;
                case 'A':

                  const char_type* __days2[7];
                  __tp._M_days(__days2);
                  _M_extract_name(__beg, __end, __tm->tm_wday, __days2, 7,
                                  __err);
                  break;
                case 'h':
                case 'b':

                  const char_type* __months1[12];
                  __tp._M_months_abbreviated(__months1);
                  _M_extract_name(__beg, __end, __tm->tm_mon, __months1, 12,
                                  __err);
                  break;
                case 'B':

                  const char_type* __months2[12];
                  __tp._M_months(__months2);
                  _M_extract_name(__beg, __end, __tm->tm_mon, __months2, 12,
                                  __err);
                  break;
                case 'c':

                  const char_type* __dt[2];
                  __tp._M_date_time_formats(__dt);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __dt[0]);
                  break;
                case 'd':

                  _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
                                 __ctype, __err);
                  break;
                case 'D':

                  __cs = "%m/%d/%y";
                  __ctype.widen(__cs, __cs + 9, __wcs);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __wcs);
                  break;
                case 'H':

                  _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
                                 __ctype, __err);
                  break;
                case 'I':

                  _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
                                 __ctype, __err);
                  break;
                case 'm':

                  _M_extract_num(__beg, __end, __mem, 1, 12, 2, __ctype,
                                 __err);
                  if (!__err)
                    __tm->tm_mon = __mem - 1;
                  break;
                case 'M':

                  _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
                                 __ctype, __err);
                  break;
                case 'n':
                  if (__ctype.narrow(*__beg, 0) == '\n')
                    ++__beg;
                  else
                    __err |= ios_base::failbit;
                  break;
                case 'R':

                  __cs = "%H:%M";
                  __ctype.widen(__cs, __cs + 6, __wcs);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __wcs);
                  break;
                case 'S':

                  _M_extract_num(__beg, __end, __tm->tm_sec, 0, 59, 2,
                                 __ctype, __err);
                  break;
                case 't':
                  if (__ctype.narrow(*__beg, 0) == '\t')
                    ++__beg;
                  else
                __err |= ios_base::failbit;
                  break;
                case 'T':

                  __cs = "%H:%M:%S";
                  __ctype.widen(__cs, __cs + 9, __wcs);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __wcs);
                  break;
                case 'x':

                  const char_type* __dates[2];
                  __tp._M_date_formats(__dates);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __dates[0]);
                  break;
                case 'X':

                  const char_type* __times[2];
                  __tp._M_time_formats(__times);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __times[0]);
                  break;
                case 'y':

                  _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
                                 __ctype, __err);
                  break;
                case 'Y':

                  _M_extract_num(__beg, __end, __mem, 0,
                                 numeric_limits<int>::max(), 4,
                                 __ctype, __err);
                  if (!__err)
                    __tm->tm_year = __mem - 1900;
                  break;
                case 'Z':

                  if (__ctype.is(ctype_base::upper, *__beg))
                    {
                      int __tmp;
                      _M_extract_name(__beg, __end, __tmp,
                                      __timepunct<_CharT>::_S_timezones,
                                      14, __err);


                      char_type __c = *__beg;
                      if (!__err && __tmp == 0
                          && (__c == __ctype.widen('-')
                              || __c == __ctype.widen('+')))
                        {
                          _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
                                          __ctype, __err);
                          _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
                                          __ctype, __err);
                        }
                          }
                      else
                        __err |= ios_base::failbit;
                      break;
                    default:

                      __err |= ios_base::failbit;
                    }
                }
              else
                {

                  if (__c == __ctype.narrow(*__beg, 0))
                    ++__beg;
                  else
                    __err |= ios_base::failbit;
                }
        }
    }

  template<typename _CharT, typename _InIter>
    void
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,
                   int __min, int __max, size_t __len,
                   const ctype<_CharT>& __ctype,
                   ios_base::iostate& __err) const
    {
      size_t __i = 0;
      string __digits;
      bool __testvalid = true;
      char_type __c = *__beg;
      while (__beg != __end && __i < __len
             && __ctype.is(ctype_base::digit, __c))
        {
          __digits += __ctype.narrow(__c, 0);
          __c = *(++__beg);
          ++__i;
        }
      if (__i == __len)
        {
          int __value = atoi(__digits.c_str());
          if (__min <= __value && __value <= __max)
            __member = __value;
          else
            __testvalid = false;
        }
      else
        __testvalid = false;
      if (!__testvalid)
        __err |= ios_base::failbit;
    }



  template<typename _CharT, typename _InIter>
    void
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,
                    const _CharT** __names, size_t __indexlen,
                    ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
                                                          * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;

      char_type __c = *__beg;

      for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
        if (__c == __names[__i1][0])
          __matches[__nmatches++] = __i1;

      while (__nmatches > 1)
        {

          size_t __minlen = 10;
          for (size_t __i2 = 0; __i2 < __nmatches; ++__i2)
            __minlen = min(__minlen,
                           __traits_type::length(__names[__matches[__i2]]));

          if (__pos < __minlen && __beg != __end)
            {
              ++__pos;
              __c = *(++__beg);
              for (size_t __i3 = 0; __i3 < __nmatches; ++__i3)
                {
                  __name = __names[__matches[__i3]];
                  if (__name[__pos] != __c)
                    __matches[__i3] = __matches[--__nmatches];
                }
            }
          else
            break;
        }

      if (__nmatches == 1)
        {

          __name = __names[__matches[0]];
          const size_t __len = __traits_type::length(__name);
          while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
            ++__beg, ++__pos;

          if (__len == __pos)
            __member = __matches[0];
          else
            __testvalid = false;
        }
      else
        __testvalid = false;
      if (!__testvalid)
        __err |= ios_base::failbit;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
                ios_base::iostate& __err, tm* __tm) const
    {
      _CharT __wcs[3];
      const char* __cs = "%X";
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __ctype.widen(__cs, __cs + 3, __wcs);
      _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
                ios_base::iostate& __err, tm* __tm) const
    {
      _CharT __wcs[3];
      const char* __cs = "%x";
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __ctype.widen(__cs, __cs + 3, __wcs);
      _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
                   ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      locale __loc = __io.getloc();
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      _M_extract_name(__beg, __end, __tmpwday, __days, 7, __err);







      if (!__err)
        {
          size_t __pos = __traits_type::length(__days[__tmpwday]);
          __tp._M_days(__days);
          const char_type* __name = __days[__tmpwday];
          if (__name[__pos] == *__beg)
            {

              const size_t __len = __traits_type::length(__name);
              while (__pos < __len && __beg != __end
                     && __name[__pos] == *__beg)
                ++__beg, ++__pos;
              if (__len != __pos)
                __err |= ios_base::failbit;
            }
          if (!__err)
            __tm->tm_wday = __tmpwday;
        }
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      locale __loc = __io.getloc();
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      _M_extract_name(__beg, __end, __tmpmon, __months, 12, __err);







      if (!__err)
        {
          size_t __pos = __traits_type::length(__months[__tmpmon]);
          __tp._M_months(__months);
          const char_type* __name = __months[__tmpmon];
          if (__name[__pos] == *__beg)
            {

              const size_t __len = __traits_type::length(__name);
              while (__pos < __len && __beg != __end
                     && __name[__pos] == *__beg)
                ++__beg, ++__pos;
              if (__len != __pos)
                __err |= ios_base::failbit;
            }
          if (!__err)
            __tm->tm_mon = __tmpmon;
        }

      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
                ios_base::iostate& __err, tm* __tm) const
    {
      locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      char_type __c = *__beg;
      size_t __i = 0;
      string __digits;
      while (__i < 4 && __beg != __end && __ctype.is(ctype_base::digit, __c))
        {
          __digits += __ctype.narrow(__c, 0);
          __c = *(++__beg);
          ++__i;
        }
      if (__i == 2 || __i == 4)
        {
          long __l;
          __convert_to_v(__digits.c_str(), __l, __err, _S_c_locale);
          if (!(__err & ios_base::failbit) && __l <= 2147483647)
            {
              __l = __i == 2 ? __l : __l - 1900;
              __tm->tm_year = static_cast<int>(__l);
            }
        }
      else
        __err |= ios_base::failbit;
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
        const _CharT* __beg, const _CharT* __end) const
    {
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      while (__beg != __end)
        {
          char __c = __ctype.narrow(*__beg, 0);
          ++__beg;
          if (__c == '%')
            {
              char __format;
              char __mod = 0;
              size_t __len = 1;
              __c = __ctype.narrow(*__beg, 0);
              ++__beg;
              if (__c == 'E' || __c == 'O')
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__beg, 0);
                  ++__beg;
                }
              else
                __format = __c;
              __s = this->do_put(__s, __io, _CharT(), __tm, __format, __mod);
            }
          else
            {
              *__s = __c;
              ++__s;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
           char __format, char __mod) const
    {
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 64;
      char_type* __res = static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return __write(__s, __res, char_traits<char_type>::length(__res));
    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
               const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.c_str() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.c_str() + __two.length();




      for (;;)
        {
          int __res = _M_compare(__p, __q);
          if (__res)
            return __res;

          __p += char_traits<_CharT>::length(__p);
          __q += char_traits<_CharT>::length(__q);
          if (__p == __pend && __q == __qend)
            return 0;
          else if (__p == __pend)
            return -1;
          else if (__q == __qend)
            return 1;

          __p++;
          __q++;
        }
    }

 template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {

      string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.c_str() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      string_type __ret;




      for (;;)
        {

          _CharT* __c =
            static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __len));
          size_t __res = _M_transform(__c, __p, __len);


          if (__res >= __len)
            {
              __len = __res + 1;
              __c = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                          * __len));
              __res = _M_transform(__c, __p, __res + 1);
            }

          __ret.append(__c, __res);
          __p += char_traits<_CharT>::length(__p);
          if (__p == __pend)
            return __ret;

          __p++;
          __ret.push_back(_CharT());
        }
    }

 template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
        __val = *__lo + ((__val << 7) |
                       (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }
# 2165 "/usr/include/c++/3.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
                                   _CharT* __news, const _CharT* __olds,
                                   const streamsize __newlen,
                                   const streamsize __oldlen, const bool __num)
    {
      size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                             * __plen));
      _Traits::assign(__pads, __plen, __fill);

      _CharT* __beg;
      _CharT* __end;
      size_t __mod = 0;
      size_t __beglen;
      ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;

      if (__adjust == ios_base::left)
        {

          __beg = const_cast<_CharT*>(__olds);
          __beglen = __oldlen;
          __end = __pads;
        }
      else if (__adjust == ios_base::internal && __num)
        {



          locale __loc = __io.getloc();
          const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
          const _CharT __minus = __ctype.widen('-');
          const _CharT __plus = __ctype.widen('+');
          bool __testsign = _Traits::eq(__olds[0], __minus)
                            || _Traits::eq(__olds[0], __plus);

          bool __testhex = _Traits::eq(__ctype.widen('0'), __olds[0])
                           && (_Traits::eq(__ctype.widen('x'), __olds[1])
                               || _Traits::eq(__ctype.widen('X'), __olds[1]));
          if (__testhex)
            {
              __news[0] = __olds[0];
              __news[1] = __olds[1];
              __mod += 2;
              __news += 2;
              __beg = __pads;
              __beglen = __plen;
              __end = const_cast<_CharT*>(__olds + __mod);
            }
          else if (__testsign)
            {
              _Traits::eq((__news[0] = __olds[0]), __plus) ? __plus : __minus;
              ++__mod;
              ++__news;
              __beg = __pads;
              __beglen = __plen;
              __end = const_cast<_CharT*>(__olds + __mod);
            }
          else
            {

              __beg = __pads;
              __beglen = __plen;
              __end = const_cast<_CharT*>(__olds);
            }
        }
      else
        {

          __beg = __pads;
          __beglen = __plen;
          __end = const_cast<_CharT*>(__olds);
        }
      _Traits::copy(__news, __beg, __beglen);
      _Traits::copy(__news + __beglen, __end,
                          __newlen - __beglen - __mod);
    }

  template<typename _CharT>
    bool
    __verify_grouping(const basic_string<_CharT>& __grouping,
                      basic_string<_CharT>& __grouping_tmp)
    {
      int __i = 0;
      int __j = 0;
      const int __len = __grouping.size();
      const int __n = __grouping_tmp.size();
      bool __test = true;




      while (__test && __i < __n - 1)
        for (__j = 0; __test && __j < __len && __i < __n - 1; ++__j,++__i)
          __test &= __grouping[__j] == __grouping_tmp[__n - __i - 1];


      __j == __len ? __j = 0 : __j;
      __test &= __grouping[__j] >= __grouping_tmp[__n - __i - 1];
      return __test;
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
                   const char* __gbeg, const char* __gend,
                   const _CharT* __first, const _CharT* __last)
    {
      if (__last - __first > *__gbeg)
        {
          __s = __add_grouping(__s, __sep,
                               (__gbeg + 1 == __gend ? __gbeg : __gbeg + 1),
                               __gend, __first, __last - *__gbeg);
          __first = __last - *__gbeg;
          *__s++ = __sep;
        }
      do
        *__s++ = *__first++;
      while (__first != __last);
      return __s;
    }



  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_convert_int(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
                     char __modl, _ValueT __v) const
      {



        char __fbuf[16];
        _S_format_int(__io, __fbuf, __mod, __modl);


        int __cs_size = 64;
        char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
        int __len = __convert_from_v(__cs, __cs_size, __fbuf, __v,
                                     _S_c_locale);

        if (__len >= __cs_size)
          {
            __cs_size = __len + 1;
            __cs = static_cast<char*>(__builtin_alloca(__cs_size));
            __len = __convert_from_v(__cs, __cs_size, __fbuf, __v,
                                     _S_c_locale);
          }






        return _M_widen_int(__s, __io, __fill, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    _M_widen_float(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs,
                   int __len) const
    {
      typedef char_traits<_CharT> __traits_type;


      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __len));


      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __len * 2));
      __ctype.widen(__cs, __cs + __len, __ws);


      const _CharT* __p;
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      if (__p = __traits_type::find(__ws, __len, __ctype.widen('.')))
        __ws[__p - __ws] = __np.decimal_point();




      const string __grouping = __np.grouping();
      if (__grouping.size())
        {
          _CharT* __p2;
          int __declen = __p ? __p - __ws : __len;
          __p2 = __add_grouping(__ws2, __np.thousands_sep(),
                                __grouping.c_str(),
                                __grouping.c_str() + __grouping.size(),
                                __ws, __ws + __declen);
          int __newlen = __p2 - __ws2;


          if (__p)
            {
              __traits_type::copy(__p2, __p, __len - __declen);
              __newlen += __len - __declen;
            }


          __ws = __ws2;
          __len = __newlen;
        }

      return _M_insert(__s, __io, __fill, __ws, __len);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    _M_widen_int(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs,
                 int __len) const
    {


      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __len));


      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __len * 2));
      __ctype.widen(__cs, __cs + __len, __ws);


      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      const string __grouping = __np.grouping();
      if (__grouping.size())
        {





          streamsize __off = 0;
          const ios_base::fmtflags __basefield = __io.flags()
                                                 & ios_base::basefield;
          if ((__io.flags() & ios_base::showbase) && __len > 1)
            if (__basefield == ios_base::oct)
              {
                __off = 1;
                *__ws2 = *__ws;
              }
            else if (__basefield == ios_base::hex)
              {
                __off = 2;
                *__ws2 = *__ws;
                *(__ws2 + 1) = *(__ws + 1);
              }
          _CharT* __p;
          __p = __add_grouping(__ws2 + __off, __np.thousands_sep(),
                               __grouping.c_str(),
                               __grouping.c_str() + __grouping.size(),
                               __ws + __off, __ws + __len);
          __len = __p - __ws2;

          __ws = __ws2;
        }
      return _M_insert(__s, __io, __fill, __ws, __len);
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    _M_insert(_OutIter __s, ios_base& __io, _CharT __fill, const _CharT* __ws,
              int __len) const
    {
      typedef char_traits<_CharT> __traits_type;


      streamsize __w = __io.width();
      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __w));
      if (__w > static_cast<streamsize>(__len))
        {
          __pad<_CharT, __traits_type>::_S_pad(__io, __fill, __ws2, __ws,
                                               __w, __len, true);
          __len = static_cast<int>(__w);

          __ws = __ws2;
        }
      __io.width(0);



      return __write(__s, __ws, __len);
    }


  template<typename _CharT>
    __locale_cache<numpunct<_CharT> >::__locale_cache(const locale& __loc)
      : _M_truename(0), _M_falsename(0), _M_use_grouping(false),
        _M_grouping(0)
    {
      if (has_facet<numpunct<_CharT> >(__loc))
        {
          const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
          _M_decimal_point = __np.decimal_point();
          _M_thousands_sep = __np.thousands_sep();

          string_type __false = __np.falsename();
          _CharT* __falsename = new _CharT[__false.length() + 1];
          __false.copy(__falsename, __false.length());
          __falsename[__false.length()] = _CharT();
          _M_falsename = __falsename;

          string_type __true = __np.truename();
          _CharT* __truename = new _CharT[__true.length() + 1];
          __true.copy(__truename, __true.length());
          __truename[__true.length()] = _CharT();
          _M_truename = __truename;

          string __grouping = __np.grouping();
          char* __group = new char[__grouping.length() + 1];
          __grouping.copy(__group, __grouping.length());
          __group[__grouping.length()] = 0;
          _M_grouping = __group;

          _M_use_grouping = __grouping.length() != 0
            && __grouping.data()[0] != 0;
        }

      if (has_facet<ctype<_CharT> >(__loc))
        {
          const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
          __ct.widen(__num_base::_S_atoms_out,
                     __num_base::_S_atoms_out + __num_base::_S_end,
                     _M_atoms_out);
        }
    }



  template<typename _CharT>
    __locale_cache<numpunct<_CharT> >::
    __locale_cache(const locale& __loc, bool)
    {

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      _M_thousands_sep = __np._M_thousands_sep;
      _M_decimal_point = __np._M_decimal_point;
      _M_falsename = __np._M_falsename;
      _M_truename = __np._M_truename;
      _M_grouping = __np._M_grouping;
      _M_use_grouping = false;

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
                 __num_base::_S_atoms_out + __num_base::_S_end,
                 _M_atoms_out);
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class ctype_byname<char>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;
  extern template class ctype_byname<wchar_t>;
  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);


}
# 48 "/usr/include/c++/3.3/locale" 2 3
# 38 "/usr/include/c++/3.3/bits/ostream.tcc" 2 3

namespace std
{
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT,_Traits>& __os)
    : _M_os(__os)
    {

      if (__os.tie() && __os.good())
        __os.tie()->flush();

      if (__os.good())
        _M_ok = true;
      else
        {
          _M_ok = false;
          __os.setstate(ios_base::failbit);
        }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ostream_type& (*__pf)(__ostream_type&))
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            { __pf(*this); }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ios_type& (*__pf)(__ios_type&))
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            { __pf(*this); }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(ios_base& (*__pf)(ios_base&))
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            { __pf(*this); }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(__streambuf_type* __sbin)
    {
      sentry __cerb(*this);
      if (__cerb && __sbin)
        {
          if (true)
            {
              if (!__copy_streambufs(*this, __sbin, this->rdbuf()))
                this->setstate(ios_base::failbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      else if (!__sbin)
        this->setstate(ios_base::badbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(bool __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            {
              char_type __c = this->fill();
              ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
              if (_M_check_facet(_M_fnumput))
                {
                  bool __b = false;
                  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
                    {
                      unsigned long __l = static_cast<unsigned long>(__n);
                      __b = _M_fnumput->put(*this, *this, __c, __l).failed();
                    }
                  else
                    __b = _M_fnumput->put(*this, *this, __c, __n).failed();
                  if (__b)
                    this->setstate(ios_base::badbit);
                }
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            {
              char_type __c = this->fill();
              ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
              if (_M_check_facet(_M_fnumput))
                {
                  bool __b = false;
                  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
                    {
                      unsigned long long __l;
                      __l = static_cast<unsigned long long>(__n);
                      __b = _M_fnumput->put(*this, *this, __c, __l).failed();
                    }
                  else
                    __b = _M_fnumput->put(*this, *this, __c, __n).failed();
                  if (__b)
                    this->setstate(ios_base::badbit);
                }
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(long double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (true)
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::put(char_type __c)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          int_type __put = rdbuf()->sputc(__c);
          if (traits_type::eq_int_type(__put, traits_type::eof()))
            this->setstate(ios_base::badbit);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::write(const _CharT* __s, streamsize __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          streamsize __put = this->rdbuf()->sputn(__s, __n);
          if ( __put != __n)
            this->setstate(ios_base::badbit);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::flush()
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
            this->setstate(ios_base::badbit);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::tellp()
    {
      pos_type __ret = pos_type(-1);
      if (!this->fail())
        __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
    {
      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekpos(__pos, ios_base::out);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __d)
    {
      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekoff(__off, __d,
                                                     ios_base::out);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          if (true)
            {
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__w + 1)));
              __pads[0] = __c;
              streamsize __len = 1;
              if (__w > __len)
                {
                  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                                 &__c, __w, __len, false);
                  __len = __w;
                }
              __out.write(__pads, __len);
              __out.width(0);
            }
          if (false)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return __out;
    }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          if (true)
            {
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              char* __pads = static_cast<char*>(__builtin_alloca(__w + 1));
              __pads[0] = __c;
              streamsize __len = 1;
              if (__w > __len)
                {
                  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                               &__c, __w, __len, false);
                  __len = __w;
                }
              __out.write(__pads, __len);
              __out.width(0);
            }
          if (false)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return __out;
     }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
        {
          if (true)
            {
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
              streamsize __len = static_cast<streamsize>(_Traits::length(__s));
              if (__w > __len)
                {
                  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                                 __s, __w, __len, false);
                  __s = __pads;
                  __len = __w;
                }
              __out.write(__s, __len);
              __out.width(0);
            }
          if (false)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      else if (!__s)
        __out.setstate(ios_base::badbit);
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;



      typedef char_traits<char> __traits_type;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
        {
          size_t __clen = __traits_type::length(__s);
          _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__clen + 1)));
          for (size_t __i = 0; __i < __clen; ++__i)
            __ws[__i] = __out.widen(__s[__i]);
          _CharT* __str = __ws;

          if (true)
            {
              streamsize __len = static_cast<streamsize>(__clen);
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));

              if (__w > __len)
                {
                  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                                 __ws, __w, __len, false);
                  __str = __pads;
                  __len = __w;
                }
              __out.write(__str, __len);
              __out.width(0);
            }
          if (false)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      else if (!__s)
        __out.setstate(ios_base::badbit);
      return __out;
    }


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
        {
          if (true)
            {
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              char* __pads = static_cast<char*>(__builtin_alloca(__w));
              streamsize __len = static_cast<streamsize>(_Traits::length(__s));

              if (__w > __len)
                {
                  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                                 __s, __w, __len, false);
                  __s = __pads;
                  __len = __w;
                }
              __out.write(__s, __len);
              __out.width(0);
            }
          if (false)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      else if (!__s)
        __out.setstate(ios_base::badbit);
      return __out;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out,
               const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          const _CharT* __s = __str.data();
          const streamsize __w = __out.width() > 0 ? __out.width() : 0;
          _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
          streamsize __len = static_cast<streamsize>(__str.size());



          if (__w > __len)
            {
              __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, __s,
                                             __w, __len, false);
              __s = __pads;
              __len = __w;
            }
          streamsize __res = __out.rdbuf()->sputn(__s, __len);
          __out.width(0);
          if (__res != __len)
            __out.setstate(ios_base::failbit);
        }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);


}
# 536 "/usr/include/c++/3.3/ostream" 2 3
# 46 "/usr/include/c++/3.3/iostream" 2 3
# 1 "/usr/include/c++/3.3/istream" 1 3
# 42 "/usr/include/c++/3.3/istream" 3
       
# 43 "/usr/include/c++/3.3/istream" 3




namespace std
{
# 57 "/usr/include/c++/3.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef istreambuf_iterator<_CharT, _Traits> __istreambuf_iter;
      typedef num_get<_CharT, __istreambuf_iter> __numget_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

    protected:







      streamsize _M_gcount;

    public:
# 103 "/usr/include/c++/3.3/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      {
        this->init(__sb);
        _M_gcount = streamsize(0);
      }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 133 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&));

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&));

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&));
# 171 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      operator>>(bool& __n);

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n);

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n);

      __istream_type&
      operator>>(long& __n);

      __istream_type&
      operator>>(unsigned long& __n);


      __istream_type&
      operator>>(long long& __n);

      __istream_type&
      operator>>(unsigned long long& __n);


      __istream_type&
      operator>>(float& __f);

      __istream_type&
      operator>>(double& __f);

      __istream_type&
      operator>>(long double& __f);

      __istream_type&
      operator>>(void*& __p);
# 232 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 242 "/usr/include/c++/3.3/istream" 3
      inline streamsize
      gcount() const
      { return _M_gcount; }
# 274 "/usr/include/c++/3.3/istream" 3
      int_type
      get();
# 288 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      get(char_type& __c);
# 315 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 326 "/usr/include/c++/3.3/istream" 3
      inline __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 349 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 359 "/usr/include/c++/3.3/istream" 3
      inline __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 388 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 399 "/usr/include/c++/3.3/istream" 3
      inline __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 418 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      ignore(streamsize __n = 1, int_type __delim = traits_type::eof());
# 429 "/usr/include/c++/3.3/istream" 3
      int_type
      peek();
# 447 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 466 "/usr/include/c++/3.3/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 482 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      putback(char_type __c);
# 497 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      unget();
# 515 "/usr/include/c++/3.3/istream" 3
      int
      sync();
# 529 "/usr/include/c++/3.3/istream" 3
      pos_type
      tellg();
# 544 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      seekg(pos_type);
# 560 "/usr/include/c++/3.3/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);

    };
# 576 "/usr/include/c++/3.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 608 "/usr/include/c++/3.3/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 618 "/usr/include/c++/3.3/istream" 3
      operator bool() { return _M_ok; }

    private:
      bool _M_ok;
    };
# 637 "/usr/include/c++/3.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 678 "/usr/include/c++/3.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 700 "/usr/include/c++/3.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;



      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb)
      { }




      virtual
      ~basic_iostream() { }
    };
# 759 "/usr/include/c++/3.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
}





# 1 "/usr/include/c++/3.3/bits/istream.tcc" 1 3
# 35 "/usr/include/c++/3.3/bits/istream.tcc" 3
       
# 36 "/usr/include/c++/3.3/bits/istream.tcc" 3




namespace std
{
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskipws)
    {
      if (__in.good())
        {
          if (__in.tie())
            __in.tie()->flush();
          if (!__noskipws && (__in.flags() & ios_base::skipws))
            {
              const __int_type __eof = traits_type::eof();
              __streambuf_type* __sb = __in.rdbuf();
              __int_type __c = __sb->sgetc();

              if (__in._M_check_facet(__in._M_fctype))
                while (!traits_type::eq_int_type(__c, __eof)
                       && __in._M_fctype->is(ctype_base::space,
                                             traits_type::to_char_type(__c)))
                  __c = __sb->snextc();



              if (traits_type::eq_int_type(__c, __eof))
                __in.setstate(ios_base::eofbit);

            }
        }

      if (__in.good())
        _M_ok = true;
      else
        {
          _M_ok = false;
          __in.setstate(ios_base::failbit);
        }
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__istream_type& (*__pf)(__istream_type&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__ios_type& (*__pf)(__ios_type&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(ios_base& (*__pf)(ios_base&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(bool& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              long __l;
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __l);


              if (!(__err & ios_base::failbit)
                  && (numeric_limits<short>::min() <= __l
                      && __l <= numeric_limits<short>::max()))
                __n = __l;
              else
                __err |= ios_base::failbit;

              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              long __l;
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __l);


              if (!(__err & ios_base::failbit)
                  && (numeric_limits<int>::min() <= __l
                      && __l <= numeric_limits<int>::max()))
                __n = __l;
              else
                __err |= ios_base::failbit;

              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
              ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(float& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(void*& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          if (true)
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
       sentry __cerb(*this, false);
       if (__cerb)
         {
           if (true)
             {
               streamsize __xtrct = 0;
               if (__sbout)
                 {
                   __streambuf_type* __sbin = this->rdbuf();
                   __xtrct = __copy_streambufs(*this, __sbin, __sbout);
                 }
               if (!__sbout || !__xtrct)
                 this->setstate(ios_base::failbit);
             }
           if (false)
             {


               this->_M_setstate(ios_base::badbit);
               if ((this->exceptions() & ios_base::badbit) != 0)
                 ;
             }
         }
       return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              __c = this->rdbuf()->sbumpc();

              if (!traits_type::eq_int_type(__c, __eof))
                _M_gcount = 1;
              else
                this->setstate(ios_base::eofbit | ios_base::failbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __eof = traits_type::eof();
              int_type __bufval = this->rdbuf()->sbumpc();

              if (!traits_type::eq_int_type(__bufval, __eof))
                {
                  _M_gcount = 1;
                  __c = traits_type::to_char_type(__bufval);
                }
              else
                this->setstate(ios_base::eofbit | ios_base::failbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                this->setstate(ios_base::eofbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      *__s = char_type();
      if (!_M_gcount)
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __this_sb = this->rdbuf();
              int_type __c = __this_sb->sgetc();
              char_type __c2 = traits_type::to_char_type(__c);

              while (!traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim)
                     && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
                {
                  ++_M_gcount;
                  __c = __this_sb->snextc();
                  __c2 = traits_type::to_char_type(__c);
                }
              if (traits_type::eq_int_type(__c, __eof))
                this->setstate(ios_base::eofbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      if (!_M_gcount)
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                this->setstate(ios_base::eofbit);
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    this->setstate(ios_base::failbit);
                }
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      *__s = char_type();
      if (!_M_gcount)
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c;

              __n = min(__n, numeric_limits<streamsize>::max());
              while (_M_gcount < __n
                     && !traits_type::eq_int_type(__c = __sb->sbumpc(), __eof))
                {
                  ++_M_gcount;
                  if (traits_type::eq_int_type(__c, __delim))
                    break;
                }
              if (traits_type::eq_int_type(__c, __eof))
                this->setstate(ios_base::eofbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            { __c = this->rdbuf()->sgetc(); }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              _M_gcount = this->rdbuf()->sgetn(__s, __n);
              if (_M_gcount != __n)
                this->setstate(ios_base::eofbit | ios_base::failbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {

              streamsize __num = this->rdbuf()->in_avail();
              if (__num >= 0)
                {
                  __num = min(__num, __n);
                  if (__num)
                    _M_gcount = this->rdbuf()->sgetn(__s, __num);
                }
              else
                this->setstate(ios_base::eofbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              if (!__sb
                  || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
                this->setstate(ios_base::badbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              if (!__sb
                  || traits_type::eq_int_type(__sb->sungetc(), __eof))
                this->setstate(ios_base::badbit);
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {

      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          if (true)
            {
              __streambuf_type* __sb = this->rdbuf();
              if (__sb)
                {
                  if (__sb->pubsync() == -1)
                    this->setstate(ios_base::badbit);
                  else
                    __ret = 0;
                }
            }
          if (false)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {

      pos_type __ret = pos_type(-1);
      if (!this->fail())
        __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {

      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekpos(__pos, ios_base::in);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {

      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekoff(__off, __dir,
                                                     ios_base::in);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
        {
          if (true)
            { __in.get(__c); }
          if (false)
            {


              __in._M_setstate(ios_base::badbit);
              if ((__in.exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      else
        __in.setstate(ios_base::failbit);
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;
      streamsize __extracted = 0;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
        {
          if (true)
            {

              streamsize __num = __in.width();
              if (__num <= 0)
                __num = numeric_limits<streamsize>::max();

              const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
              const int_type __eof = _Traits::eof();
              __streambuf_type* __sb = __in.rdbuf();
              int_type __c = __sb->sgetc();

              while (__extracted < __num - 1
                     && !_Traits::eq_int_type(__c, __eof)
                     && !__ctype.is(ctype_base::space, _Traits::to_char_type(__c)))
                {
                  *__s++ = _Traits::to_char_type(__c);
                  ++__extracted;
                  __c = __sb->snextc();
                }
              if (_Traits::eq_int_type(__c, __eof))
                __in.setstate(ios_base::eofbit);



              *__s = char_type();

              __in.width(0);
            }
          if (false)
            {


              __in._M_setstate(ios_base::badbit);
              if ((__in.exceptions() & ios_base::badbit) != 0)
                ;
            }
        }
      if (!__extracted)
        __in.setstate(ios_base::failbit);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;

      const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
             && __ctype.is(ctype_base::space, _Traits::to_char_type(__c)))
        __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
        __in.setstate(ios_base::eofbit);

      return __in;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
               basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __size_type __extracted = 0;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
        {
          __str.erase();
          streamsize __w = __in.width();
          __size_type __n;
          __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();

          const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
          const __int_type __eof = _Traits::eof();
          __streambuf_type* __sb = __in.rdbuf();
          __int_type __c = __sb->sgetc();

          while (__extracted < __n
                 && !_Traits::eq_int_type(__c, __eof)
                 && !__ctype.is(ctype_base::space, _Traits::to_char_type(__c)))
            {
              __str += _Traits::to_char_type(__c);
              ++__extracted;
              __c = __sb->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            __in.setstate(ios_base::eofbit);
          __in.width(0);
        }


      if (!__extracted)
        __in.setstate (ios_base::failbit);

      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
            basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      bool __testdelim = false;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
        {
          __str.erase();
          __size_type __n = __str.max_size();

          __int_type __idelim = _Traits::to_int_type(__delim);
          __streambuf_type* __sb = __in.rdbuf();
          __int_type __c = __sb->sbumpc();
          const __int_type __eof = _Traits::eof();
          __testdelim = _Traits::eq_int_type(__c, __idelim);

          while (__extracted <= __n
                 && !_Traits::eq_int_type(__c, __eof)
                 && !__testdelim)
            {
              __str += _Traits::to_char_type(__c);
              ++__extracted;
              __c = __sb->sbumpc();
              __testdelim = _Traits::eq_int_type(__c, __idelim);
            }
          if (_Traits::eq_int_type(__c, __eof))
            __in.setstate(ios_base::eofbit);
        }
      if (!__extracted && !__testdelim)
        __in.setstate(ios_base::failbit);
      return __in;
    }

  template<class _CharT, class _Traits, class _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
            basic_string<_CharT,_Traits,_Alloc>& __str)
    { return getline(__in, __str, __in.widen('\n')); }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);


}
# 769 "/usr/include/c++/3.3/istream" 2 3
# 47 "/usr/include/c++/3.3/iostream" 2 3

namespace std
{
# 63 "/usr/include/c++/3.3/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;
}
# 38 "/usr/include/gtk++/gtypedefs.hpp" 2 3 4

# 1 "/usr/include/glib-2.0/glib.h" 1 3 4
# 30 "/usr/include/glib-2.0/glib.h" 3 4
# 1 "/usr/include/glib-2.0/glib/galloca.h" 1 3 4
# 30 "/usr/include/glib-2.0/glib/galloca.h" 3 4
# 1 "/usr/include/glib-2.0/glib/gtypes.h" 1 3 4
# 30 "/usr/include/glib-2.0/glib/gtypes.h" 3 4
# 1 "/usr/lib/glib-2.0/include/glibconfig.h" 1 3 4
# 9 "/usr/lib/glib-2.0/include/glibconfig.h" 3 4
# 1 "/usr/include/glib-2.0/glib/gmacros.h" 1 3 4
# 36 "/usr/include/glib-2.0/glib/gmacros.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 37 "/usr/include/glib-2.0/glib/gmacros.h" 2 3 4
# 10 "/usr/lib/glib-2.0/include/glibconfig.h" 2 3 4

# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/limits.h" 1 3 4
# 12 "/usr/lib/glib-2.0/include/glibconfig.h" 2 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/float.h" 1 3 4
# 13 "/usr/lib/glib-2.0/include/glibconfig.h" 2 3 4




# 36 "/usr/lib/glib-2.0/include/glibconfig.h" 3 4
typedef signed char gint8;
typedef unsigned char guint8;
typedef signed short gint16;
typedef unsigned short guint16;


typedef signed int gint32;
typedef unsigned int guint32;




 typedef signed long long gint64;
 typedef unsigned long long guint64;
# 59 "/usr/lib/glib-2.0/include/glibconfig.h" 3 4
typedef signed int gssize;
typedef unsigned int gsize;
# 113 "/usr/lib/glib-2.0/include/glibconfig.h" 3 4
typedef struct _GStaticMutex GStaticMutex;
struct _GStaticMutex
{
  struct _GMutex *runtime_mutex;
  union {
    char pad[24];
    double dummy_double;
    void *dummy_pointer;
    long dummy_long;
  } static_mutex;
};






typedef union _GSystemThread GSystemThread;
union _GSystemThread
{
  char data[4];
  double dummy_double;
  void *dummy_pointer;
  long dummy_long;
};
# 170 "/usr/lib/glib-2.0/include/glibconfig.h" 3 4

# 31 "/usr/include/glib-2.0/glib/gtypes.h" 2 3 4


# 41 "/usr/include/glib-2.0/glib/gtypes.h" 3 4
typedef char gchar;
typedef short gshort;
typedef long glong;
typedef int gint;
typedef gint gboolean;

typedef unsigned char guchar;
typedef unsigned short gushort;
typedef unsigned long gulong;
typedef unsigned int guint;

typedef float gfloat;
typedef double gdouble;
# 66 "/usr/include/glib-2.0/glib/gtypes.h" 3 4
typedef void* gpointer;
typedef const void *gconstpointer;

typedef gint (*GCompareFunc) (gconstpointer a,
                                                 gconstpointer b);
typedef gint (*GCompareDataFunc) (gconstpointer a,
                                                 gconstpointer b,
                                                 gpointer user_data);
typedef gboolean (*GEqualFunc) (gconstpointer a,
                                                 gconstpointer b);
typedef void (*GDestroyNotify) (gpointer data);
typedef void (*GFunc) (gpointer data,
                                                 gpointer user_data);
typedef guint (*GHashFunc) (gconstpointer key);
typedef void (*GHFunc) (gpointer key,
                                                 gpointer value,
                                                 gpointer user_data);
typedef void (*GFreeFunc) (gpointer data);
# 329 "/usr/include/glib-2.0/glib/gtypes.h" 3 4
typedef union _GDoubleIEEE754 GDoubleIEEE754;
typedef union _GFloatIEEE754 GFloatIEEE754;





union _GFloatIEEE754
{
  gfloat v_float;
  struct {
    guint mantissa : 23;
    guint biased_exponent : 8;
    guint sign : 1;
  } mpn;
};
union _GDoubleIEEE754
{
  gdouble v_double;
  struct {
    guint mantissa_low : 32;
    guint mantissa_high : 20;
    guint biased_exponent : 11;
    guint sign : 1;
  } mpn;
};
# 379 "/usr/include/glib-2.0/glib/gtypes.h" 3 4
typedef struct _GTimeVal GTimeVal;

struct _GTimeVal
{
  glong tv_sec;
  glong tv_usec;
};


# 31 "/usr/include/glib-2.0/glib/galloca.h" 2 3 4
# 31 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/garray.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/garray.h" 3 4


typedef struct _GArray GArray;
typedef struct _GByteArray GByteArray;
typedef struct _GPtrArray GPtrArray;

struct _GArray
{
  gchar *data;
  guint len;
};

struct _GByteArray
{
  guint8 *data;
  guint len;
};

struct _GPtrArray
{
  gpointer *pdata;
  guint len;
};
# 66 "/usr/include/glib-2.0/glib/garray.h" 3 4
GArray* g_array_new (gboolean zero_terminated,
                                   gboolean clear_,
                                   guint element_size);
GArray* g_array_sized_new (gboolean zero_terminated,
                                   gboolean clear_,
                                   guint element_size,
                                   guint reserved_size);
gchar* g_array_free (GArray *array,
                                   gboolean free_segment);
GArray* g_array_append_vals (GArray *array,
                                   gconstpointer data,
                                   guint len);
GArray* g_array_prepend_vals (GArray *array,
                                   gconstpointer data,
                                   guint len);
GArray* g_array_insert_vals (GArray *array,
                                   guint index_,
                                   gconstpointer data,
                                   guint len);
GArray* g_array_set_size (GArray *array,
                                   guint length);
GArray* g_array_remove_index (GArray *array,
                                   guint index_);
GArray* g_array_remove_index_fast (GArray *array,
                                   guint index_);
void g_array_sort (GArray *array,
                                   GCompareFunc compare_func);
void g_array_sort_with_data (GArray *array,
                                   GCompareDataFunc compare_func,
                                   gpointer user_data);






GPtrArray* g_ptr_array_new (void);
GPtrArray* g_ptr_array_sized_new (guint reserved_size);
gpointer* g_ptr_array_free (GPtrArray *array,
                                           gboolean free_seg);
void g_ptr_array_set_size (GPtrArray *array,
                                           gint length);
gpointer g_ptr_array_remove_index (GPtrArray *array,
                                           guint index_);
gpointer g_ptr_array_remove_index_fast (GPtrArray *array,
                                           guint index_);
gboolean g_ptr_array_remove (GPtrArray *array,
                                           gpointer data);
gboolean g_ptr_array_remove_fast (GPtrArray *array,
                                           gpointer data);
void g_ptr_array_add (GPtrArray *array,
                                           gpointer data);
void g_ptr_array_sort (GPtrArray *array,
                                           GCompareFunc compare_func);
void g_ptr_array_sort_with_data (GPtrArray *array,
                                           GCompareDataFunc compare_func,
                                           gpointer user_data);






GByteArray* g_byte_array_new (void);
GByteArray* g_byte_array_sized_new (guint reserved_size);
guint8* g_byte_array_free (GByteArray *array,
                                            gboolean free_segment);
GByteArray* g_byte_array_append (GByteArray *array,
                                            const guint8 *data,
                                            guint len);
GByteArray* g_byte_array_prepend (GByteArray *array,
                                            const guint8 *data,
                                            guint len);
GByteArray* g_byte_array_set_size (GByteArray *array,
                                            guint length);
GByteArray* g_byte_array_remove_index (GByteArray *array,
                                            guint index_);
GByteArray* g_byte_array_remove_index_fast (GByteArray *array,
                                            guint index_);
void g_byte_array_sort (GByteArray *array,
                                            GCompareFunc compare_func);
void g_byte_array_sort_with_data (GByteArray *array,
                                            GCompareDataFunc compare_func,
                                            gpointer user_data);



# 32 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gasyncqueue.h" 1 3 4
# 30 "/usr/include/glib-2.0/glib/gasyncqueue.h" 3 4
# 1 "/usr/include/glib-2.0/glib/gthread.h" 1 3 4
# 30 "/usr/include/glib-2.0/glib/gthread.h" 3 4
# 1 "/usr/include/glib-2.0/glib/gerror.h" 1 3 4
# 24 "/usr/include/glib-2.0/glib/gerror.h" 3 4
# 1 "/usr/include/glib-2.0/glib/gquark.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gquark.h" 3 4


typedef guint32 GQuark;



GQuark g_quark_try_string (const gchar *string);
GQuark g_quark_from_static_string (const gchar *string);
GQuark g_quark_from_string (const gchar *string);
const gchar* g_quark_to_string (GQuark quark) ;


# 25 "/usr/include/glib-2.0/glib/gerror.h" 2 3 4



typedef struct _GError GError;

struct _GError
{
  GQuark domain;
  gint code;
  gchar *message;
};

GError* g_error_new (GQuark domain,
                                gint code,
                                const gchar *format,
                                ...) ;

GError* g_error_new_literal (GQuark domain,
                                gint code,
                                const gchar *message);

void g_error_free (GError *error);
GError* g_error_copy (const GError *error);

gboolean g_error_matches (const GError *error,
                                GQuark domain,
                                gint code);




void g_set_error (GError **err,
                                GQuark domain,
                                gint code,
                                const gchar *format,
                                ...) ;



void g_propagate_error (GError **dest,
                                GError *src);


void g_clear_error (GError **err);



# 31 "/usr/include/glib-2.0/glib/gthread.h" 2 3 4







extern GQuark g_thread_error_quark (void);


typedef enum
{
  G_THREAD_ERROR_AGAIN
} GThreadError;

typedef gpointer (*GThreadFunc) (gpointer data);

typedef enum
{
  G_THREAD_PRIORITY_LOW,
  G_THREAD_PRIORITY_NORMAL,
  G_THREAD_PRIORITY_HIGH,
  G_THREAD_PRIORITY_URGENT
} GThreadPriority;

typedef struct _GThread GThread;
struct _GThread
{

  GThreadFunc func;
  gpointer data;
  gboolean joinable;
  GThreadPriority priority;
};

typedef struct _GMutex GMutex;
typedef struct _GCond GCond;
typedef struct _GPrivate GPrivate;
typedef struct _GStaticPrivate GStaticPrivate;

typedef struct _GThreadFunctions GThreadFunctions;
struct _GThreadFunctions
{
  GMutex* (*mutex_new) (void);
  void (*mutex_lock) (GMutex *mutex);
  gboolean (*mutex_trylock) (GMutex *mutex);
  void (*mutex_unlock) (GMutex *mutex);
  void (*mutex_free) (GMutex *mutex);
  GCond* (*cond_new) (void);
  void (*cond_signal) (GCond *cond);
  void (*cond_broadcast) (GCond *cond);
  void (*cond_wait) (GCond *cond,
                                   GMutex *mutex);
  gboolean (*cond_timed_wait) (GCond *cond,
                                   GMutex *mutex,
                                   GTimeVal *end_time);
  void (*cond_free) (GCond *cond);
  GPrivate* (*private_new) (GDestroyNotify destructor);
  gpointer (*private_get) (GPrivate *private_key);
  void (*private_set) (GPrivate *private_key,
                                   gpointer data);
  void (*thread_create) (GThreadFunc func,
                                   gpointer data,
                                   gulong stack_size,
                                   gboolean joinable,
                                   gboolean bound,
                                   GThreadPriority priority,
                                   gpointer thread,
                                   GError **error);
  void (*thread_yield) (void);
  void (*thread_join) (gpointer thread);
  void (*thread_exit) (void);
  void (*thread_set_priority)(gpointer thread,
                                   GThreadPriority priority);
  void (*thread_self) (gpointer thread);
  gboolean (*thread_equal) (gpointer thread1,
                                   gpointer thread2);
};

extern GThreadFunctions g_thread_functions_for_glib_use;
extern gboolean g_thread_use_default_impl;
extern gboolean g_threads_got_initialized;





void g_thread_init (GThreadFunctions *vtable);
# 127 "/usr/include/glib-2.0/glib/gthread.h" 3 4
void g_thread_init_with_errorcheck_mutexes (GThreadFunctions* vtable);
# 137 "/usr/include/glib-2.0/glib/gthread.h" 3 4
GMutex* g_static_mutex_get_mutex_impl (GMutex **mutex);
# 203 "/usr/include/glib-2.0/glib/gthread.h" 3 4
GThread* g_thread_create_full (GThreadFunc func,
                                gpointer data,
                                gulong stack_size,
                                gboolean joinable,
                                gboolean bound,
                                GThreadPriority priority,
                                GError **error);
GThread* g_thread_self (void);
void g_thread_exit (gpointer retval);
gpointer g_thread_join (GThread *thread);

void g_thread_set_priority (GThread *thread,
                                GThreadPriority priority);
# 228 "/usr/include/glib-2.0/glib/gthread.h" 3 4
void g_static_mutex_init (GStaticMutex *mutex);
void g_static_mutex_free (GStaticMutex *mutex);

struct _GStaticPrivate
{

  guint index;
};

void g_static_private_init (GStaticPrivate *private_key);
gpointer g_static_private_get (GStaticPrivate *private_key);
void g_static_private_set (GStaticPrivate *private_key,
                                          gpointer data,
                                          GDestroyNotify notify);
void g_static_private_free (GStaticPrivate *private_key);

typedef struct _GStaticRecMutex GStaticRecMutex;
struct _GStaticRecMutex
{

  GStaticMutex mutex;
  guint depth;
  GSystemThread owner;
};


void g_static_rec_mutex_init (GStaticRecMutex *mutex);
void g_static_rec_mutex_lock (GStaticRecMutex *mutex);
gboolean g_static_rec_mutex_trylock (GStaticRecMutex *mutex);
void g_static_rec_mutex_unlock (GStaticRecMutex *mutex);
void g_static_rec_mutex_lock_full (GStaticRecMutex *mutex,
                                         guint depth);
guint g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);
void g_static_rec_mutex_free (GStaticRecMutex *mutex);

typedef struct _GStaticRWLock GStaticRWLock;
struct _GStaticRWLock
{

  GStaticMutex mutex;
  GCond *read_cond;
  GCond *write_cond;
  guint read_counter;
  gboolean have_writer;
  guint want_to_read;
  guint want_to_write;
};



void g_static_rw_lock_init (GStaticRWLock* lock);
void g_static_rw_lock_reader_lock (GStaticRWLock* lock);
gboolean g_static_rw_lock_reader_trylock (GStaticRWLock* lock);
void g_static_rw_lock_reader_unlock (GStaticRWLock* lock);
void g_static_rw_lock_writer_lock (GStaticRWLock* lock);
gboolean g_static_rw_lock_writer_trylock (GStaticRWLock* lock);
void g_static_rw_lock_writer_unlock (GStaticRWLock* lock);
void g_static_rw_lock_free (GStaticRWLock* lock);
# 296 "/usr/include/glib-2.0/glib/gthread.h" 3 4
extern void glib_dummy_decl (void);
# 338 "/usr/include/glib-2.0/glib/gthread.h" 3 4

# 31 "/usr/include/glib-2.0/glib/gasyncqueue.h" 2 3 4



typedef struct _GAsyncQueue GAsyncQueue;





GAsyncQueue* g_async_queue_new (void);





void g_async_queue_lock (GAsyncQueue *queue);
void g_async_queue_unlock (GAsyncQueue *queue);
# 56 "/usr/include/glib-2.0/glib/gasyncqueue.h" 3 4
void g_async_queue_ref (GAsyncQueue *queue);
void g_async_queue_ref_unlocked (GAsyncQueue *queue);
void g_async_queue_unref (GAsyncQueue *queue);
void g_async_queue_unref_and_unlock (GAsyncQueue *queue);


void g_async_queue_push (GAsyncQueue *queue,
                                                gpointer data);
void g_async_queue_push_unlocked (GAsyncQueue *queue,
                                                gpointer data);



gpointer g_async_queue_pop (GAsyncQueue *queue);
gpointer g_async_queue_pop_unlocked (GAsyncQueue *queue);


gpointer g_async_queue_try_pop (GAsyncQueue *queue);
gpointer g_async_queue_try_pop_unlocked (GAsyncQueue *queue);



gpointer g_async_queue_timed_pop (GAsyncQueue *queue,
                                                GTimeVal *end_time);
gpointer g_async_queue_timed_pop_unlocked (GAsyncQueue *queue,
                                                GTimeVal *end_time);







gint g_async_queue_length (GAsyncQueue *queue);
gint g_async_queue_length_unlocked (GAsyncQueue *queue);


# 33 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gbacktrace.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gbacktrace.h" 3 4

# 43 "/usr/include/glib-2.0/glib/gbacktrace.h" 3 4
void g_on_error_query (const gchar *prg_name);
void g_on_error_stack_trace (const gchar *prg_name);
# 59 "/usr/include/glib-2.0/glib/gbacktrace.h" 3 4

# 34 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gcache.h" 1 3 4
# 30 "/usr/include/glib-2.0/glib/gcache.h" 3 4
# 1 "/usr/include/glib-2.0/glib/glist.h" 1 3 4
# 30 "/usr/include/glib-2.0/glib/glist.h" 3 4
# 1 "/usr/include/glib-2.0/glib/gmem.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gmem.h" 3 4


typedef struct _GAllocator GAllocator;
typedef struct _GMemChunk GMemChunk;
typedef struct _GMemVTable GMemVTable;
# 48 "/usr/include/glib-2.0/glib/gmem.h" 3 4
gpointer g_malloc (gulong n_bytes);
gpointer g_malloc0 (gulong n_bytes);
gpointer g_realloc (gpointer mem,
                           gulong n_bytes);
void g_free (gpointer mem);
gpointer g_try_malloc (gulong n_bytes);
gpointer g_try_realloc (gpointer mem,
                           gulong n_bytes);
# 72 "/usr/include/glib-2.0/glib/gmem.h" 3 4
struct _GMemVTable
{
  gpointer (*malloc) (gsize n_bytes);
  gpointer (*realloc) (gpointer mem,
                           gsize n_bytes);
  void (*free) (gpointer mem);

  gpointer (*calloc) (gsize n_blocks,
                           gsize n_block_bytes);
  gpointer (*try_malloc) (gsize n_bytes);
  gpointer (*try_realloc) (gpointer mem,
                           gsize n_bytes);
};
void g_mem_set_vtable (GMemVTable *vtable);
gboolean g_mem_is_system_malloc (void);



extern GMemVTable *glib_mem_profiler_table;
void g_mem_profile (void);
# 135 "/usr/include/glib-2.0/glib/gmem.h" 3 4
GMemChunk* g_mem_chunk_new (const gchar *name,
                                gint atom_size,
                                gulong area_size,
                                gint type);
void g_mem_chunk_destroy (GMemChunk *mem_chunk);
gpointer g_mem_chunk_alloc (GMemChunk *mem_chunk);
gpointer g_mem_chunk_alloc0 (GMemChunk *mem_chunk);
void g_mem_chunk_free (GMemChunk *mem_chunk,
                                gpointer mem);
void g_mem_chunk_clean (GMemChunk *mem_chunk);
void g_mem_chunk_reset (GMemChunk *mem_chunk);
void g_mem_chunk_print (GMemChunk *mem_chunk);
void g_mem_chunk_info (void);
# 157 "/usr/include/glib-2.0/glib/gmem.h" 3 4
void g_blow_chunks (void);




GAllocator* g_allocator_new (const gchar *name,
                               guint n_preallocs);
void g_allocator_free (GAllocator *allocator);








# 31 "/usr/include/glib-2.0/glib/glist.h" 2 3 4



typedef struct _GList GList;

struct _GList
{
  gpointer data;
  GList *next;
  GList *prev;
};



void g_list_push_allocator (GAllocator *allocator);
void g_list_pop_allocator (void);
GList* g_list_alloc (void);
void g_list_free (GList *list);
void g_list_free_1 (GList *list);
GList* g_list_append (GList *list,
                                gpointer data);
GList* g_list_prepend (GList *list,
                                gpointer data);
GList* g_list_insert (GList *list,
                                gpointer data,
                                gint position);
GList* g_list_insert_sorted (GList *list,
                                gpointer data,
                                GCompareFunc func);
GList* g_list_insert_before (GList *list,
                                GList *sibling,
                                gpointer data);
GList* g_list_concat (GList *list1,
                                GList *list2);
GList* g_list_remove (GList *list,
                                gconstpointer data);
GList* g_list_remove_all (GList *list,
                                gconstpointer data);
GList* g_list_remove_link (GList *list,
                                GList *llink);
GList* g_list_delete_link (GList *list,
                                GList *link_);
GList* g_list_reverse (GList *list);
GList* g_list_copy (GList *list);
GList* g_list_nth (GList *list,
                                guint n);
GList* g_list_nth_prev (GList *list,
                                guint n);
GList* g_list_find (GList *list,
                                gconstpointer data);
GList* g_list_find_custom (GList *list,
                                gconstpointer data,
                                GCompareFunc func);
gint g_list_position (GList *list,
                                GList *llink);
gint g_list_index (GList *list,
                                gconstpointer data);
GList* g_list_last (GList *list);
GList* g_list_first (GList *list);
guint g_list_length (GList *list);
void g_list_foreach (GList *list,
                                GFunc func,
                                gpointer user_data);
GList* g_list_sort (GList *list,
                                GCompareFunc compare_func);
GList* g_list_sort_with_data (GList *list,
                                GCompareDataFunc compare_func,
                                gpointer user_data);
gpointer g_list_nth_data (GList *list,
                                guint n);





# 31 "/usr/include/glib-2.0/glib/gcache.h" 2 3 4



typedef struct _GCache GCache;

typedef gpointer (*GCacheNewFunc) (gpointer key);
typedef gpointer (*GCacheDupFunc) (gpointer value);
typedef void (*GCacheDestroyFunc) (gpointer value);



GCache* g_cache_new (GCacheNewFunc value_new_func,
                                GCacheDestroyFunc value_destroy_func,
                                GCacheDupFunc key_dup_func,
                                GCacheDestroyFunc key_destroy_func,
                                GHashFunc hash_key_func,
                                GHashFunc hash_value_func,
                                GEqualFunc key_equal_func);
void g_cache_destroy (GCache *cache);
gpointer g_cache_insert (GCache *cache,
                                gpointer key);
void g_cache_remove (GCache *cache,
                                gconstpointer value);
void g_cache_key_foreach (GCache *cache,
                                GHFunc func,
                                gpointer user_data);
void g_cache_value_foreach (GCache *cache,
                                GHFunc func,
                                gpointer user_data);


# 35 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gcompletion.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gcompletion.h" 3 4


typedef struct _GCompletion GCompletion;

typedef gchar* (*GCompletionFunc) (gpointer);




typedef gint (*GCompletionStrncmpFunc) (const gchar *s1,
                                        const gchar *s2,
                                        gsize n);

struct _GCompletion
{
  GList* items;
  GCompletionFunc func;

  gchar* prefix;
  GList* cache;
  GCompletionStrncmpFunc strncmp_func;
};

GCompletion* g_completion_new (GCompletionFunc func);
void g_completion_add_items (GCompletion* cmp,
                                        GList* items);
void g_completion_remove_items (GCompletion* cmp,
                                        GList* items);
void g_completion_clear_items (GCompletion* cmp);
GList* g_completion_complete (GCompletion* cmp,
                                        const gchar* prefix,
                                        gchar** new_prefix);
void g_completion_set_compare (GCompletion *cmp,
                                       GCompletionStrncmpFunc strncmp_func);
void g_completion_free (GCompletion* cmp);


# 36 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gconvert.h" 1 3 4
# 30 "/usr/include/glib-2.0/glib/gconvert.h" 3 4
# 1 "/usr/lib/gcc-lib/i486-linux/3.3.2/include/stddef.h" 1 3 4
# 31 "/usr/include/glib-2.0/glib/gconvert.h" 2 3 4




typedef enum
{
  G_CONVERT_ERROR_NO_CONVERSION,
  G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
  G_CONVERT_ERROR_FAILED,
  G_CONVERT_ERROR_PARTIAL_INPUT,
  G_CONVERT_ERROR_BAD_URI,
  G_CONVERT_ERROR_NOT_ABSOLUTE_PATH
} GConvertError;


GQuark g_convert_error_quark (void);



typedef struct _GIConv *GIConv;

GIConv g_iconv_open (const gchar *to_codeset,
                       const gchar *from_codeset);
size_t g_iconv (GIConv converter,
                       gchar **inbuf,
                       gsize *inbytes_left,
                       gchar **outbuf,
                       gsize *outbytes_left);
gint g_iconv_close (GIConv converter);


gchar* g_convert (const gchar *str,
                                gssize len,
                                const gchar *to_codeset,
                                const gchar *from_codeset,
                                gsize *bytes_read,
                                gsize *bytes_written,
                                GError **error);
gchar* g_convert_with_iconv (const gchar *str,
                                gssize len,
                                GIConv converter,
                                gsize *bytes_read,
                                gsize *bytes_written,
                                GError **error);
gchar* g_convert_with_fallback (const gchar *str,
                                gssize len,
                                const gchar *to_codeset,
                                const gchar *from_codeset,
                                gchar *fallback,
                                gsize *bytes_read,
                                gsize *bytes_written,
                                GError **error);




gchar* g_locale_to_utf8 (const gchar *opsysstring,
                           gssize len,
                           gsize *bytes_read,
                           gsize *bytes_written,
                           GError **error);
gchar* g_locale_from_utf8 (const gchar *utf8string,
                           gssize len,
                           gsize *bytes_read,
                           gsize *bytes_written,
                           GError **error);




gchar* g_filename_to_utf8 (const gchar *opsysstring,
                             gssize len,
                             gsize *bytes_read,
                             gsize *bytes_written,
                             GError **error);
gchar* g_filename_from_utf8 (const gchar *utf8string,
                             gssize len,
                             gsize *bytes_read,
                             gsize *bytes_written,
                             GError **error);

gchar *g_filename_from_uri (const char *uri,
                            char **hostname,
                            GError **error);

gchar *g_filename_to_uri (const char *filename,
                            const char *hostname,
                            GError **error);



# 37 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gdataset.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gdataset.h" 3 4


typedef struct _GData GData;

typedef void (*GDataForeachFunc) (GQuark key_id,
                                                 gpointer data,
                                                 gpointer user_data);



void g_datalist_init (GData **datalist);
void g_datalist_clear (GData **datalist);
gpointer g_datalist_id_get_data (GData **datalist,
                                          GQuark key_id);
void g_datalist_id_set_data_full (GData **datalist,
                                          GQuark key_id,
                                          gpointer data,
                                          GDestroyNotify destroy_func);
gpointer g_datalist_id_remove_no_notify (GData **datalist,
                                          GQuark key_id);
void g_datalist_foreach (GData **datalist,
                                          GDataForeachFunc func,
                                          gpointer user_data);
# 73 "/usr/include/glib-2.0/glib/gdataset.h" 3 4
void g_dataset_destroy (gconstpointer dataset_location);
gpointer g_dataset_id_get_data (gconstpointer dataset_location,
                                         GQuark key_id);
void g_dataset_id_set_data_full (gconstpointer dataset_location,
                                         GQuark key_id,
                                         gpointer data,
                                         GDestroyNotify destroy_func);
gpointer g_dataset_id_remove_no_notify (gconstpointer dataset_location,
                                         GQuark key_id);
void g_dataset_foreach (gconstpointer dataset_location,
                                         GDataForeachFunc func,
                                         gpointer user_data);
# 100 "/usr/include/glib-2.0/glib/gdataset.h" 3 4

# 38 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gdate.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gdate.h" 3 4

# 43 "/usr/include/glib-2.0/glib/gdate.h" 3 4
typedef gint32 GTime;
typedef guint16 GDateYear;
typedef guint8 GDateDay;
typedef struct _GDate GDate;

struct tm;


typedef enum
{
  G_DATE_DAY = 0,
  G_DATE_MONTH = 1,
  G_DATE_YEAR = 2
} GDateDMY;


typedef enum
{
  G_DATE_BAD_WEEKDAY = 0,
  G_DATE_MONDAY = 1,
  G_DATE_TUESDAY = 2,
  G_DATE_WEDNESDAY = 3,
  G_DATE_THURSDAY = 4,
  G_DATE_FRIDAY = 5,
  G_DATE_SATURDAY = 6,
  G_DATE_SUNDAY = 7
} GDateWeekday;
typedef enum
{
  G_DATE_BAD_MONTH = 0,
  G_DATE_JANUARY = 1,
  G_DATE_FEBRUARY = 2,
  G_DATE_MARCH = 3,
  G_DATE_APRIL = 4,
  G_DATE_MAY = 5,
  G_DATE_JUNE = 6,
  G_DATE_JULY = 7,
  G_DATE_AUGUST = 8,
  G_DATE_SEPTEMBER = 9,
  G_DATE_OCTOBER = 10,
  G_DATE_NOVEMBER = 11,
  G_DATE_DECEMBER = 12
} GDateMonth;
# 96 "/usr/include/glib-2.0/glib/gdate.h" 3 4
struct _GDate
{
  guint julian_days : 32;





  guint julian : 1;
  guint dmy : 1;


  guint day : 6;
  guint month : 4;
  guint year : 16;
};





GDate* g_date_new (void);
GDate* g_date_new_dmy (GDateDay day,
                                           GDateMonth month,
                                           GDateYear year);
GDate* g_date_new_julian (guint32 julian_day);
void g_date_free (GDate *date);






gboolean g_date_valid (const GDate *date);
gboolean g_date_valid_day (GDateDay day) ;
gboolean g_date_valid_month (GDateMonth month) ;
gboolean g_date_valid_year (GDateYear year) ;
gboolean g_date_valid_weekday (GDateWeekday weekday) ;
gboolean g_date_valid_julian (guint32 julian_date) ;
gboolean g_date_valid_dmy (GDateDay day,
                                           GDateMonth month,
                                           GDateYear year) ;

GDateWeekday g_date_get_weekday (const GDate *date);
GDateMonth g_date_get_month (const GDate *date);
GDateYear g_date_get_year (const GDate *date);
GDateDay g_date_get_day (const GDate *date);
guint32 g_date_get_julian (const GDate *date);
guint g_date_get_day_of_year (const GDate *date);






guint g_date_get_monday_week_of_year (const GDate *date);
guint g_date_get_sunday_week_of_year (const GDate *date);





void g_date_clear (GDate *date,
                                           guint n_dates);





void g_date_set_parse (GDate *date,
                                           const gchar *str);
void g_date_set_time (GDate *date,
                                           GTime time_);
void g_date_set_month (GDate *date,
                                           GDateMonth month);
void g_date_set_day (GDate *date,
                                           GDateDay day);
void g_date_set_year (GDate *date,
                                           GDateYear year);
void g_date_set_dmy (GDate *date,
                                           GDateDay day,
                                           GDateMonth month,
                                           GDateYear y);
void g_date_set_julian (GDate *date,
                                           guint32 julian_date);
gboolean g_date_is_first_of_month (const GDate *date);
gboolean g_date_is_last_of_month (const GDate *date);


void g_date_add_days (GDate *date,
                                           guint n_days);
void g_date_subtract_days (GDate *date,
                                           guint n_days);


void g_date_add_months (GDate *date,
                                           guint n_months);
void g_date_subtract_months (GDate *date,
                                           guint n_months);


void g_date_add_years (GDate *date,
                                           guint n_years);
void g_date_subtract_years (GDate *date,
                                           guint n_years);
gboolean g_date_is_leap_year (GDateYear year) ;
guint8 g_date_get_days_in_month (GDateMonth month,
                                           GDateYear year) ;
guint8 g_date_get_monday_weeks_in_year (GDateYear year) ;
guint8 g_date_get_sunday_weeks_in_year (GDateYear year) ;



gint g_date_days_between (const GDate *date1,
                                           const GDate *date2);


gint g_date_compare (const GDate *lhs,
                                           const GDate *rhs);
void g_date_to_struct_tm (const GDate *date,
                                           struct tm *tm);

void g_date_clamp (GDate *date,
                                           const GDate *min_date,
                                           const GDate *max_date);


void g_date_order (GDate *date1, GDate *date2);




gsize g_date_strftime (gchar *s,
                                           gsize slen,
                                           const gchar *format,
                                           const GDate *date);
# 249 "/usr/include/glib-2.0/glib/gdate.h" 3 4

# 39 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gdir.h" 1 3 4
# 28 "/usr/include/glib-2.0/glib/gdir.h" 3 4


typedef struct _GDir GDir;

GDir * g_dir_open (const gchar *path,
                                         guint flags,
                                         GError **error);
const gchar *g_dir_read_name (GDir *dir);
void g_dir_rewind (GDir *dir);
void g_dir_close (GDir *dir);


# 40 "/usr/include/glib-2.0/glib.h" 2 3 4

# 1 "/usr/include/glib-2.0/glib/gfileutils.h" 1 3 4
# 26 "/usr/include/glib-2.0/glib/gfileutils.h" 3 4




typedef enum
{
  G_FILE_ERROR_EXIST,
  G_FILE_ERROR_ISDIR,
  G_FILE_ERROR_ACCES,
  G_FILE_ERROR_NAMETOOLONG,
  G_FILE_ERROR_NOENT,
  G_FILE_ERROR_NOTDIR,
  G_FILE_ERROR_NXIO,
  G_FILE_ERROR_NODEV,
  G_FILE_ERROR_ROFS,
  G_FILE_ERROR_TXTBSY,
  G_FILE_ERROR_FAULT,
  G_FILE_ERROR_LOOP,
  G_FILE_ERROR_NOSPC,
  G_FILE_ERROR_NOMEM,
  G_FILE_ERROR_MFILE,
  G_FILE_ERROR_NFILE,
  G_FILE_ERROR_BADF,
  G_FILE_ERROR_INVAL,
  G_FILE_ERROR_PIPE,
  G_FILE_ERROR_AGAIN,
  G_FILE_ERROR_INTR,
  G_FILE_ERROR_IO,
  G_FILE_ERROR_PERM,
  G_FILE_ERROR_FAILED
} GFileError;





typedef enum
{
  G_FILE_TEST_IS_REGULAR = 1 << 0,
  G_FILE_TEST_IS_SYMLINK = 1 << 1,
  G_FILE_TEST_IS_DIR = 1 << 2,
  G_FILE_TEST_IS_EXECUTABLE = 1 << 3,
  G_FILE_TEST_EXISTS = 1 << 4
} GFileTest;

GQuark g_file_error_quark (void);

GFileError g_file_error_from_errno (gint err_no);

gboolean g_file_test (const gchar *filename,
                              GFileTest test);
gboolean g_file_get_contents (const gchar *filename,
                              gchar **contents,
                              gsize *length,
                              GError **error);



int g_mkstemp (char *tmpl);


int g_file_open_tmp (const char *tmpl,
                              char **name_used,
                              GError **error);

gchar *g_build_path (const gchar *separator,
                         const gchar *first_element,
                         ...);
gchar *g_build_filename (const gchar *first_element,
                         ...);


# 42 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/ghash.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/ghash.h" 3 4


typedef struct _GHashTable GHashTable;

typedef gboolean (*GHRFunc) (gpointer key,
                               gpointer value,
                               gpointer user_data);



GHashTable* g_hash_table_new (GHashFunc hash_func,
                                            GEqualFunc key_equal_func);
GHashTable* g_hash_table_new_full (GHashFunc hash_func,
                                            GEqualFunc key_equal_func,
                                            GDestroyNotify key_destroy_func,
                                            GDestroyNotify value_destroy_func);
void g_hash_table_destroy (GHashTable *hash_table);
void g_hash_table_insert (GHashTable *hash_table,
                                            gpointer key,
                                            gpointer value);
void g_hash_table_replace (GHashTable *hash_table,
                                            gpointer key,
                                            gpointer value);
gboolean g_hash_table_remove (GHashTable *hash_table,
                                            gconstpointer key);
gboolean g_hash_table_steal (GHashTable *hash_table,
                                            gconstpointer key);
gpointer g_hash_table_lookup (GHashTable *hash_table,
                                            gconstpointer key);
gboolean g_hash_table_lookup_extended (GHashTable *hash_table,
                                            gconstpointer lookup_key,
                                            gpointer *orig_key,
                                            gpointer *value);
void g_hash_table_foreach (GHashTable *hash_table,
                                            GHFunc func,
                                            gpointer user_data);
guint g_hash_table_foreach_remove (GHashTable *hash_table,
                                            GHRFunc func,
                                            gpointer user_data);
guint g_hash_table_foreach_steal (GHashTable *hash_table,
                                            GHRFunc func,
                                            gpointer user_data);
guint g_hash_table_size (GHashTable *hash_table);
# 87 "/usr/include/glib-2.0/glib/ghash.h" 3 4
gboolean g_str_equal (gconstpointer v,
                      gconstpointer v2);
guint g_str_hash (gconstpointer v);

gboolean g_int_equal (gconstpointer v,
                      gconstpointer v2);
guint g_int_hash (gconstpointer v);







guint g_direct_hash (gconstpointer v) ;
gboolean g_direct_equal (gconstpointer v,
                         gconstpointer v2) ;


# 43 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/ghook.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/ghook.h" 3 4




typedef struct _GHook GHook;
typedef struct _GHookList GHookList;

typedef gint (*GHookCompareFunc) (GHook *new_hook,
                                                 GHook *sibling);
typedef gboolean (*GHookFindFunc) (GHook *hook,
                                                 gpointer data);
typedef void (*GHookMarshaller) (GHook *hook,
                                                 gpointer marshal_data);
typedef gboolean (*GHookCheckMarshaller) (GHook *hook,
                                                 gpointer marshal_data);
typedef void (*GHookFunc) (gpointer data);
typedef gboolean (*GHookCheckFunc) (gpointer data);
typedef void (*GHookFinalizeFunc) (GHookList *hook_list,
                                                 GHook *hook);
typedef enum
{
  G_HOOK_FLAG_ACTIVE = 1 << 0,
  G_HOOK_FLAG_IN_CALL = 1 << 1,
  G_HOOK_FLAG_MASK = 0x0f
} GHookFlagMask;




struct _GHookList
{
  gulong seq_id;
  guint hook_size : 16;
  guint is_setup : 1;
  GHook *hooks;
  GMemChunk *hook_memchunk;
  GHookFinalizeFunc finalize_hook;
  gpointer dummy[2];
};
struct _GHook
{
  gpointer data;
  GHook *next;
  GHook *prev;
  guint ref_count;
  gulong hook_id;
  guint flags;
  gpointer func;
  GDestroyNotify destroy;
};
# 102 "/usr/include/glib-2.0/glib/ghook.h" 3 4
void g_hook_list_init (GHookList *hook_list,
                                         guint hook_size);
void g_hook_list_clear (GHookList *hook_list);
GHook* g_hook_alloc (GHookList *hook_list);
void g_hook_free (GHookList *hook_list,
                                         GHook *hook);
void g_hook_ref (GHookList *hook_list,
                                         GHook *hook);
void g_hook_unref (GHookList *hook_list,
                                         GHook *hook);
gboolean g_hook_destroy (GHookList *hook_list,
                                         gulong hook_id);
void g_hook_destroy_link (GHookList *hook_list,
                                         GHook *hook);
void g_hook_prepend (GHookList *hook_list,
                                         GHook *hook);
void g_hook_insert_before (GHookList *hook_list,
                                         GHook *sibling,
                                         GHook *hook);
void g_hook_insert_sorted (GHookList *hook_list,
                                         GHook *hook,
                                         GHookCompareFunc func);
GHook* g_hook_get (GHookList *hook_list,
                                         gulong hook_id);
GHook* g_hook_find (GHookList *hook_list,
                                         gboolean need_valids,
                                         GHookFindFunc func,
                                         gpointer data);
GHook* g_hook_find_data (GHookList *hook_list,
                                         gboolean need_valids,
                                         gpointer data);
GHook* g_hook_find_func (GHookList *hook_list,
                                         gboolean need_valids,
                                         gpointer func);
GHook* g_hook_find_func_data (GHookList *hook_list,
                                         gboolean need_valids,
                                         gpointer func,
                                         gpointer data);

GHook* g_hook_first_valid (GHookList *hook_list,
                                         gboolean may_be_in_call);



GHook* g_hook_next_valid (GHookList *hook_list,
                                         GHook *hook,
                                         gboolean may_be_in_call);

gint g_hook_compare_ids (GHook *new_hook,
                                         GHook *sibling);





void g_hook_list_invoke (GHookList *hook_list,
                                         gboolean may_recurse);



void g_hook_list_invoke_check (GHookList *hook_list,
                                         gboolean may_recurse);


void g_hook_list_marshal (GHookList *hook_list,
                                         gboolean may_recurse,
                                         GHookMarshaller marshaller,
                                         gpointer marshal_data);
void g_hook_list_marshal_check (GHookList *hook_list,
                                         gboolean may_recurse,
                                         GHookCheckMarshaller marshaller,
                                         gpointer marshal_data);


# 44 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/giochannel.h" 1 3 4
# 31 "/usr/include/glib-2.0/glib/giochannel.h" 3 4
# 1 "/usr/include/glib-2.0/glib/gmain.h" 1 3 4
# 23 "/usr/include/glib-2.0/glib/gmain.h" 3 4
# 1 "/usr/include/glib-2.0/glib/gslist.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gslist.h" 3 4


typedef struct _GSList GSList;

struct _GSList
{
  gpointer data;
  GSList *next;
};



void g_slist_push_allocator (GAllocator *allocator);
void g_slist_pop_allocator (void);
GSList* g_slist_alloc (void);
void g_slist_free (GSList *list);
void g_slist_free_1 (GSList *list);
GSList* g_slist_append (GSList *list,
                                 gpointer data);
GSList* g_slist_prepend (GSList *list,
                                 gpointer data);
GSList* g_slist_insert (GSList *list,
                                 gpointer data,
                                 gint position);
GSList* g_slist_insert_sorted (GSList *list,
                                 gpointer data,
                                 GCompareFunc func);
GSList* g_slist_insert_before (GSList *slist,
                                 GSList *sibling,
                                 gpointer data);
GSList* g_slist_concat (GSList *list1,
                                 GSList *list2);
GSList* g_slist_remove (GSList *list,
                                 gconstpointer data);
GSList* g_slist_remove_all (GSList *list,
                                 gconstpointer data);
GSList* g_slist_remove_link (GSList *list,
                                 GSList *link_);
GSList* g_slist_delete_link (GSList *list,
                                 GSList *link_);
GSList* g_slist_reverse (GSList *list);
GSList* g_slist_copy (GSList *list);
GSList* g_slist_nth (GSList *list,
                                 guint n);
GSList* g_slist_find (GSList *list,
                                 gconstpointer data);
GSList* g_slist_find_custom (GSList *list,
                                 gconstpointer data,
                                 GCompareFunc func);
gint g_slist_position (GSList *list,
                                 GSList *llink);
gint g_slist_index (GSList *list,
                                 gconstpointer data);
GSList* g_slist_last (GSList *list);
guint g_slist_length (GSList *list);
void g_slist_foreach (GSList *list,
                                 GFunc func,
                                 gpointer user_data);
GSList* g_slist_sort (GSList *list,
                                 GCompareFunc compare_func);
GSList* g_slist_sort_with_data (GSList *list,
                                 GCompareDataFunc compare_func,
                                 gpointer user_data);
gpointer g_slist_nth_data (GSList *list,
                                 guint n);



# 24 "/usr/include/glib-2.0/glib/gmain.h" 2 3 4




typedef struct _GMainContext GMainContext;
typedef struct _GMainLoop GMainLoop;
typedef struct _GSource GSource;
typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
typedef struct _GSourceFuncs GSourceFuncs;

typedef gboolean (*GSourceFunc) (gpointer data);

struct _GSource
{

  gpointer callback_data;
  GSourceCallbackFuncs *callback_funcs;

  GSourceFuncs *source_funcs;
  guint ref_count;

  GMainContext *context;

  gint priority;
  guint flags;
  guint source_id;

  GSList *poll_fds;

  GSource *prev;
  GSource *next;

  gpointer reserved1;
  gpointer reserved2;
};

struct _GSourceCallbackFuncs
{
  void (*ref) (gpointer cb_data);
  void (*unref) (gpointer cb_data);
  void (*get) (gpointer cb_data,
                 GSource *source,
                 GSourceFunc *func,
                 gpointer *data);
};

typedef void (*GSourceDummyMarshal) (void);

struct _GSourceFuncs
{
  gboolean (*prepare) (GSource *source,
                        gint *timeout_);
  gboolean (*check) (GSource *source);
  gboolean (*dispatch) (GSource *source,
                        GSourceFunc callback,
                        gpointer user_data);
  void (*finalize) (GSource *source);


  GSourceFunc closure_callback;
  GSourceDummyMarshal closure_marshal;
};
# 114 "/usr/include/glib-2.0/glib/gmain.h" 3 4
typedef struct _GPollFD GPollFD;
typedef gint (*GPollFunc) (GPollFD *ufds,
                                 guint nfsd,
                                 gint timeout_);

struct _GPollFD
{
  gint fd;
  gushort events;
  gushort revents;
};
# 136 "/usr/include/glib-2.0/glib/gmain.h" 3 4
GMainContext *g_main_context_new (void);
void g_main_context_ref (GMainContext *context);
void g_main_context_unref (GMainContext *context);
GMainContext *g_main_context_default (void);

gboolean g_main_context_iteration (GMainContext *context,
                                        gboolean may_block);
gboolean g_main_context_pending (GMainContext *context);



GSource *g_main_context_find_source_by_id (GMainContext *context,
                                                             guint source_id);
GSource *g_main_context_find_source_by_user_data (GMainContext *context,
                                                             gpointer user_data);
GSource *g_main_context_find_source_by_funcs_user_data (GMainContext *context,
                                                             GSourceFuncs *funcs,
                                                             gpointer user_data);



void g_main_context_wakeup (GMainContext *context);
gboolean g_main_context_acquire (GMainContext *context);
void g_main_context_release (GMainContext *context);
gboolean g_main_context_wait (GMainContext *context,
                                 GCond *cond,
                                 GMutex *mutex);

gboolean g_main_context_prepare (GMainContext *context,
                                  gint *priority);
gint g_main_context_query (GMainContext *context,
                                  gint max_priority,
                                  gint *timeout_,
                                  GPollFD *fds,
                                  gint n_fds);
gint g_main_context_check (GMainContext *context,
                                  gint max_priority,
                                  GPollFD *fds,
                                  gint n_fds);
void g_main_context_dispatch (GMainContext *context);

void g_main_context_set_poll_func (GMainContext *context,
                                        GPollFunc func);
GPollFunc g_main_context_get_poll_func (GMainContext *context);



void g_main_context_add_poll (GMainContext *context,
                                   GPollFD *fd,
                                   gint priority);
void g_main_context_remove_poll (GMainContext *context,
                                   GPollFD *fd);



GMainLoop *g_main_loop_new (GMainContext *context,
                                   gboolean is_running);
void g_main_loop_run (GMainLoop *loop);
void g_main_loop_quit (GMainLoop *loop);
GMainLoop *g_main_loop_ref (GMainLoop *loop);
void g_main_loop_unref (GMainLoop *loop);
gboolean g_main_loop_is_running (GMainLoop *loop);
GMainContext *g_main_loop_get_context (GMainLoop *loop);



GSource *g_source_new (GSourceFuncs *source_funcs,
                                   guint struct_size);
GSource *g_source_ref (GSource *source);
void g_source_unref (GSource *source);

guint g_source_attach (GSource *source,
                                   GMainContext *context);
void g_source_destroy (GSource *source);

void g_source_set_priority (GSource *source,
                                   gint priority);
gint g_source_get_priority (GSource *source);
void g_source_set_can_recurse (GSource *source,
                                   gboolean can_recurse);
gboolean g_source_get_can_recurse (GSource *source);
guint g_source_get_id (GSource *source);

GMainContext *g_source_get_context (GSource *source);

void g_source_set_callback (GSource *source,
                                     GSourceFunc func,
                                     gpointer data,
                                     GDestroyNotify notify);



void g_source_set_callback_indirect (GSource *source,
                                     gpointer callback_data,
                                     GSourceCallbackFuncs *callback_funcs);

void g_source_add_poll (GSource *source,
                                    GPollFD *fd);
void g_source_remove_poll (GSource *source,
                                    GPollFD *fd);

void g_source_get_current_time (GSource *source,
                                    GTimeVal *timeval);







GSource *g_idle_source_new (void);
GSource *g_timeout_source_new (guint interval);



void g_get_current_time (GTimeVal *result);
# 276 "/usr/include/glib-2.0/glib/gmain.h" 3 4
gboolean g_source_remove (guint tag);
gboolean g_source_remove_by_user_data (gpointer user_data);
gboolean g_source_remove_by_funcs_user_data (GSourceFuncs *funcs,
                                              gpointer user_data);


guint g_timeout_add_full (gint priority,
                                         guint interval,
                                         GSourceFunc function,
                                         gpointer data,
                                         GDestroyNotify notify);
guint g_timeout_add (guint interval,
                                         GSourceFunc function,
                                         gpointer data);
guint g_idle_add (GSourceFunc function,
                                         gpointer data);
guint g_idle_add_full (gint priority,
                                         GSourceFunc function,
                                         gpointer data,
                                         GDestroyNotify notify);
gboolean g_idle_remove_by_data (gpointer data);


extern GSourceFuncs g_timeout_funcs;
extern GSourceFuncs g_idle_funcs;


# 32 "/usr/include/glib-2.0/glib/giochannel.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gstring.h" 1 3 4
# 31 "/usr/include/glib-2.0/glib/gstring.h" 3 4
# 1 "/usr/include/glib-2.0/glib/gunicode.h" 1 3 4
# 28 "/usr/include/glib-2.0/glib/gunicode.h" 3 4


typedef guint32 gunichar;
typedef guint16 gunichar2;




typedef enum
{
  G_UNICODE_CONTROL,
  G_UNICODE_FORMAT,
  G_UNICODE_UNASSIGNED,
  G_UNICODE_PRIVATE_USE,
  G_UNICODE_SURROGATE,
  G_UNICODE_LOWERCASE_LETTER,
  G_UNICODE_MODIFIER_LETTER,
  G_UNICODE_OTHER_LETTER,
  G_UNICODE_TITLECASE_LETTER,
  G_UNICODE_UPPERCASE_LETTER,
  G_UNICODE_COMBINING_MARK,
  G_UNICODE_ENCLOSING_MARK,
  G_UNICODE_NON_SPACING_MARK,
  G_UNICODE_DECIMAL_NUMBER,
  G_UNICODE_LETTER_NUMBER,
  G_UNICODE_OTHER_NUMBER,
  G_UNICODE_CONNECT_PUNCTUATION,
  G_UNICODE_DASH_PUNCTUATION,
  G_UNICODE_CLOSE_PUNCTUATION,
  G_UNICODE_FINAL_PUNCTUATION,
  G_UNICODE_INITIAL_PUNCTUATION,
  G_UNICODE_OTHER_PUNCTUATION,
  G_UNICODE_OPEN_PUNCTUATION,
  G_UNICODE_CURRENCY_SYMBOL,
  G_UNICODE_MODIFIER_SYMBOL,
  G_UNICODE_MATH_SYMBOL,
  G_UNICODE_OTHER_SYMBOL,
  G_UNICODE_LINE_SEPARATOR,
  G_UNICODE_PARAGRAPH_SEPARATOR,
  G_UNICODE_SPACE_SEPARATOR
} GUnicodeType;




typedef enum
{
  G_UNICODE_BREAK_MANDATORY,
  G_UNICODE_BREAK_CARRIAGE_RETURN,
  G_UNICODE_BREAK_LINE_FEED,
  G_UNICODE_BREAK_COMBINING_MARK,
  G_UNICODE_BREAK_SURROGATE,
  G_UNICODE_BREAK_ZERO_WIDTH_SPACE,
  G_UNICODE_BREAK_INSEPARABLE,
  G_UNICODE_BREAK_NON_BREAKING_GLUE,
  G_UNICODE_BREAK_CONTINGENT,
  G_UNICODE_BREAK_SPACE,
  G_UNICODE_BREAK_AFTER,
  G_UNICODE_BREAK_BEFORE,
  G_UNICODE_BREAK_BEFORE_AND_AFTER,
  G_UNICODE_BREAK_HYPHEN,
  G_UNICODE_BREAK_NON_STARTER,
  G_UNICODE_BREAK_OPEN_PUNCTUATION,
  G_UNICODE_BREAK_CLOSE_PUNCTUATION,
  G_UNICODE_BREAK_QUOTATION,
  G_UNICODE_BREAK_EXCLAMATION,
  G_UNICODE_BREAK_IDEOGRAPHIC,
  G_UNICODE_BREAK_NUMERIC,
  G_UNICODE_BREAK_INFIX_SEPARATOR,
  G_UNICODE_BREAK_SYMBOL,
  G_UNICODE_BREAK_ALPHABETIC,
  G_UNICODE_BREAK_PREFIX,
  G_UNICODE_BREAK_POSTFIX,
  G_UNICODE_BREAK_COMPLEX_CONTEXT,
  G_UNICODE_BREAK_AMBIGUOUS,
  G_UNICODE_BREAK_UNKNOWN
} GUnicodeBreakType;







gboolean g_get_charset (const char **charset);



gboolean g_unichar_isalnum (gunichar c) ;
gboolean g_unichar_isalpha (gunichar c) ;
gboolean g_unichar_iscntrl (gunichar c) ;
gboolean g_unichar_isdigit (gunichar c) ;
gboolean g_unichar_isgraph (gunichar c) ;
gboolean g_unichar_islower (gunichar c) ;
gboolean g_unichar_isprint (gunichar c) ;
gboolean g_unichar_ispunct (gunichar c) ;
gboolean g_unichar_isspace (gunichar c) ;
gboolean g_unichar_isupper (gunichar c) ;
gboolean g_unichar_isxdigit (gunichar c) ;
gboolean g_unichar_istitle (gunichar c) ;
gboolean g_unichar_isdefined (gunichar c) ;
gboolean g_unichar_iswide (gunichar c) ;



gunichar g_unichar_toupper (gunichar c) ;
gunichar g_unichar_tolower (gunichar c) ;
gunichar g_unichar_totitle (gunichar c) ;



gint g_unichar_digit_value (gunichar c) ;

gint g_unichar_xdigit_value (gunichar c) ;


GUnicodeType g_unichar_type (gunichar c) ;


GUnicodeBreakType g_unichar_break_type (gunichar c) ;





void g_unicode_canonical_ordering (gunichar *string,
                                   gsize len);




gunichar *g_unicode_canonical_decomposition (gunichar ch,
                                             gsize *result_len);



extern const gchar * const g_utf8_skip;



gunichar g_utf8_get_char (const gchar *p);
gunichar g_utf8_get_char_validated (const gchar *p,
                                    gssize max_len);

gchar* g_utf8_offset_to_pointer (const gchar *str,
                                   glong offset);
glong g_utf8_pointer_to_offset (const gchar *str,
                                   const gchar *pos);
gchar* g_utf8_prev_char (const gchar *p);
gchar* g_utf8_find_next_char (const gchar *p,
                                   const gchar *end);
gchar* g_utf8_find_prev_char (const gchar *str,
                                   const gchar *p);

glong g_utf8_strlen (const gchar *p,
                     gssize max);


gchar* g_utf8_strncpy (gchar *dest,
                       const gchar *src,
                       gsize n);



gchar* g_utf8_strchr (const gchar *p,
                       gssize len,
                       gunichar c);
gchar* g_utf8_strrchr (const gchar *p,
                       gssize len,
                       gunichar c);
gchar* g_utf8_strreverse (const gchar *str,
                          gssize len);

gunichar2 *g_utf8_to_utf16 (const gchar *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error);
gunichar * g_utf8_to_ucs4 (const gchar *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error);
gunichar * g_utf8_to_ucs4_fast (const gchar *str,
                                glong len,
                                glong *items_written);
gunichar * g_utf16_to_ucs4 (const gunichar2 *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error);
gchar* g_utf16_to_utf8 (const gunichar2 *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error);
gunichar2 *g_ucs4_to_utf16 (const gunichar *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error);
gchar* g_ucs4_to_utf8 (const gunichar *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error);





gint g_unichar_to_utf8 (gunichar c,
                             gchar *outbuf);





gboolean g_utf8_validate (const gchar *str,
                          gssize max_len,
                          const gchar **end);


gboolean g_unichar_validate (gunichar ch);

gchar *g_utf8_strup (const gchar *str,
                       gssize len);
gchar *g_utf8_strdown (const gchar *str,
                       gssize len);
gchar *g_utf8_casefold (const gchar *str,
                        gssize len);

typedef enum {
  G_NORMALIZE_DEFAULT,
  G_NORMALIZE_NFD = G_NORMALIZE_DEFAULT,
  G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_NFC = G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_ALL,
  G_NORMALIZE_NFKD = G_NORMALIZE_ALL,
  G_NORMALIZE_ALL_COMPOSE,
  G_NORMALIZE_NFKC = G_NORMALIZE_ALL_COMPOSE
} GNormalizeMode;

gchar *g_utf8_normalize (const gchar *str,
                         gssize len,
                         GNormalizeMode mode);

gint g_utf8_collate (const gchar *str1,
                           const gchar *str2);
gchar *g_utf8_collate_key (const gchar *str,
                           gssize len);


# 32 "/usr/include/glib-2.0/glib/gstring.h" 2 3 4



typedef struct _GString GString;
typedef struct _GStringChunk GStringChunk;

struct _GString
{
  gchar *str;
  gsize len;
  gsize allocated_len;
};



GStringChunk* g_string_chunk_new (gsize size);
void g_string_chunk_free (GStringChunk *chunk);
gchar* g_string_chunk_insert (GStringChunk *chunk,
                                            const gchar *string);
gchar* g_string_chunk_insert_const (GStringChunk *chunk,
                                            const gchar *string);




GString* g_string_new (const gchar *init);
GString* g_string_new_len (const gchar *init,
                                         gssize len);
GString* g_string_sized_new (gsize dfl_size);
gchar* g_string_free (GString *string,
                                         gboolean free_segment);
gboolean g_string_equal (const GString *v,
                                         const GString *v2);
guint g_string_hash (const GString *str);
GString* g_string_assign (GString *string,
                                         const gchar *rval);
GString* g_string_truncate (GString *string,
                                         gsize len);
GString* g_string_set_size (GString *string,
                                         gsize len);
GString* g_string_insert_len (GString *string,
                                         gssize pos,
                                         const gchar *val,
                                         gssize len);
GString* g_string_append (GString *string,
                                         const gchar *val);
GString* g_string_append_len (GString *string,
                                         const gchar *val,
                                         gssize len);
GString* g_string_append_c (GString *string,
                                         gchar c);
GString* g_string_append_unichar (GString *string,
                                         gunichar wc);
GString* g_string_prepend (GString *string,
                                         const gchar *val);
GString* g_string_prepend_c (GString *string,
                                         gchar c);
GString* g_string_prepend_unichar (GString *string,
                                         gunichar wc);
GString* g_string_prepend_len (GString *string,
                                         const gchar *val,
                                         gssize len);
GString* g_string_insert (GString *string,
                                         gssize pos,
                                         const gchar *val);
GString* g_string_insert_c (GString *string,
                                         gssize pos,
                                         gchar c);
GString* g_string_insert_unichar (GString *string,
                                         gssize pos,
                                         gunichar wc);
GString* g_string_erase (GString *string,
                                         gssize pos,
                                         gssize len);
GString* g_string_ascii_down (GString *string);
GString* g_string_ascii_up (GString *string);
void g_string_printf (GString *string,
                                         const gchar *format,
                                         ...) ;
void g_string_append_printf (GString *string,
                                         const gchar *format,
                                         ...) ;
# 122 "/usr/include/glib-2.0/glib/gstring.h" 3 4
GString* g_string_down (GString *string);
GString* g_string_up (GString *string);








# 33 "/usr/include/glib-2.0/glib/giochannel.h" 2 3 4






typedef struct _GIOChannel GIOChannel;
typedef struct _GIOFuncs GIOFuncs;

typedef enum
{
  G_IO_ERROR_NONE,
  G_IO_ERROR_AGAIN,
  G_IO_ERROR_INVAL,
  G_IO_ERROR_UNKNOWN
} GIOError;



typedef enum
{

  G_IO_CHANNEL_ERROR_FBIG,
  G_IO_CHANNEL_ERROR_INVAL,
  G_IO_CHANNEL_ERROR_IO,
  G_IO_CHANNEL_ERROR_ISDIR,
  G_IO_CHANNEL_ERROR_NOSPC,
  G_IO_CHANNEL_ERROR_NXIO,
  G_IO_CHANNEL_ERROR_OVERFLOW,
  G_IO_CHANNEL_ERROR_PIPE,

  G_IO_CHANNEL_ERROR_FAILED
} GIOChannelError;

typedef enum
{
  G_IO_STATUS_ERROR,
  G_IO_STATUS_NORMAL,
  G_IO_STATUS_EOF,
  G_IO_STATUS_AGAIN
} GIOStatus;

typedef enum
{
  G_SEEK_CUR,
  G_SEEK_SET,
  G_SEEK_END
} GSeekType;

typedef enum
{
  G_IO_IN =1,
  G_IO_OUT =4,
  G_IO_PRI =2,
  G_IO_ERR =8,
  G_IO_HUP =16,
  G_IO_NVAL =32
} GIOCondition;

typedef enum
{
  G_IO_FLAG_APPEND = 1 << 0,
  G_IO_FLAG_NONBLOCK = 1 << 1,
  G_IO_FLAG_IS_READABLE = 1 << 2,
  G_IO_FLAG_IS_WRITEABLE = 1 << 3,
  G_IO_FLAG_IS_SEEKABLE = 1 << 4,
  G_IO_FLAG_MASK = (1 << 5) - 1,
  G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK,
  G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK
} GIOFlags;

struct _GIOChannel
{

  guint ref_count;
  GIOFuncs *funcs;

  gchar *encoding;
  GIConv read_cd;
  GIConv write_cd;
  gchar *line_term;
  guint line_term_len;

  gsize buf_size;
  GString *read_buf;
  GString *encoded_read_buf;
  GString *write_buf;
  gchar partial_write_buf[6];



  guint use_buffer : 1;
  guint do_encode : 1;
  guint close_on_unref : 1;
  guint is_readable : 1;
  guint is_writeable : 1;
  guint is_seekable : 1;

  gpointer reserved1;
  gpointer reserved2;
};

typedef gboolean (*GIOFunc) (GIOChannel *source,
                             GIOCondition condition,
                             gpointer data);
struct _GIOFuncs
{
  GIOStatus (*io_read) (GIOChannel *channel,
                                  gchar *buf,
                                  gsize count,
                                  gsize *bytes_read,
                                  GError **err);
  GIOStatus (*io_write) (GIOChannel *channel,
                                  const gchar *buf,
                                  gsize count,
                                  gsize *bytes_written,
                                  GError **err);
  GIOStatus (*io_seek) (GIOChannel *channel,
                                  gint64 offset,
                                  GSeekType type,
                                  GError **err);
  GIOStatus (*io_close) (GIOChannel *channel,
                                  GError **err);
  GSource* (*io_create_watch) (GIOChannel *channel,
                                  GIOCondition condition);
  void (*io_free) (GIOChannel *channel);
  GIOStatus (*io_set_flags) (GIOChannel *channel,
                                  GIOFlags flags,
                                  GError **err);
  GIOFlags (*io_get_flags) (GIOChannel *channel);
};

void g_io_channel_init (GIOChannel *channel);
void g_io_channel_ref (GIOChannel *channel);
void g_io_channel_unref (GIOChannel *channel);


GIOError g_io_channel_read (GIOChannel *channel,
                                 gchar *buf,
                                 gsize count,
                                 gsize *bytes_read);
GIOError g_io_channel_write (GIOChannel *channel,
                                 const gchar *buf,
                                 gsize count,
                                 gsize *bytes_written);
GIOError g_io_channel_seek (GIOChannel *channel,
                                 gint64 offset,
                                 GSeekType type);
void g_io_channel_close (GIOChannel *channel);


GIOStatus g_io_channel_shutdown (GIOChannel *channel,
                                 gboolean flush,
                                 GError **err);
guint g_io_add_watch_full (GIOChannel *channel,
                                 gint priority,
                                 GIOCondition condition,
                                 GIOFunc func,
                                 gpointer user_data,
                                 GDestroyNotify notify);
GSource * g_io_create_watch (GIOChannel *channel,
                                 GIOCondition condition);
guint g_io_add_watch (GIOChannel *channel,
                                 GIOCondition condition,
                                 GIOFunc func,
                                 gpointer user_data);




void g_io_channel_set_buffer_size (GIOChannel *channel,
                                                         gsize size);
gsize g_io_channel_get_buffer_size (GIOChannel *channel);
GIOCondition g_io_channel_get_buffer_condition (GIOChannel *channel);
GIOStatus g_io_channel_set_flags (GIOChannel *channel,
                                                         GIOFlags flags,
                                                         GError **error);
GIOFlags g_io_channel_get_flags (GIOChannel *channel);
void g_io_channel_set_line_term (GIOChannel *channel,
                                                         const gchar *line_term,
                                                         gint length);
const gchar* g_io_channel_get_line_term (GIOChannel *channel,
                                                         gint *length);
void g_io_channel_set_buffered (GIOChannel *channel,
                                                         gboolean buffered);
gboolean g_io_channel_get_buffered (GIOChannel *channel);
GIOStatus g_io_channel_set_encoding (GIOChannel *channel,
                                                         const gchar *encoding,
                                                         GError **error);
const gchar* g_io_channel_get_encoding (GIOChannel *channel);
void g_io_channel_set_close_on_unref (GIOChannel *channel,
                                                         gboolean do_close);
gboolean g_io_channel_get_close_on_unref (GIOChannel *channel);


GIOStatus g_io_channel_flush (GIOChannel *channel,
                                           GError **error);
GIOStatus g_io_channel_read_line (GIOChannel *channel,
                                           gchar **str_return,
                                           gsize *length,
                                           gsize *terminator_pos,
                                           GError **error);
GIOStatus g_io_channel_read_line_string (GIOChannel *channel,
                                           GString *buffer,
                                           gsize *terminator_pos,
                                           GError **error);
GIOStatus g_io_channel_read_to_end (GIOChannel *channel,
                                           gchar **str_return,
                                           gsize *length,
                                           GError **error);
GIOStatus g_io_channel_read_chars (GIOChannel *channel,
                                           gchar *buf,
                                           gsize count,
                                           gsize *bytes_read,
                                           GError **error);
GIOStatus g_io_channel_read_unichar (GIOChannel *channel,
                                           gunichar *thechar,
                                           GError **error);
GIOStatus g_io_channel_write_chars (GIOChannel *channel,
                                           const gchar *buf,
                                           gssize count,
                                           gsize *bytes_written,
                                           GError **error);
GIOStatus g_io_channel_write_unichar (GIOChannel *channel,
                                           gunichar thechar,
                                           GError **error);
GIOStatus g_io_channel_seek_position (GIOChannel *channel,
                                           gint64 offset,
                                           GSeekType type,
                                           GError **error);
GIOChannel* g_io_channel_new_file (const gchar *filename,
                                           const gchar *mode,
                                           GError **error);



GQuark g_io_channel_error_quark (void);
GIOChannelError g_io_channel_error_from_errno (gint en);
# 290 "/usr/include/glib-2.0/glib/giochannel.h" 3 4
GIOChannel* g_io_channel_unix_new (int fd);
gint g_io_channel_unix_get_fd (GIOChannel *channel);



extern GSourceFuncs g_io_watch_funcs;
# 348 "/usr/include/glib-2.0/glib/giochannel.h" 3 4

# 45 "/usr/include/glib-2.0/glib.h" 2 3 4



# 1 "/usr/include/glib-2.0/glib/gmarkup.h" 1 3 4
# 26 "/usr/include/glib-2.0/glib/gmarkup.h" 3 4


typedef enum
{
  G_MARKUP_ERROR_BAD_UTF8,
  G_MARKUP_ERROR_EMPTY,
  G_MARKUP_ERROR_PARSE,



  G_MARKUP_ERROR_UNKNOWN_ELEMENT,
  G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
  G_MARKUP_ERROR_INVALID_CONTENT
} GMarkupError;



GQuark g_markup_error_quark (void);

typedef enum
{

  G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1 << 0

} GMarkupParseFlags;

typedef struct _GMarkupParseContext GMarkupParseContext;
typedef struct _GMarkupParser GMarkupParser;

struct _GMarkupParser
{

  void (*start_element) (GMarkupParseContext *context,
                          const gchar *element_name,
                          const gchar **attribute_names,
                          const gchar **attribute_values,
                          gpointer user_data,
                          GError **error);


  void (*end_element) (GMarkupParseContext *context,
                          const gchar *element_name,
                          gpointer user_data,
                          GError **error);



  void (*text) (GMarkupParseContext *context,
                          const gchar *text,
                          gsize text_len,
                          gpointer user_data,
                          GError **error);






  void (*passthrough) (GMarkupParseContext *context,
                          const gchar *passthrough_text,
                          gsize text_len,
                          gpointer user_data,
                          GError **error);




  void (*error) (GMarkupParseContext *context,
                          GError *error,
                          gpointer user_data);
};

GMarkupParseContext *g_markup_parse_context_new (const GMarkupParser *parser,
                                                   GMarkupParseFlags flags,
                                                   gpointer user_data,
                                                   GDestroyNotify user_data_dnotify);
void g_markup_parse_context_free (GMarkupParseContext *context);
gboolean g_markup_parse_context_parse (GMarkupParseContext *context,
                                                   const gchar *text,
                                                   gssize text_len,
                                                   GError **error);

gboolean g_markup_parse_context_end_parse (GMarkupParseContext *context,
                                                       GError **error);
const gchar *g_markup_parse_context_get_element (GMarkupParseContext *context);


void g_markup_parse_context_get_position (GMarkupParseContext *context,
                                                          gint *line_number,
                                                          gint *char_number);


gchar* g_markup_escape_text (const gchar *text,
                             gssize length);


# 49 "/usr/include/glib-2.0/glib.h" 2 3 4

# 1 "/usr/include/glib-2.0/glib/gmessages.h" 1 3 4
# 40 "/usr/include/glib-2.0/glib/gmessages.h" 3 4




gsize g_printf_string_upper_bound (const gchar* format,
                                     va_list args);
# 54 "/usr/include/glib-2.0/glib/gmessages.h" 3 4
typedef enum
{

  G_LOG_FLAG_RECURSION = 1 << 0,
  G_LOG_FLAG_FATAL = 1 << 1,


  G_LOG_LEVEL_ERROR = 1 << 2,
  G_LOG_LEVEL_CRITICAL = 1 << 3,
  G_LOG_LEVEL_WARNING = 1 << 4,
  G_LOG_LEVEL_MESSAGE = 1 << 5,
  G_LOG_LEVEL_INFO = 1 << 6,
  G_LOG_LEVEL_DEBUG = 1 << 7,

  G_LOG_LEVEL_MASK = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
} GLogLevelFlags;




typedef void (*GLogFunc) (const gchar *log_domain,
                                                 GLogLevelFlags log_level,
                                                 const gchar *message,
                                                 gpointer user_data);



guint g_log_set_handler (const gchar *log_domain,
                                         GLogLevelFlags log_levels,
                                         GLogFunc log_func,
                                         gpointer user_data);
void g_log_remove_handler (const gchar *log_domain,
                                         guint handler_id);
void g_log_default_handler (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *message,
                                         gpointer unused_data);
void g_log (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *format,
                                         ...) ;
void g_logv (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *format,
                                         va_list args);
GLogLevelFlags g_log_set_fatal_mask (const gchar *log_domain,
                                         GLogLevelFlags fatal_mask);
GLogLevelFlags g_log_set_always_fatal (GLogLevelFlags fatal_mask);


void _g_log_fallback_handler (const gchar *log_domain,
                                 GLogLevelFlags log_level,
                                 const gchar *message,
                                 gpointer unused_data);
# 178 "/usr/include/glib-2.0/glib/gmessages.h" 3 4
typedef void (*GPrintFunc) (const gchar *string);
void g_print (const gchar *format,
                                         ...) ;
GPrintFunc g_set_print_handler (GPrintFunc func);
void g_printerr (const gchar *format,
                                         ...) ;
GPrintFunc g_set_printerr_handler (GPrintFunc func);
# 345 "/usr/include/glib-2.0/glib/gmessages.h" 3 4

# 51 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gnode.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gnode.h" 3 4


typedef struct _GNode GNode;


typedef enum
{
  G_TRAVERSE_LEAFS = 1 << 0,
  G_TRAVERSE_NON_LEAFS = 1 << 1,
  G_TRAVERSE_ALL = G_TRAVERSE_LEAFS | G_TRAVERSE_NON_LEAFS,
  G_TRAVERSE_MASK = 0x03
} GTraverseFlags;


typedef enum
{
  G_IN_ORDER,
  G_PRE_ORDER,
  G_POST_ORDER,
  G_LEVEL_ORDER
} GTraverseType;

typedef gboolean (*GNodeTraverseFunc) (GNode *node,
                                                 gpointer data);
typedef void (*GNodeForeachFunc) (GNode *node,
                                                 gpointer data);



struct _GNode
{
  gpointer data;
  GNode *next;
  GNode *prev;
  GNode *parent;
  GNode *children;
};






void g_node_push_allocator (GAllocator *allocator);
void g_node_pop_allocator (void);
GNode* g_node_new (gpointer data);
void g_node_destroy (GNode *root);
void g_node_unlink (GNode *node);
GNode* g_node_copy (GNode *node);
GNode* g_node_insert (GNode *parent,
                                 gint position,
                                 GNode *node);
GNode* g_node_insert_before (GNode *parent,
                                 GNode *sibling,
                                 GNode *node);
GNode* g_node_insert_after (GNode *parent,
                                 GNode *sibling,
                                 GNode *node);
GNode* g_node_prepend (GNode *parent,
                                 GNode *node);
guint g_node_n_nodes (GNode *root,
                                 GTraverseFlags flags);
GNode* g_node_get_root (GNode *node);
gboolean g_node_is_ancestor (GNode *node,
                                 GNode *descendant);
guint g_node_depth (GNode *node);
GNode* g_node_find (GNode *root,
                                 GTraverseType order,
                                 GTraverseFlags flags,
                                 gpointer data);
# 120 "/usr/include/glib-2.0/glib/gnode.h" 3 4
void g_node_traverse (GNode *root,
                                 GTraverseType order,
                                 GTraverseFlags flags,
                                 gint max_depth,
                                 GNodeTraverseFunc func,
                                 gpointer data);






guint g_node_max_height (GNode *root);

void g_node_children_foreach (GNode *node,
                                  GTraverseFlags flags,
                                  GNodeForeachFunc func,
                                  gpointer data);
void g_node_reverse_children (GNode *node);
guint g_node_n_children (GNode *node);
GNode* g_node_nth_child (GNode *node,
                                  guint n);
GNode* g_node_last_child (GNode *node);
GNode* g_node_find_child (GNode *node,
                                  GTraverseFlags flags,
                                  gpointer data);
gint g_node_child_position (GNode *node,
                                  GNode *child);
gint g_node_child_index (GNode *node,
                                  gpointer data);

GNode* g_node_first_sibling (GNode *node);
GNode* g_node_last_sibling (GNode *node);
# 161 "/usr/include/glib-2.0/glib/gnode.h" 3 4

# 52 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gpattern.h" 1 3 4
# 24 "/usr/include/glib-2.0/glib/gpattern.h" 3 4



typedef struct _GPatternSpec GPatternSpec;

GPatternSpec* g_pattern_spec_new (const gchar *pattern);
void g_pattern_spec_free (GPatternSpec *pspec);
gboolean g_pattern_spec_equal (GPatternSpec *pspec1,
                                        GPatternSpec *pspec2);
gboolean g_pattern_match (GPatternSpec *pspec,
                                        guint string_length,
                                        const gchar *string,
                                        const gchar *string_reversed);
gboolean g_pattern_match_string (GPatternSpec *pspec,
                                        const gchar *string);
gboolean g_pattern_match_simple (const gchar *pattern,
                                        const gchar *string);


# 53 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gprimes.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gprimes.h" 3 4

# 43 "/usr/include/glib-2.0/glib/gprimes.h" 3 4
guint g_spaced_primes_closest (guint num) ;


# 54 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gqsort.h" 1 3 4
# 33 "/usr/include/glib-2.0/glib/gqsort.h" 3 4


void g_qsort_with_data (gconstpointer pbase,
                        gint total_elems,
                        size_t size,
                        GCompareDataFunc compare_func,
                        gpointer user_data);


# 55 "/usr/include/glib-2.0/glib.h" 2 3 4

# 1 "/usr/include/glib-2.0/glib/gqueue.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gqueue.h" 3 4


typedef struct _GQueue GQueue;

struct _GQueue
{
  GList *head;
  GList *tail;
  guint length;
};



GQueue* g_queue_new (void);
void g_queue_free (GQueue *queue);
void g_queue_push_head (GQueue *queue,
                                 gpointer data);
void g_queue_push_tail (GQueue *queue,
                                 gpointer data);
gpointer g_queue_pop_head (GQueue *queue);
gpointer g_queue_pop_tail (GQueue *queue);
gboolean g_queue_is_empty (GQueue *queue);
gpointer g_queue_peek_head (GQueue *queue);
gpointer g_queue_peek_tail (GQueue *queue);
void g_queue_push_head_link (GQueue *queue,
                                 GList *link_);
void g_queue_push_tail_link (GQueue *queue,
                                 GList *link_);
GList* g_queue_pop_head_link (GQueue *queue);
GList* g_queue_pop_tail_link (GQueue *queue);


# 57 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/grand.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/grand.h" 3 4


typedef struct _GRand GRand;
# 45 "/usr/include/glib-2.0/glib/grand.h" 3 4
GRand* g_rand_new_with_seed (guint32 seed);
GRand* g_rand_new (void);
void g_rand_free (GRand *rand_);
void g_rand_set_seed (GRand *rand_,
                               guint32 seed);



guint32 g_rand_int (GRand *rand_);
gint32 g_rand_int_range (GRand *rand_,
                               gint32 begin,
                               gint32 end);
gdouble g_rand_double (GRand *rand_);
gdouble g_rand_double_range (GRand *rand_,
                               gdouble begin,
                               gdouble end);
void g_random_set_seed (guint32 seed);



guint32 g_random_int (void);
gint32 g_random_int_range (gint32 begin,
                               gint32 end);
gdouble g_random_double (void);
gdouble g_random_double_range (gdouble begin,
                               gdouble end);



# 58 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/grel.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/grel.h" 3 4


typedef struct _GRelation GRelation;
typedef struct _GTuples GTuples;

struct _GTuples
{
  guint len;
};
# 65 "/usr/include/glib-2.0/glib/grel.h" 3 4
GRelation* g_relation_new (gint fields);
void g_relation_destroy (GRelation *relation);
void g_relation_index (GRelation *relation,
                               gint field,
                               GHashFunc hash_func,
                               GEqualFunc key_equal_func);
void g_relation_insert (GRelation *relation,
                               ...);
gint g_relation_delete (GRelation *relation,
                               gconstpointer key,
                               gint field);
GTuples* g_relation_select (GRelation *relation,
                               gconstpointer key,
                               gint field);
gint g_relation_count (GRelation *relation,
                               gconstpointer key,
                               gint field);
gboolean g_relation_exists (GRelation *relation,
                               ...);
void g_relation_print (GRelation *relation);

void g_tuples_destroy (GTuples *tuples);
gpointer g_tuples_index (GTuples *tuples,
                               gint index_,
                               gint field);


# 59 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gscanner.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gscanner.h" 3 4


typedef struct _GScanner GScanner;
typedef struct _GScannerConfig GScannerConfig;
typedef union _GTokenValue GTokenValue;

typedef void (*GScannerMsgFunc) (GScanner *scanner,
                                                 gchar *message,
                                                 gboolean error);
# 59 "/usr/include/glib-2.0/glib/gscanner.h" 3 4
typedef enum
{
  G_ERR_UNKNOWN,
  G_ERR_UNEXP_EOF,
  G_ERR_UNEXP_EOF_IN_STRING,
  G_ERR_UNEXP_EOF_IN_COMMENT,
  G_ERR_NON_DIGIT_IN_CONST,
  G_ERR_DIGIT_RADIX,
  G_ERR_FLOAT_RADIX,
  G_ERR_FLOAT_MALFORMED
} GErrorType;


typedef enum
{
  G_TOKEN_EOF = 0,

  G_TOKEN_LEFT_PAREN = '(',
  G_TOKEN_RIGHT_PAREN = ')',
  G_TOKEN_LEFT_CURLY = '{',
  G_TOKEN_RIGHT_CURLY = '}',
  G_TOKEN_LEFT_BRACE = '[',
  G_TOKEN_RIGHT_BRACE = ']',
  G_TOKEN_EQUAL_SIGN = '=',
  G_TOKEN_COMMA = ',',

  G_TOKEN_NONE = 256,

  G_TOKEN_ERROR,

  G_TOKEN_CHAR,
  G_TOKEN_BINARY,
  G_TOKEN_OCTAL,
  G_TOKEN_INT,
  G_TOKEN_HEX,
  G_TOKEN_FLOAT,
  G_TOKEN_STRING,

  G_TOKEN_SYMBOL,
  G_TOKEN_IDENTIFIER,
  G_TOKEN_IDENTIFIER_NULL,

  G_TOKEN_COMMENT_SINGLE,
  G_TOKEN_COMMENT_MULTI,
  G_TOKEN_LAST
} GTokenType;

union _GTokenValue
{
  gpointer v_symbol;
  gchar *v_identifier;
  gulong v_binary;
  gulong v_octal;
  gulong v_int;
  guint64 v_int64;
  gdouble v_float;
  gulong v_hex;
  gchar *v_string;
  gchar *v_comment;
  guchar v_char;
  guint v_error;
};

struct _GScannerConfig
{


  gchar *cset_skip_characters;
  gchar *cset_identifier_first;
  gchar *cset_identifier_nth;
  gchar *cpair_comment_single;



  guint case_sensitive : 1;




  guint skip_comment_multi : 1;
  guint skip_comment_single : 1;
  guint scan_comment_multi : 1;
  guint scan_identifier : 1;
  guint scan_identifier_1char : 1;
  guint scan_identifier_NULL : 1;
  guint scan_symbols : 1;
  guint scan_binary : 1;
  guint scan_octal : 1;
  guint scan_float : 1;
  guint scan_hex : 1;
  guint scan_hex_dollar : 1;
  guint scan_string_sq : 1;
  guint scan_string_dq : 1;
  guint numbers_2_int : 1;
  guint int_2_float : 1;
  guint identifier_2_string : 1;
  guint char_2_token : 1;
  guint symbol_2_token : 1;
  guint scope_0_fallback : 1;
  guint store_int64 : 1;
  guint padding_dummy;
};

struct _GScanner
{

  gpointer user_data;
  guint max_parse_errors;


  guint parse_errors;


  const gchar *input_name;


  GData *qdata;


  GScannerConfig *config;


  GTokenType token;
  GTokenValue value;
  guint line;
  guint position;


  GTokenType next_token;
  GTokenValue next_value;
  guint next_line;
  guint next_position;


  GHashTable *symbol_table;
  gint input_fd;
  const gchar *text;
  const gchar *text_end;
  gchar *buffer;
  guint scope_id;


  GScannerMsgFunc msg_handler;
};

GScanner* g_scanner_new (const GScannerConfig *config_templ);
void g_scanner_destroy (GScanner *scanner);
void g_scanner_input_file (GScanner *scanner,
                                                 gint input_fd);
void g_scanner_sync_file_offset (GScanner *scanner);
void g_scanner_input_text (GScanner *scanner,
                                                 const gchar *text,
                                                 guint text_len);
GTokenType g_scanner_get_next_token (GScanner *scanner);
GTokenType g_scanner_peek_next_token (GScanner *scanner);
GTokenType g_scanner_cur_token (GScanner *scanner);
GTokenValue g_scanner_cur_value (GScanner *scanner);
guint g_scanner_cur_line (GScanner *scanner);
guint g_scanner_cur_position (GScanner *scanner);
gboolean g_scanner_eof (GScanner *scanner);
guint g_scanner_set_scope (GScanner *scanner,
                                                 guint scope_id);
void g_scanner_scope_add_symbol (GScanner *scanner,
                                                 guint scope_id,
                                                 const gchar *symbol,
                                                 gpointer value);
void g_scanner_scope_remove_symbol (GScanner *scanner,
                                                 guint scope_id,
                                                 const gchar *symbol);
gpointer g_scanner_scope_lookup_symbol (GScanner *scanner,
                                                 guint scope_id,
                                                 const gchar *symbol);
void g_scanner_scope_foreach_symbol (GScanner *scanner,
                                                 guint scope_id,
                                                 GHFunc func,
                                                 gpointer user_data);
gpointer g_scanner_lookup_symbol (GScanner *scanner,
                                                 const gchar *symbol);
void g_scanner_unexp_token (GScanner *scanner,
                                                 GTokenType expected_token,
                                                 const gchar *identifier_spec,
                                                 const gchar *symbol_spec,
                                                 const gchar *symbol_name,
                                                 const gchar *message,
                                                 gint is_error);
void g_scanner_error (GScanner *scanner,
                                                 const gchar *format,
                                                 ...) ;
void g_scanner_warn (GScanner *scanner,
                                                 const gchar *format,
                                                 ...) ;
# 271 "/usr/include/glib-2.0/glib/gscanner.h" 3 4

# 60 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gshell.h" 1 3 4
# 26 "/usr/include/glib-2.0/glib/gshell.h" 3 4




typedef enum
{

  G_SHELL_ERROR_BAD_QUOTING,

  G_SHELL_ERROR_EMPTY_STRING,
  G_SHELL_ERROR_FAILED
} GShellError;

GQuark g_shell_error_quark (void);

gchar* g_shell_quote (const gchar *unquoted_string);
gchar* g_shell_unquote (const gchar *quoted_string,
                             GError **error);
gboolean g_shell_parse_argv (const gchar *command_line,
                             gint *argcp,
                             gchar ***argvp,
                             GError **error);


# 61 "/usr/include/glib-2.0/glib.h" 2 3 4

# 1 "/usr/include/glib-2.0/glib/gspawn.h" 1 3 4
# 26 "/usr/include/glib-2.0/glib/gspawn.h" 3 4





typedef enum
{
  G_SPAWN_ERROR_FORK,
  G_SPAWN_ERROR_READ,
  G_SPAWN_ERROR_CHDIR,
  G_SPAWN_ERROR_ACCES,
  G_SPAWN_ERROR_PERM,
  G_SPAWN_ERROR_2BIG,
  G_SPAWN_ERROR_NOEXEC,
  G_SPAWN_ERROR_NAMETOOLONG,
  G_SPAWN_ERROR_NOENT,
  G_SPAWN_ERROR_NOMEM,
  G_SPAWN_ERROR_NOTDIR,
  G_SPAWN_ERROR_LOOP,
  G_SPAWN_ERROR_TXTBUSY,
  G_SPAWN_ERROR_IO,
  G_SPAWN_ERROR_NFILE,
  G_SPAWN_ERROR_MFILE,
  G_SPAWN_ERROR_INVAL,
  G_SPAWN_ERROR_ISDIR,
  G_SPAWN_ERROR_LIBBAD,
  G_SPAWN_ERROR_FAILED


} GSpawnError;

typedef void (* GSpawnChildSetupFunc) (gpointer user_data);

typedef enum
{
  G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 << 0,
  G_SPAWN_DO_NOT_REAP_CHILD = 1 << 1,

  G_SPAWN_SEARCH_PATH = 1 << 2,

  G_SPAWN_STDOUT_TO_DEV_NULL = 1 << 3,
  G_SPAWN_STDERR_TO_DEV_NULL = 1 << 4,
  G_SPAWN_CHILD_INHERITS_STDIN = 1 << 5,
  G_SPAWN_FILE_AND_ARGV_ZERO = 1 << 6
} GSpawnFlags;

GQuark g_spawn_error_quark (void);

gboolean g_spawn_async (const gchar *working_directory,
                        gchar **argv,
                        gchar **envp,
                        GSpawnFlags flags,
                        GSpawnChildSetupFunc child_setup,
                        gpointer user_data,
                        gint *child_pid,
                        GError **error);





gboolean g_spawn_async_with_pipes (const gchar *working_directory,
                                   gchar **argv,
                                   gchar **envp,
                                   GSpawnFlags flags,
                                   GSpawnChildSetupFunc child_setup,
                                   gpointer user_data,
                                   gint *child_pid,
                                   gint *standard_input,
                                   gint *standard_output,
                                   gint *standard_error,
                                   GError **error);






gboolean g_spawn_sync (const gchar *working_directory,
                               gchar **argv,
                               gchar **envp,
                               GSpawnFlags flags,
                               GSpawnChildSetupFunc child_setup,
                               gpointer user_data,
                               gchar **standard_output,
                               gchar **standard_error,
                               gint *exit_status,
                               GError **error);

gboolean g_spawn_command_line_sync (const gchar *command_line,
                                     gchar **standard_output,
                                     gchar **standard_error,
                                     gint *exit_status,
                                     GError **error);
gboolean g_spawn_command_line_async (const gchar *command_line,
                                     GError **error);



# 63 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gstrfuncs.h" 1 3 4
# 33 "/usr/include/glib-2.0/glib/gstrfuncs.h" 3 4



typedef enum {
  G_ASCII_ALNUM = 1 << 0,
  G_ASCII_ALPHA = 1 << 1,
  G_ASCII_CNTRL = 1 << 2,
  G_ASCII_DIGIT = 1 << 3,
  G_ASCII_GRAPH = 1 << 4,
  G_ASCII_LOWER = 1 << 5,
  G_ASCII_PRINT = 1 << 6,
  G_ASCII_PUNCT = 1 << 7,
  G_ASCII_SPACE = 1 << 8,
  G_ASCII_UPPER = 1 << 9,
  G_ASCII_XDIGIT = 1 << 10
} GAsciiType;

extern const guint16 * const g_ascii_table;
# 85 "/usr/include/glib-2.0/glib/gstrfuncs.h" 3 4
gchar g_ascii_tolower (gchar c) ;
gchar g_ascii_toupper (gchar c) ;

gint g_ascii_digit_value (gchar c) ;
gint g_ascii_xdigit_value (gchar c) ;





gchar* g_strdelimit (gchar *string,
                                        const gchar *delimiters,
                                        gchar new_delimiter);
gchar* g_strcanon (gchar *string,
                                        const gchar *valid_chars,
                                        gchar substitutor);
const gchar* g_strerror (gint errnum) ;
const gchar* g_strsignal (gint signum) ;
gchar* g_strreverse (gchar *string);
gsize g_strlcpy (gchar *dest,
                                        const gchar *src,
                                        gsize dest_size);
gsize g_strlcat (gchar *dest,
                                        const gchar *src,
                                        gsize dest_size);
gchar * g_strstr_len (const gchar *haystack,
                                        gssize haystack_len,
                                        const gchar *needle);
gchar * g_strrstr (const gchar *haystack,
                                        const gchar *needle);
gchar * g_strrstr_len (const gchar *haystack,
                                        gssize haystack_len,
                                        const gchar *needle);

gboolean g_str_has_suffix (const gchar *str,
                                        const gchar *suffix);
gboolean g_str_has_prefix (const gchar *str,
                                        const gchar *prefix);



gdouble g_strtod (const gchar *nptr,
                                        gchar **endptr);
gdouble g_ascii_strtod (const gchar *nptr,
                                        gchar **endptr);
guint64 g_ascii_strtoull (const gchar *nptr,
                                        gchar **endptr,
                                        guint base);




gchar * g_ascii_dtostr (gchar *buffer,
                                        gint buf_len,
                                        gdouble d);
gchar * g_ascii_formatd (gchar *buffer,
                                        gint buf_len,
                                        const gchar *format,
                                        gdouble d);


gchar* g_strchug (gchar *string);

gchar* g_strchomp (gchar *string);



gint g_ascii_strcasecmp (const gchar *s1,
                                           const gchar *s2);
gint g_ascii_strncasecmp (const gchar *s1,
                                           const gchar *s2,
                                           gsize n);
gchar* g_ascii_strdown (const gchar *str,
                                           gssize len);
gchar* g_ascii_strup (const gchar *str,
                                           gssize len);
# 169 "/usr/include/glib-2.0/glib/gstrfuncs.h" 3 4
gint g_strcasecmp (const gchar *s1,
                                        const gchar *s2);
gint g_strncasecmp (const gchar *s1,
                                        const gchar *s2,
                                        guint n);
gchar* g_strdown (gchar *string);
gchar* g_strup (gchar *string);






gchar* g_strdup (const gchar *str);
gchar* g_strdup_printf (const gchar *format,
                                        ...) ;
gchar* g_strdup_vprintf (const gchar *format,
                                        va_list args);
gchar* g_strndup (const gchar *str,
                                        gsize n);
gchar* g_strnfill (gsize length,
                                        gchar fill_char);
gchar* g_strconcat (const gchar *string1,
                                        ...);
gchar* g_strjoin (const gchar *separator,
                                        ...);




gchar* g_strcompress (const gchar *source);
# 209 "/usr/include/glib-2.0/glib/gstrfuncs.h" 3 4
gchar* g_strescape (const gchar *source,
                                        const gchar *exceptions);

gpointer g_memdup (gconstpointer mem,
                                        guint byte_size);
# 223 "/usr/include/glib-2.0/glib/gstrfuncs.h" 3 4
gchar** g_strsplit (const gchar *string,
                                        const gchar *delimiter,
                                        gint max_tokens);
gchar* g_strjoinv (const gchar *separator,
                                        gchar **str_array);
void g_strfreev (gchar **str_array);
gchar** g_strdupv (gchar **str_array);

gchar* g_stpcpy (gchar *dest,
                                        const char *src);


# 64 "/usr/include/glib-2.0/glib.h" 2 3 4


# 1 "/usr/include/glib-2.0/glib/gthreadpool.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gthreadpool.h" 3 4


typedef struct _GThreadPool GThreadPool;






struct _GThreadPool
{
  GFunc func;
  gpointer user_data;
  gboolean exclusive;
};






GThreadPool* g_thread_pool_new (GFunc func,
                                               gpointer user_data,
                                               gint max_threads,
                                               gboolean exclusive,
                                               GError **error);





void g_thread_pool_push (GThreadPool *pool,
                                               gpointer data,
                                               GError **error);




void g_thread_pool_set_max_threads (GThreadPool *pool,
                                               gint max_threads,
                                               GError **error);
gint g_thread_pool_get_max_threads (GThreadPool *pool);



guint g_thread_pool_get_num_threads (GThreadPool *pool);


guint g_thread_pool_unprocessed (GThreadPool *pool);





void g_thread_pool_free (GThreadPool *pool,
                                               gboolean immediate,
                                               gboolean wait);



void g_thread_pool_set_max_unused_threads (gint max_threads);
gint g_thread_pool_get_max_unused_threads (void);
guint g_thread_pool_get_num_unused_threads (void);


void g_thread_pool_stop_unused_threads (void);


# 67 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gtimer.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gtimer.h" 3 4






typedef struct _GTimer GTimer;



GTimer* g_timer_new (void);
void g_timer_destroy (GTimer *timer);
void g_timer_start (GTimer *timer);
void g_timer_stop (GTimer *timer);
void g_timer_reset (GTimer *timer);
gdouble g_timer_elapsed (GTimer *timer,
                         gulong *microseconds);

void g_usleep (gulong microseconds);

void g_time_val_add (GTimeVal *time_,
                         glong microseconds);


# 68 "/usr/include/glib-2.0/glib.h" 2 3 4
# 1 "/usr/include/glib-2.0/glib/gtree.h" 1 3 4
# 32 "/usr/include/glib-2.0/glib/gtree.h" 3 4


typedef struct _GTree GTree;

typedef gboolean (*GTraverseFunc) (gpointer key,
                                   gpointer value,
                                   gpointer data);



GTree* g_tree_new (GCompareFunc key_compare_func);
GTree* g_tree_new_with_data (GCompareDataFunc key_compare_func,
                                 gpointer key_compare_data);
GTree* g_tree_new_full (GCompareDataFunc key_compare_func,
                                 gpointer key_compare_data,
                                 GDestroyNotify key_destroy_func,
                                 GDestroyNotify value_destroy_func);
void g_tree_destroy (GTree *tree);
void g_tree_insert (GTree *tree,
                                 gpointer key,
                                 gpointer value);
void g_tree_replace (GTree *tree,
                                 gpointer key,
                                 gpointer value);
void g_tree_remove (GTree *tree,
                                 gconstpointer key);
void g_tree_steal (GTree *tree,
                                 gconstpointer key);
gpointer g_tree_lookup (GTree *tree,
                                 gconstpointer key);
gboolean g_tree_lookup_extended (GTree *tree,
                                 gconstpointer lookup_key,
                                 gpointer *orig_key,
                                 gpointer *value);
void g_tree_foreach (GTree *tree,
                                 GTraverseFunc func,
                                 gpointer user_data);


void g_tree_traverse (GTree *tree,
                                 GTraverseFunc traverse_func,
                                 GTraverseType traverse_type,
                                 gpointer user_data);


gpointer g_tree_search (GTree *tree,
                                 GCompareFunc search_func,
                                 gconstpointer user_data);
gint g_tree_height (GTree *tree);
gint g_tree_nnodes (GTree *tree);




# 69 "/usr/include/glib-2.0/glib.h" 2 3 4


# 1 "/usr/include/glib-2.0/glib/gutils.h" 1 3 4
# 33 "/usr/include/glib-2.0/glib/gutils.h" 3 4

# 116 "/usr/include/glib-2.0/glib/gutils.h" 3 4
const gchar* g_get_user_name (void);
const gchar* g_get_real_name (void);
const gchar* g_get_home_dir (void);
const gchar* g_get_tmp_dir (void);
gchar* g_get_prgname (void);
void g_set_prgname (const gchar *prgname);
const gchar* g_get_application_name (void);
void g_set_application_name (const gchar *application_name);


typedef struct _GDebugKey GDebugKey;
struct _GDebugKey
{
  gchar *key;
  guint value;
};



guint g_parse_debug_string (const gchar *string,
                                            const GDebugKey *keys,
                                            guint nkeys);

gint g_snprintf (gchar *string,
                                            gulong n,
                                            gchar const *format,
                                            ...) ;
gint g_vsnprintf (gchar *string,
                                            gulong n,
                                            gchar const *format,
                                            va_list args);


gboolean g_path_is_absolute (const gchar *file_name);


const gchar* g_path_skip_root (const gchar *file_name);







const gchar* g_basename (const gchar *file_name);





gchar* g_get_current_dir (void);
gchar* g_path_get_basename (const gchar *file_name);
gchar* g_path_get_dirname (const gchar *file_name);



void g_nullify_pointer (gpointer *nullify_location);






const gchar* g_getenv (const gchar *variable);






typedef void (*GVoidFunc) (void);
# 197 "/usr/include/glib-2.0/glib/gutils.h" 3 4
void g_atexit (GVoidFunc func);


gchar* g_find_program_in_path (const gchar *program);



static inline gint g_bit_nth_lsf (gulong mask,
                                       gint nth_bit);
static inline gint g_bit_nth_msf (gulong mask,
                                       gint nth_bit);
static inline guint g_bit_storage (gulong number);




typedef struct _GTrashStack GTrashStack;
struct _GTrashStack
{
  GTrashStack *next;
};

static inline void g_trash_stack_push (GTrashStack **stack_p,
                                                 gpointer data_p);
static inline gpointer g_trash_stack_pop (GTrashStack **stack_p);
static inline gpointer g_trash_stack_peek (GTrashStack **stack_p);
static inline guint g_trash_stack_height (GTrashStack **stack_p);




static inline gint
g_bit_nth_lsf (gulong mask,
               gint nth_bit)
{
  do
    {
      nth_bit++;
      if (mask & (1 << (gulong) nth_bit))
        return nth_bit;
    }
  while (nth_bit < 31);
  return -1;
}
static inline gint
g_bit_nth_msf (gulong mask,
               gint nth_bit)
{
  if (nth_bit < 0)
    nth_bit = 4 * 8;
  do
    {
      nth_bit--;
      if (mask & (1 << (gulong) nth_bit))
        return nth_bit;
    }
  while (nth_bit > 0);
  return -1;
}
static inline guint
g_bit_storage (gulong number)
{
  register guint n_bits = 0;

  do
    {
      n_bits++;
      number >>= 1;
    }
  while (number);
  return n_bits;
}
static inline void
g_trash_stack_push (GTrashStack **stack_p,
                    gpointer data_p)
{
  GTrashStack *data = (GTrashStack *) data_p;

  data->next = *stack_p;
  *stack_p = data;
}
static inline gpointer
g_trash_stack_pop (GTrashStack **stack_p)
{
  GTrashStack *data;

  data = *stack_p;
  if (data)
    {
      *stack_p = data->next;



      data->next = ((void *)0);
    }

  return data;
}
static inline gpointer
g_trash_stack_peek (GTrashStack **stack_p)
{
  GTrashStack *data;

  data = *stack_p;

  return data;
}
static inline guint
g_trash_stack_height (GTrashStack **stack_p)
{
  GTrashStack *data;
  guint i = 0;

  for (data = *stack_p; data; data = data->next)
    i++;

  return i;
}






extern const guint glib_major_version;
extern const guint glib_minor_version;
extern const guint glib_micro_version;
extern const guint glib_interface_age;
extern const guint glib_binary_age;








# 72 "/usr/include/glib-2.0/glib.h" 2 3 4
# 40 "/usr/include/gtk++/gtypedefs.hpp" 2 3 4
# 150 "/usr/include/gtk++/gtypedefs.hpp" 3 4
namespace lgtkpp
{

  typedef gint loop_index;
  typedef gpointer void_data_ptr;
  typedef gint list_index;

  typedef gdouble seconde;
  typedef guint milli_sec;
  typedef gulong micro_sec;

  inline gchar* StrToGchar(std::string const & aString)
    {
      if (aString.length() == 0)
        return ((void *)0);
      gchar* Chars = new gchar [aString.length() + 1];
      aString.copy (Chars, aString.length());
      Chars[aString.length()] = '\0';
      return Chars;
    }


}
# 44 "/usr/include/gtk++/gtktypedefs.hpp" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtk.h" 1 3 4
# 31 "/usr/include/gtk-2.0/gtk/gtk.h" 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdk.h" 1 3 4
# 30 "/usr/include/gtk-2.0/gdk/gdk.h" 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkcolor.h" 1 3 4



# 1 "/usr/include/gtk-2.0/gdk/gdktypes.h" 1 3 4
# 33 "/usr/include/gtk-2.0/gdk/gdktypes.h" 3 4
# 1 "/usr/include/pango-1.0/pango/pango.h" 1 3 4
# 25 "/usr/include/pango-1.0/pango/pango.h" 3 4
# 1 "/usr/include/pango-1.0/pango/pango-attributes.h" 1 3 4
# 25 "/usr/include/pango-1.0/pango/pango-attributes.h" 3 4
# 1 "/usr/include/pango-1.0/pango/pango-font.h" 1 3 4
# 25 "/usr/include/pango-1.0/pango/pango-font.h" 3 4
# 1 "/usr/include/pango-1.0/pango/pango-coverage.h" 1 3 4
# 27 "/usr/include/pango-1.0/pango/pango-coverage.h" 3 4


typedef struct _PangoCoverage PangoCoverage;

typedef enum {
  PANGO_COVERAGE_NONE,
  PANGO_COVERAGE_FALLBACK,
  PANGO_COVERAGE_APPROXIMATE,
  PANGO_COVERAGE_EXACT
} PangoCoverageLevel;

PangoCoverage * pango_coverage_new (void);
PangoCoverage * pango_coverage_ref (PangoCoverage *coverage);
void pango_coverage_unref (PangoCoverage *coverage);
PangoCoverage * pango_coverage_copy (PangoCoverage *coverage);
PangoCoverageLevel pango_coverage_get (PangoCoverage *coverage,
                                           int index_);
void pango_coverage_set (PangoCoverage *coverage,
                                           int index_,
                                           PangoCoverageLevel level);
void pango_coverage_max (PangoCoverage *coverage,
                                           PangoCoverage *other);

void pango_coverage_to_bytes (PangoCoverage *coverage,
                                          guchar **bytes,
                                          int *n_bytes);
PangoCoverage *pango_coverage_from_bytes (guchar *bytes,
                                          int n_bytes);


# 26 "/usr/include/pango-1.0/pango/pango-font.h" 2 3 4
# 1 "/usr/include/pango-1.0/pango/pango-types.h" 1 3 4
# 26 "/usr/include/pango-1.0/pango/pango-types.h" 3 4
# 1 "/usr/include/glib-2.0/glib-object.h" 1 3 4
# 25 "/usr/include/glib-2.0/glib-object.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gboxed.h" 1 3 4
# 26 "/usr/include/glib-2.0/gobject/gboxed.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1 3 4
# 28 "/usr/include/glib-2.0/gobject/gtype.h" 3 4

# 92 "/usr/include/glib-2.0/gobject/gtype.h" 3 4
typedef gulong GType;



typedef struct _GValue GValue;
typedef union _GTypeCValue GTypeCValue;
typedef struct _GTypePlugin GTypePlugin;
typedef struct _GTypeClass GTypeClass;
typedef struct _GTypeInterface GTypeInterface;
typedef struct _GTypeInstance GTypeInstance;
typedef struct _GTypeInfo GTypeInfo;
typedef struct _GTypeFundamentalInfo GTypeFundamentalInfo;
typedef struct _GInterfaceInfo GInterfaceInfo;
typedef struct _GTypeValueTable GTypeValueTable;
typedef struct _GTypeQuery GTypeQuery;




struct _GTypeClass
{

  GType g_type;
};
struct _GTypeInstance
{

  GTypeClass *g_class;
};
struct _GTypeInterface
{

  GType g_type;
  GType g_instance_type;
};
struct _GTypeQuery
{
  GType type;
  const gchar *type_name;
  guint class_size;
  guint instance_size;
};
# 155 "/usr/include/glib-2.0/gobject/gtype.h" 3 4
typedef enum
{
  G_TYPE_DEBUG_NONE = 0,
  G_TYPE_DEBUG_OBJECTS = 1 << 0,
  G_TYPE_DEBUG_SIGNALS = 1 << 1,
  G_TYPE_DEBUG_MASK = 0x03
} GTypeDebugFlags;



void g_type_init (void);
void g_type_init_with_debug_flags (GTypeDebugFlags debug_flags);
const gchar* g_type_name (GType type);
GQuark g_type_qname (GType type);
GType g_type_from_name (const gchar *name);
GType g_type_parent (GType type);
guint g_type_depth (GType type);
GType g_type_next_base (GType leaf_type,
                                                      GType root_type);
gboolean g_type_is_a (GType type,
                                                      GType is_a_type);
gpointer g_type_class_ref (GType type);
gpointer g_type_class_peek (GType type);
void g_type_class_unref (gpointer g_class);
gpointer g_type_class_peek_parent (gpointer g_class);
gpointer g_type_interface_peek (gpointer instance_class,
                                                      GType iface_type);
gpointer g_type_interface_peek_parent (gpointer g_iface);


GType* g_type_children (GType type,
                                                      guint *n_children);
GType* g_type_interfaces (GType type,
                                                      guint *n_interfaces);


void g_type_set_qdata (GType type,
                                                      GQuark quark,
                                                      gpointer data);
gpointer g_type_get_qdata (GType type,
                                                      GQuark quark);
void g_type_query (GType type,
                                                      GTypeQuery *query);



typedef void (*GBaseInitFunc) (gpointer g_class);
typedef void (*GBaseFinalizeFunc) (gpointer g_class);
typedef void (*GClassInitFunc) (gpointer g_class,
                                              gpointer class_data);
typedef void (*GClassFinalizeFunc) (gpointer g_class,
                                              gpointer class_data);
typedef void (*GInstanceInitFunc) (GTypeInstance *instance,
                                              gpointer g_class);
typedef void (*GInterfaceInitFunc) (gpointer g_iface,
                                              gpointer iface_data);
typedef void (*GInterfaceFinalizeFunc) (gpointer g_iface,
                                              gpointer iface_data);
typedef gboolean (*GTypeClassCacheFunc) (gpointer cache_data,
                                              GTypeClass *g_class);
typedef enum
{
  G_TYPE_FLAG_CLASSED = (1 << 0),
  G_TYPE_FLAG_INSTANTIATABLE = (1 << 1),
  G_TYPE_FLAG_DERIVABLE = (1 << 2),
  G_TYPE_FLAG_DEEP_DERIVABLE = (1 << 3)
} GTypeFundamentalFlags;
typedef enum
{
  G_TYPE_FLAG_ABSTRACT = (1 << 4),
  G_TYPE_FLAG_VALUE_ABSTRACT = (1 << 5)
} GTypeFlags;
struct _GTypeInfo
{

  guint16 class_size;

  GBaseInitFunc base_init;
  GBaseFinalizeFunc base_finalize;


  GClassInitFunc class_init;
  GClassFinalizeFunc class_finalize;
  gconstpointer class_data;


  guint16 instance_size;
  guint16 n_preallocs;
  GInstanceInitFunc instance_init;


  const GTypeValueTable *value_table;
};
struct _GTypeFundamentalInfo
{
  GTypeFundamentalFlags type_flags;
};
struct _GInterfaceInfo
{
  GInterfaceInitFunc interface_init;
  GInterfaceFinalizeFunc interface_finalize;
  gpointer interface_data;
};
struct _GTypeValueTable
{
  void (*value_init) (GValue *value);
  void (*value_free) (GValue *value);
  void (*value_copy) (const GValue *src_value,
                                  GValue *dest_value);

  gpointer (*value_peek_pointer) (const GValue *value);
  gchar *collect_format;
  gchar* (*collect_value) (GValue *value,
                                  guint n_collect_values,
                                  GTypeCValue *collect_values,
                                  guint collect_flags);
  gchar *lcopy_format;
  gchar* (*lcopy_value) (const GValue *value,
                                  guint n_collect_values,
                                  GTypeCValue *collect_values,
                                  guint collect_flags);
};
GType g_type_register_static (GType parent_type,
                                         const gchar *type_name,
                                         const GTypeInfo *info,
                                         GTypeFlags flags);
GType g_type_register_dynamic (GType parent_type,
                                         const gchar *type_name,
                                         GTypePlugin *plugin,
                                         GTypeFlags flags);
GType g_type_register_fundamental (GType type_id,
                                         const gchar *type_name,
                                         const GTypeInfo *info,
                                         const GTypeFundamentalInfo *finfo,
                                         GTypeFlags flags);
void g_type_add_interface_static (GType instance_type,
                                         GType interface_type,
                                         const GInterfaceInfo *info);
void g_type_add_interface_dynamic (GType instance_type,
                                         GType interface_type,
                                         GTypePlugin *plugin);
void g_type_interface_add_prerequisite (GType interface_type,
                                         GType prerequisite_type);
GType *g_type_interface_prerequisites (GType interface_type,
                                         guint *n_prerequisites);



GTypePlugin* g_type_get_plugin (GType type);
GTypePlugin* g_type_interface_get_plugin (GType instance_type,
                                                 GType interface_type);
GType g_type_fundamental_next (void);
GType g_type_fundamental (GType type_id);
GTypeInstance* g_type_create_instance (GType type);
void g_type_free_instance (GTypeInstance *instance);
void g_type_add_class_cache_func (gpointer cache_data,
                                                 GTypeClassCacheFunc cache_func);
void g_type_remove_class_cache_func (gpointer cache_data,
                                                 GTypeClassCacheFunc cache_func);
void g_type_class_unref_uncached (gpointer g_class);
GTypeValueTable* g_type_value_table_peek (GType type);



gboolean g_type_check_instance (GTypeInstance *instance);
GTypeInstance* g_type_check_instance_cast (GTypeInstance *instance,
                                                 GType iface_type);
gboolean g_type_check_instance_is_a (GTypeInstance *instance,
                                                 GType iface_type);
GTypeClass* g_type_check_class_cast (GTypeClass *g_class,
                                                 GType is_a_type);
gboolean g_type_check_class_is_a (GTypeClass *g_class,
                                                 GType is_a_type);
gboolean g_type_check_is_value_type (GType type);
gboolean g_type_check_value (GValue *value);
gboolean g_type_check_value_holds (GValue *value,
                                                 GType type);
gboolean g_type_test_flags (GType type,
                                                 guint flags);



const gchar* g_type_name_from_instance (GTypeInstance *instance);
const gchar* g_type_name_from_class (GTypeClass *g_class);
# 378 "/usr/include/glib-2.0/gobject/gtype.h" 3 4
extern GTypeDebugFlags _g_type_debug_flags;


# 27 "/usr/include/glib-2.0/gobject/gboxed.h" 2 3 4









typedef gpointer (*GBoxedCopyFunc) (gpointer boxed);
typedef void (*GBoxedFreeFunc) (gpointer boxed);



gpointer g_boxed_copy (GType boxed_type,
                                                 gconstpointer src_boxed);
void g_boxed_free (GType boxed_type,
                                                 gpointer boxed);
void g_value_set_boxed (GValue *value,
                                                 gconstpointer v_boxed);
void g_value_set_static_boxed (GValue *value,
                                                 gconstpointer v_boxed);
gpointer g_value_get_boxed (const GValue *value);
gpointer g_value_dup_boxed (const GValue *value);



GType g_boxed_type_register_static (const gchar *name,
                                                 GBoxedCopyFunc boxed_copy,
                                                 GBoxedFreeFunc boxed_free);
# 67 "/usr/include/glib-2.0/gobject/gboxed.h" 3 4
void g_value_set_boxed_take_ownership (GValue *value,
                                                 gconstpointer v_boxed);
GType g_closure_get_type (void) ;
GType g_value_get_type (void) ;
GType g_value_array_get_type (void) ;
GType g_gstring_get_type (void) ;


# 26 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/genums.h" 1 3 4
# 26 "/usr/include/glib-2.0/gobject/genums.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1 3 4
# 27 "/usr/include/glib-2.0/gobject/genums.h" 2 3 4


# 46 "/usr/include/glib-2.0/gobject/genums.h" 3 4
typedef struct _GEnumClass GEnumClass;
typedef struct _GFlagsClass GFlagsClass;
typedef struct _GEnumValue GEnumValue;
typedef struct _GFlagsValue GFlagsValue;
struct _GEnumClass
{
  GTypeClass g_type_class;

  gint minimum;
  gint maximum;
  guint n_values;
  GEnumValue *values;
};
struct _GFlagsClass
{
  GTypeClass g_type_class;

  guint mask;
  guint n_values;
  GFlagsValue *values;
};
struct _GEnumValue
{
  gint value;
  gchar *value_name;
  gchar *value_nick;
};
struct _GFlagsValue
{
  guint value;
  gchar *value_name;
  gchar *value_nick;
};



GEnumValue* g_enum_get_value (GEnumClass *enum_class,
                                                 gint value);
GEnumValue* g_enum_get_value_by_name (GEnumClass *enum_class,
                                                 const gchar *name);
GEnumValue* g_enum_get_value_by_nick (GEnumClass *enum_class,
                                                 const gchar *nick);
GFlagsValue* g_flags_get_first_value (GFlagsClass *flags_class,
                                                 guint value);
GFlagsValue* g_flags_get_value_by_name (GFlagsClass *flags_class,
                                                 const gchar *name);
GFlagsValue* g_flags_get_value_by_nick (GFlagsClass *flags_class,
                                                 const gchar *nick);
void g_value_set_enum (GValue *value,
                                                 gint v_enum);
gint g_value_get_enum (const GValue *value);
void g_value_set_flags (GValue *value,
                                                 guint v_flags);
guint g_value_get_flags (const GValue *value);







GType g_enum_register_static (const gchar *name,
                                    const GEnumValue *const_static_values);
GType g_flags_register_static (const gchar *name,
                                    const GFlagsValue *const_static_values);



void g_enum_complete_type_info (GType g_enum_type,
                                    GTypeInfo *info,
                                    const GEnumValue *const_values);
void g_flags_complete_type_info (GType g_flags_type,
                                    GTypeInfo *info,
                                    const GFlagsValue *const_values);


# 27 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gobject.h" 1 3 4
# 26 "/usr/include/glib-2.0/gobject/gobject.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1 3 4
# 27 "/usr/include/glib-2.0/gobject/gobject.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1 3 4
# 28 "/usr/include/glib-2.0/gobject/gvalue.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1 3 4
# 29 "/usr/include/glib-2.0/gobject/gvalue.h" 2 3 4


# 41 "/usr/include/glib-2.0/gobject/gvalue.h" 3 4
typedef void (*GValueTransform) (const GValue *src_value,
                                 GValue *dest_value);
struct _GValue
{

  GType g_type;


  union {
    gint v_int;
    guint v_uint;
    glong v_long;
    gulong v_ulong;
    gint64 v_int64;
    guint64 v_uint64;
    gfloat v_float;
    gdouble v_double;
    gpointer v_pointer;
  } data[2];
};



GValue* g_value_init (GValue *value,
                                         GType g_type);
void g_value_copy (const GValue *src_value,
                                         GValue *dest_value);
GValue* g_value_reset (GValue *value);
void g_value_unset (GValue *value);
void g_value_set_instance (GValue *value,
                                         gpointer instance);



gboolean g_value_fits_pointer (const GValue *value);
gpointer g_value_peek_pointer (const GValue *value);



gboolean g_value_type_compatible (GType src_type,
                                         GType dest_type);
gboolean g_value_type_transformable (GType src_type,
                                         GType dest_type);
gboolean g_value_transform (const GValue *src_value,
                                         GValue *dest_value);
void g_value_register_transform_func (GType src_type,
                                         GType dest_type,
                                         GValueTransform transform_func);




# 28 "/usr/include/glib-2.0/gobject/gobject.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gparam.h" 1 3 4
# 28 "/usr/include/glib-2.0/gobject/gparam.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1 3 4
# 29 "/usr/include/glib-2.0/gobject/gparam.h" 2 3 4


# 49 "/usr/include/glib-2.0/gobject/gparam.h" 3 4
typedef enum
{
  G_PARAM_READABLE = 1 << 0,
  G_PARAM_WRITABLE = 1 << 1,
  G_PARAM_CONSTRUCT = 1 << 2,
  G_PARAM_CONSTRUCT_ONLY = 1 << 3,
  G_PARAM_LAX_VALIDATION = 1 << 4,
  G_PARAM_PRIVATE = 1 << 5
} GParamFlags;







typedef struct _GParamSpec GParamSpec;
typedef struct _GParamSpecClass GParamSpecClass;
typedef struct _GParameter GParameter;
typedef struct _GParamSpecPool GParamSpecPool;
struct _GParamSpec
{
  GTypeInstance g_type_instance;

  gchar *name;
  GParamFlags flags;
  GType value_type;
  GType owner_type;


  gchar *_nick;
  gchar *_blurb;
  GData *qdata;
  guint ref_count;
  guint param_id;
};
struct _GParamSpecClass
{
  GTypeClass g_type_class;

  GType value_type;

  void (*finalize) (GParamSpec *pspec);


  void (*value_set_default) (GParamSpec *pspec,
                                         GValue *value);
  gboolean (*value_validate) (GParamSpec *pspec,
                                         GValue *value);
  gint (*values_cmp) (GParamSpec *pspec,
                                         const GValue *value1,
                                         const GValue *value2);
  gpointer dummy[4];
};
struct _GParameter
{
  const gchar *name;
  GValue value;
};



GParamSpec* g_param_spec_ref (GParamSpec *pspec);
void g_param_spec_unref (GParamSpec *pspec);
void g_param_spec_sink (GParamSpec *pspec);
gpointer g_param_spec_get_qdata (GParamSpec *pspec,
                                                 GQuark quark);
void g_param_spec_set_qdata (GParamSpec *pspec,
                                                 GQuark quark,
                                                 gpointer data);
void g_param_spec_set_qdata_full (GParamSpec *pspec,
                                                 GQuark quark,
                                                 gpointer data,
                                                 GDestroyNotify destroy);
gpointer g_param_spec_steal_qdata (GParamSpec *pspec,
                                                 GQuark quark);
void g_param_value_set_default (GParamSpec *pspec,
                                                 GValue *value);
gboolean g_param_value_defaults (GParamSpec *pspec,
                                                 GValue *value);
gboolean g_param_value_validate (GParamSpec *pspec,
                                                 GValue *value);
gboolean g_param_value_convert (GParamSpec *pspec,
                                                 const GValue *src_value,
                                                 GValue *dest_value,
                                                 gboolean strict_validation);
gint g_param_values_cmp (GParamSpec *pspec,
                                                 const GValue *value1,
                                                 const GValue *value2);
const gchar* g_param_spec_get_name (GParamSpec *pspec);
const gchar* g_param_spec_get_nick (GParamSpec *pspec);
const gchar* g_param_spec_get_blurb (GParamSpec *pspec);
void g_value_set_param (GValue *value,
                                                 GParamSpec *param);
GParamSpec* g_value_get_param (const GValue *value);
GParamSpec* g_value_dup_param (const GValue *value);



void g_value_set_param_take_ownership (GValue *value,
                                                 GParamSpec *param);



typedef struct _GParamSpecTypeInfo GParamSpecTypeInfo;
struct _GParamSpecTypeInfo
{

  guint16 instance_size;
  guint16 n_preallocs;
  void (*instance_init) (GParamSpec *pspec);


  GType value_type;
  void (*finalize) (GParamSpec *pspec);
  void (*value_set_default) (GParamSpec *pspec,
                                         GValue *value);
  gboolean (*value_validate) (GParamSpec *pspec,
                                         GValue *value);
  gint (*values_cmp) (GParamSpec *pspec,
                                         const GValue *value1,
                                         const GValue *value2);
};
GType g_param_type_register_static (const gchar *name,
                                         const GParamSpecTypeInfo *pspec_info);


GType _g_param_type_register_static_constant (const gchar *name,
                                               const GParamSpecTypeInfo *pspec_info,
                                               GType opt_type);



gpointer g_param_spec_internal (GType param_type,
                                                 const gchar *name,
                                                 const gchar *nick,
                                                 const gchar *blurb,
                                                 GParamFlags flags);
GParamSpecPool* g_param_spec_pool_new (gboolean type_prefixing);
void g_param_spec_pool_insert (GParamSpecPool *pool,
                                                 GParamSpec *pspec,
                                                 GType owner_type);
void g_param_spec_pool_remove (GParamSpecPool *pool,
                                                 GParamSpec *pspec);
GParamSpec* g_param_spec_pool_lookup (GParamSpecPool *pool,
                                                 const gchar *param_name,
                                                 GType owner_type,
                                                 gboolean walk_ancestors);
GList* g_param_spec_pool_list_owned (GParamSpecPool *pool,
                                                 GType owner_type);
GParamSpec** g_param_spec_pool_list (GParamSpecPool *pool,
                                                 GType owner_type,
                                                 guint *n_pspecs_p);
# 221 "/usr/include/glib-2.0/gobject/gparam.h" 3 4

# 29 "/usr/include/glib-2.0/gobject/gobject.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gclosure.h" 1 3 4
# 26 "/usr/include/glib-2.0/gobject/gclosure.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1 3 4
# 27 "/usr/include/glib-2.0/gobject/gclosure.h" 2 3 4


# 39 "/usr/include/glib-2.0/gobject/gclosure.h" 3 4
typedef struct _GClosure GClosure;
typedef struct _GClosureNotifyData GClosureNotifyData;
typedef void (*GCallback) (void);
typedef void (*GClosureNotify) (gpointer data,
                                         GClosure *closure);
typedef void (*GClosureMarshal) (GClosure *closure,
                                         GValue *return_value,
                                         guint n_param_values,
                                         const GValue *param_values,
                                         gpointer invocation_hint,
                                         gpointer marshal_data);
typedef struct _GCClosure GCClosure;



struct _GClosureNotifyData
{
  gpointer data;
  GClosureNotify notify;
};
struct _GClosure
{
                        guint ref_count : 15;
                        guint meta_marshal : 1;
                        guint n_guards : 1;
                        guint n_fnotifiers : 2;
                        guint n_inotifiers : 8;
                        guint in_inotify : 1;
                        guint floating : 1;
                        guint derivative_flag : 1;
                        guint in_marshal : 1;
                        guint is_invalid : 1;

                        void (*marshal) (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
                        gpointer data;

                        GClosureNotifyData *notifiers;
# 92 "/usr/include/glib-2.0/gobject/gclosure.h" 3 4
};


struct _GCClosure
{
  GClosure closure;
  gpointer callback;
};



GClosure* g_cclosure_new (GCallback callback_func,
                                                 gpointer user_data,
                                                 GClosureNotify destroy_data);
GClosure* g_cclosure_new_swap (GCallback callback_func,
                                                 gpointer user_data,
                                                 GClosureNotify destroy_data);
GClosure* g_signal_type_cclosure_new (GType itype,
                                                 guint struct_offset);



GClosure* g_closure_ref (GClosure *closure);
void g_closure_sink (GClosure *closure);
void g_closure_unref (GClosure *closure);

GClosure* g_closure_new_simple (guint sizeof_closure,
                                                 gpointer data);
void g_closure_add_finalize_notifier (GClosure *closure,
                                                 gpointer notify_data,
                                                 GClosureNotify notify_func);
void g_closure_remove_finalize_notifier (GClosure *closure,
                                                 gpointer notify_data,
                                                 GClosureNotify notify_func);
void g_closure_add_invalidate_notifier (GClosure *closure,
                                                 gpointer notify_data,
                                                 GClosureNotify notify_func);
void g_closure_remove_invalidate_notifier (GClosure *closure,
                                                 gpointer notify_data,
                                                 GClosureNotify notify_func);
void g_closure_add_marshal_guards (GClosure *closure,
                                                 gpointer pre_marshal_data,
                                                 GClosureNotify pre_marshal_notify,
                                                 gpointer post_marshal_data,
                                                 GClosureNotify post_marshal_notify);
void g_closure_set_marshal (GClosure *closure,
                                                 GClosureMarshal marshal);
void g_closure_set_meta_marshal (GClosure *closure,
                                                 gpointer marshal_data,
                                                 GClosureMarshal meta_marshal);
void g_closure_invalidate (GClosure *closure);
void g_closure_invoke (GClosure *closure,
                                                 GValue *return_value,
                                                 guint n_param_values,
                                                 const GValue *param_values,
                                                 gpointer invocation_hint);
# 160 "/usr/include/glib-2.0/gobject/gclosure.h" 3 4

# 30 "/usr/include/glib-2.0/gobject/gobject.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gsignal.h" 1 3 4
# 26 "/usr/include/glib-2.0/gobject/gsignal.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gclosure.h" 1 3 4
# 27 "/usr/include/glib-2.0/gobject/gsignal.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1 3 4
# 28 "/usr/include/glib-2.0/gobject/gsignal.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gparam.h" 1 3 4
# 29 "/usr/include/glib-2.0/gobject/gsignal.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gmarshal.h" 1 3 4






extern void g_cclosure_marshal_VOID__VOID (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__BOOLEAN (GClosure *closure,
                                              GValue *return_value,
                                              guint n_param_values,
                                              const GValue *param_values,
                                              gpointer invocation_hint,
                                              gpointer marshal_data);


extern void g_cclosure_marshal_VOID__CHAR (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__UCHAR (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__INT (GClosure *closure,
                                          GValue *return_value,
                                          guint n_param_values,
                                          const GValue *param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data);


extern void g_cclosure_marshal_VOID__UINT (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__LONG (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__ULONG (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__ENUM (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__FLAGS (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__FLOAT (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__DOUBLE (GClosure *closure,
                                             GValue *return_value,
                                             guint n_param_values,
                                             const GValue *param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);


extern void g_cclosure_marshal_VOID__STRING (GClosure *closure,
                                             GValue *return_value,
                                             guint n_param_values,
                                             const GValue *param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);


extern void g_cclosure_marshal_VOID__PARAM (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__BOXED (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__POINTER (GClosure *closure,
                                              GValue *return_value,
                                              guint n_param_values,
                                              const GValue *param_values,
                                              gpointer invocation_hint,
                                              gpointer marshal_data);


extern void g_cclosure_marshal_VOID__OBJECT (GClosure *closure,
                                             GValue *return_value,
                                             guint n_param_values,
                                             const GValue *param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);


extern void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure *closure,
                                                       GValue *return_value,
                                                       guint n_param_values,
                                                       const GValue *param_values,
                                                       gpointer invocation_hint,
                                                       gpointer marshal_data);


extern void g_cclosure_marshal_VOID__UINT_POINTER (GClosure *closure,
                                                   GValue *return_value,
                                                   guint n_param_values,
                                                   const GValue *param_values,
                                                   gpointer invocation_hint,
                                                   gpointer marshal_data);


extern void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure *closure,
                                               GValue *return_value,
                                               guint n_param_values,
                                               const GValue *param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data);



# 30 "/usr/include/glib-2.0/gobject/gsignal.h" 2 3 4




typedef struct _GSignalQuery GSignalQuery;
typedef struct _GSignalInvocationHint GSignalInvocationHint;
typedef GClosureMarshal GSignalCMarshaller;
typedef gboolean (*GSignalEmissionHook) (GSignalInvocationHint *ihint,
                                         guint n_param_values,
                                         const GValue *param_values,
                                         gpointer data);
typedef gboolean (*GSignalAccumulator) (GSignalInvocationHint *ihint,
                                         GValue *return_accu,
                                         const GValue *handler_return,
                                         gpointer data);



typedef enum
{
  G_SIGNAL_RUN_FIRST = 1 << 0,
  G_SIGNAL_RUN_LAST = 1 << 1,
  G_SIGNAL_RUN_CLEANUP = 1 << 2,
  G_SIGNAL_NO_RECURSE = 1 << 3,
  G_SIGNAL_DETAILED = 1 << 4,
  G_SIGNAL_ACTION = 1 << 5,
  G_SIGNAL_NO_HOOKS = 1 << 6
} GSignalFlags;

typedef enum
{
  G_CONNECT_AFTER = 1 << 0,
  G_CONNECT_SWAPPED = 1 << 1
} GConnectFlags;
typedef enum
{
  G_SIGNAL_MATCH_ID = 1 << 0,
  G_SIGNAL_MATCH_DETAIL = 1 << 1,
  G_SIGNAL_MATCH_CLOSURE = 1 << 2,
  G_SIGNAL_MATCH_FUNC = 1 << 3,
  G_SIGNAL_MATCH_DATA = 1 << 4,
  G_SIGNAL_MATCH_UNBLOCKED = 1 << 5
} GSignalMatchType;





struct _GSignalInvocationHint
{
  guint signal_id;
  GQuark detail;
  GSignalFlags run_type;
};
struct _GSignalQuery
{
  guint signal_id;
  const gchar *signal_name;
  GType itype;
  GSignalFlags signal_flags;
  GType return_type;
  guint n_params;
  const GType *param_types;
};



guint g_signal_newv (const gchar *signal_name,
                                             GType itype,
                                             GSignalFlags signal_flags,
                                             GClosure *class_closure,
                                             GSignalAccumulator accumulator,
                                             gpointer accu_data,
                                             GSignalCMarshaller c_marshaller,
                                             GType return_type,
                                             guint n_params,
                                             GType *param_types);
guint g_signal_new_valist (const gchar *signal_name,
                                             GType itype,
                                             GSignalFlags signal_flags,
                                             GClosure *class_closure,
                                             GSignalAccumulator accumulator,
                                             gpointer accu_data,
                                             GSignalCMarshaller c_marshaller,
                                             GType return_type,
                                             guint n_params,
                                             va_list args);
guint g_signal_new (const gchar *signal_name,
                                             GType itype,
                                             GSignalFlags signal_flags,
                                             guint class_offset,
                                             GSignalAccumulator accumulator,
                                             gpointer accu_data,
                                             GSignalCMarshaller c_marshaller,
                                             GType return_type,
                                             guint n_params,
                                             ...);
void g_signal_emitv (const GValue *instance_and_params,
                                             guint signal_id,
                                             GQuark detail,
                                             GValue *return_value);
void g_signal_emit_valist (gpointer instance,
                                             guint signal_id,
                                             GQuark detail,
                                             va_list var_args);
void g_signal_emit (gpointer instance,
                                             guint signal_id,
                                             GQuark detail,
                                             ...);
void g_signal_emit_by_name (gpointer instance,
                                             const gchar *detailed_signal,
                                             ...);
guint g_signal_lookup (const gchar *name,
                                             GType itype);
const gchar* g_signal_name (guint signal_id);
void g_signal_query (guint signal_id,
                                             GSignalQuery *query);
guint* g_signal_list_ids (GType itype,
                                             guint *n_ids);
gboolean g_signal_parse_name (const gchar *detailed_signal,
                                             GType itype,
                                             guint *signal_id_p,
                                             GQuark *detail_p,
                                             gboolean force_detail_quark);
GSignalInvocationHint* g_signal_get_invocation_hint (gpointer instance);



void g_signal_stop_emission (gpointer instance,
                                             guint signal_id,
                                             GQuark detail);
void g_signal_stop_emission_by_name (gpointer instance,
                                             const gchar *detailed_signal);
gulong g_signal_add_emission_hook (guint signal_id,
                                             GQuark detail,
                                             GSignalEmissionHook hook_func,
                                             gpointer hook_data,
                                             GDestroyNotify data_destroy);
void g_signal_remove_emission_hook (guint signal_id,
                                             gulong hook_id);



gboolean g_signal_has_handler_pending (gpointer instance,
                                               guint signal_id,
                                               GQuark detail,
                                               gboolean may_be_blocked);
gulong g_signal_connect_closure_by_id (gpointer instance,
                                               guint signal_id,
                                               GQuark detail,
                                               GClosure *closure,
                                               gboolean after);
gulong g_signal_connect_closure (gpointer instance,
                                               const gchar *detailed_signal,
                                               GClosure *closure,
                                               gboolean after);
gulong g_signal_connect_data (gpointer instance,
                                               const gchar *detailed_signal,
                                               GCallback c_handler,
                                               gpointer data,
                                               GClosureNotify destroy_data,
                                               GConnectFlags connect_flags);
void g_signal_handler_block (gpointer instance,
                                               gulong handler_id);
void g_signal_handler_unblock (gpointer instance,
                                               gulong handler_id);
void g_signal_handler_disconnect (gpointer instance,
                                               gulong handler_id);
gboolean g_signal_handler_is_connected (gpointer instance,
                                               gulong handler_id);
gulong g_signal_handler_find (gpointer instance,
                                               GSignalMatchType mask,
                                               guint signal_id,
                                               GQuark detail,
                                               GClosure *closure,
                                               gpointer func,
                                               gpointer data);
guint g_signal_handlers_block_matched (gpointer instance,
                                               GSignalMatchType mask,
                                               guint signal_id,
                                               GQuark detail,
                                               GClosure *closure,
                                               gpointer func,
                                               gpointer data);
guint g_signal_handlers_unblock_matched (gpointer instance,
                                               GSignalMatchType mask,
                                               guint signal_id,
                                               GQuark detail,
                                               GClosure *closure,
                                               gpointer func,
                                               gpointer data);
guint g_signal_handlers_disconnect_matched (gpointer instance,
                                               GSignalMatchType mask,
                                               guint signal_id,
                                               GQuark detail,
                                               GClosure *closure,
                                               gpointer func,
                                               gpointer data);



void g_signal_override_class_closure (guint signal_id,
                                               GType instance_type,
                                               GClosure *class_closure);
void g_signal_chain_from_overridden (const GValue *instance_and_params,
                                               GValue *return_value);
# 260 "/usr/include/glib-2.0/gobject/gsignal.h" 3 4
void g_signal_handlers_destroy (gpointer instance);
void _g_signals_destroy (GType itype);


# 31 "/usr/include/glib-2.0/gobject/gobject.h" 2 3 4


# 49 "/usr/include/glib-2.0/gobject/gobject.h" 3 4
typedef struct _GObject GObject;
typedef struct _GObjectClass GObjectClass;
typedef struct _GObjectConstructParam GObjectConstructParam;
typedef void (*GObjectGetPropertyFunc) (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec);
typedef void (*GObjectSetPropertyFunc) (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec);
typedef void (*GObjectFinalizeFunc) (GObject *object);
typedef void (*GWeakNotify) (gpointer data,
                                         GObject *where_the_object_was);
struct _GObject
{
  GTypeInstance g_type_instance;


  guint ref_count;
  GData *qdata;
};
struct _GObjectClass
{
  GTypeClass g_type_class;


  GSList *construct_properties;


  GObject* (*constructor) (GType type,
                                 guint n_construct_properties,
                                 GObjectConstructParam *construct_properties);
  void (*set_property) (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec);
  void (*get_property) (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec);
  void (*dispose) (GObject *object);
  void (*finalize) (GObject *object);


  void (*dispatch_properties_changed) (GObject *object,
                                             guint n_pspecs,
                                             GParamSpec **pspecs);


  void (*notify) (GObject *object,
                                         GParamSpec *pspec);

  gpointer pdummy[8];
};
struct _GObjectConstructParam
{
  GParamSpec *pspec;
  GValue *value;
};



void g_object_class_install_property (GObjectClass *oclass,
                                               guint property_id,
                                               GParamSpec *pspec);
GParamSpec* g_object_class_find_property (GObjectClass *oclass,
                                               const gchar *property_name);
GParamSpec**g_object_class_list_properties (GObjectClass *oclass,
                                               guint *n_properties);
gpointer g_object_new (GType object_type,
                                               const gchar *first_property_name,
                                               ...);
gpointer g_object_newv (GType object_type,
                                               guint n_parameters,
                                               GParameter *parameters);
GObject* g_object_new_valist (GType object_type,
                                               const gchar *first_property_name,
                                               va_list var_args);
void g_object_set (gpointer object,
                                               const gchar *first_property_name,
                                               ...);
void g_object_get (gpointer object,
                                               const gchar *first_property_name,
                                               ...);
gpointer g_object_connect (gpointer object,
                                               const gchar *signal_spec,
                                               ...);
void g_object_disconnect (gpointer object,
                                               const gchar *signal_spec,
                                               ...);
void g_object_set_valist (GObject *object,
                                               const gchar *first_property_name,
                                               va_list var_args);
void g_object_get_valist (GObject *object,
                                               const gchar *first_property_name,
                                               va_list var_args);
void g_object_set_property (GObject *object,
                                               const gchar *property_name,
                                               const GValue *value);
void g_object_get_property (GObject *object,
                                               const gchar *property_name,
                                               GValue *value);
void g_object_freeze_notify (GObject *object);
void g_object_notify (GObject *object,
                                               const gchar *property_name);
void g_object_thaw_notify (GObject *object);
gpointer g_object_ref (gpointer object);
void g_object_unref (gpointer object);
void g_object_weak_ref (GObject *object,
                                               GWeakNotify notify,
                                               gpointer data);
void g_object_weak_unref (GObject *object,
                                               GWeakNotify notify,
                                               gpointer data);
void g_object_add_weak_pointer (GObject *object,
                                               gpointer *weak_pointer_location);
void g_object_remove_weak_pointer (GObject *object,
                                               gpointer *weak_pointer_location);
gpointer g_object_get_qdata (GObject *object,
                                               GQuark quark);
void g_object_set_qdata (GObject *object,
                                               GQuark quark,
                                               gpointer data);
void g_object_set_qdata_full (GObject *object,
                                               GQuark quark,
                                               gpointer data,
                                               GDestroyNotify destroy);
gpointer g_object_steal_qdata (GObject *object,
                                               GQuark quark);
gpointer g_object_get_data (GObject *object,
                                               const gchar *key);
void g_object_set_data (GObject *object,
                                               const gchar *key,
                                               gpointer data);
void g_object_set_data_full (GObject *object,
                                               const gchar *key,
                                               gpointer data,
                                               GDestroyNotify destroy);
gpointer g_object_steal_data (GObject *object,
                                               const gchar *key);
void g_object_watch_closure (GObject *object,
                                               GClosure *closure);
GClosure* g_cclosure_new_object (GCallback callback_func,
                                               GObject *object);
GClosure* g_cclosure_new_object_swap (GCallback callback_func,
                                               GObject *object);
GClosure* g_closure_new_object (guint sizeof_closure,
                                               GObject *object);
void g_value_set_object (GValue *value,
                                               gpointer v_object);
gpointer g_value_get_object (const GValue *value);
GObject* g_value_dup_object (const GValue *value);
gulong g_signal_connect_object (gpointer instance,
                                               const gchar *detailed_signal,
                                               GCallback c_handler,
                                               gpointer gobject,
                                               GConnectFlags connect_flags);



void g_object_run_dispose (GObject *object);



void g_value_set_object_take_ownership (GValue *value,
                                               gpointer v_object);
# 235 "/usr/include/glib-2.0/gobject/gobject.h" 3 4

# 28 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gparam.h" 1 3 4
# 29 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gparamspecs.h" 1 3 4
# 28 "/usr/include/glib-2.0/gobject/gparamspecs.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1 3 4
# 29 "/usr/include/glib-2.0/gobject/gparamspecs.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/genums.h" 1 3 4
# 30 "/usr/include/glib-2.0/gobject/gparamspecs.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gboxed.h" 1 3 4
# 31 "/usr/include/glib-2.0/gobject/gparamspecs.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gobject.h" 1 3 4
# 32 "/usr/include/glib-2.0/gobject/gparamspecs.h" 2 3 4


# 99 "/usr/include/glib-2.0/gobject/gparamspecs.h" 3 4
typedef struct _GParamSpecChar GParamSpecChar;
typedef struct _GParamSpecUChar GParamSpecUChar;
typedef struct _GParamSpecBoolean GParamSpecBoolean;
typedef struct _GParamSpecInt GParamSpecInt;
typedef struct _GParamSpecUInt GParamSpecUInt;
typedef struct _GParamSpecLong GParamSpecLong;
typedef struct _GParamSpecULong GParamSpecULong;
typedef struct _GParamSpecInt64 GParamSpecInt64;
typedef struct _GParamSpecUInt64 GParamSpecUInt64;
typedef struct _GParamSpecUnichar GParamSpecUnichar;
typedef struct _GParamSpecEnum GParamSpecEnum;
typedef struct _GParamSpecFlags GParamSpecFlags;
typedef struct _GParamSpecFloat GParamSpecFloat;
typedef struct _GParamSpecDouble GParamSpecDouble;
typedef struct _GParamSpecString GParamSpecString;
typedef struct _GParamSpecParam GParamSpecParam;
typedef struct _GParamSpecBoxed GParamSpecBoxed;
typedef struct _GParamSpecPointer GParamSpecPointer;
typedef struct _GParamSpecValueArray GParamSpecValueArray;
typedef struct _GParamSpecObject GParamSpecObject;

struct _GParamSpecChar
{
  GParamSpec parent_instance;

  gint8 minimum;
  gint8 maximum;
  gint8 default_value;
};
struct _GParamSpecUChar
{
  GParamSpec parent_instance;

  guint8 minimum;
  guint8 maximum;
  guint8 default_value;
};
struct _GParamSpecBoolean
{
  GParamSpec parent_instance;

  gboolean default_value;
};
struct _GParamSpecInt
{
  GParamSpec parent_instance;

  gint minimum;
  gint maximum;
  gint default_value;
};
struct _GParamSpecUInt
{
  GParamSpec parent_instance;

  guint minimum;
  guint maximum;
  guint default_value;
};
struct _GParamSpecLong
{
  GParamSpec parent_instance;

  glong minimum;
  glong maximum;
  glong default_value;
};
struct _GParamSpecULong
{
  GParamSpec parent_instance;

  gulong minimum;
  gulong maximum;
  gulong default_value;
};
struct _GParamSpecInt64
{
  GParamSpec parent_instance;

  gint64 minimum;
  gint64 maximum;
  gint64 default_value;
};
struct _GParamSpecUInt64
{
  GParamSpec parent_instance;

  guint64 minimum;
  guint64 maximum;
  guint64 default_value;
};
struct _GParamSpecUnichar
{
  GParamSpec parent_instance;

  gunichar default_value;
};
struct _GParamSpecEnum
{
  GParamSpec parent_instance;

  GEnumClass *enum_class;
  gint default_value;
};
struct _GParamSpecFlags
{
  GParamSpec parent_instance;

  GFlagsClass *flags_class;
  guint default_value;
};
struct _GParamSpecFloat
{
  GParamSpec parent_instance;

  gfloat minimum;
  gfloat maximum;
  gfloat default_value;
  gfloat epsilon;
};
struct _GParamSpecDouble
{
  GParamSpec parent_instance;

  gdouble minimum;
  gdouble maximum;
  gdouble default_value;
  gdouble epsilon;
};
struct _GParamSpecString
{
  GParamSpec parent_instance;

  gchar *default_value;
  gchar *cset_first;
  gchar *cset_nth;
  gchar substitutor;
  guint null_fold_if_empty : 1;
  guint ensure_non_null : 1;
};
struct _GParamSpecParam
{
  GParamSpec parent_instance;
};
struct _GParamSpecBoxed
{
  GParamSpec parent_instance;
};
struct _GParamSpecPointer
{
  GParamSpec parent_instance;
};
struct _GParamSpecValueArray
{
  GParamSpec parent_instance;
  GParamSpec *element_spec;
  guint fixed_n_elements;
};
struct _GParamSpecObject
{
  GParamSpec parent_instance;
};


GParamSpec* g_param_spec_char (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          gint8 minimum,
                                          gint8 maximum,
                                          gint8 default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_uchar (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          guint8 minimum,
                                          guint8 maximum,
                                          guint8 default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_boolean (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          gboolean default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_int (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          gint minimum,
                                          gint maximum,
                                          gint default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_uint (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          guint minimum,
                                          guint maximum,
                                          guint default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_long (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          glong minimum,
                                          glong maximum,
                                          glong default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_ulong (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          gulong minimum,
                                          gulong maximum,
                                          gulong default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_int64 (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          gint64 minimum,
                                          gint64 maximum,
                                          gint64 default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_uint64 (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          guint64 minimum,
                                          guint64 maximum,
                                          guint64 default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_unichar (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          gunichar default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_enum (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          GType enum_type,
                                          gint default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_flags (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          GType flags_type,
                                          guint default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_float (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          gfloat minimum,
                                          gfloat maximum,
                                          gfloat default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_double (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          gdouble minimum,
                                          gdouble maximum,
                                          gdouble default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_string (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          const gchar *default_value,
                                          GParamFlags flags);
GParamSpec* g_param_spec_param (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          GType param_type,
                                          GParamFlags flags);
GParamSpec* g_param_spec_boxed (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          GType boxed_type,
                                          GParamFlags flags);
GParamSpec* g_param_spec_pointer (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          GParamFlags flags);
GParamSpec* g_param_spec_value_array (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          GParamSpec *element_spec,
                                          GParamFlags flags);
GParamSpec* g_param_spec_object (const gchar *name,
                                          const gchar *nick,
                                          const gchar *blurb,
                                          GType object_type,
                                          GParamFlags flags);
# 410 "/usr/include/glib-2.0/gobject/gparamspecs.h" 3 4
extern GType *g_param_spec_types;


# 30 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gsignal.h" 1 3 4
# 31 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gsourceclosure.h" 1 3 4
# 25 "/usr/include/glib-2.0/gobject/gsourceclosure.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gclosure.h" 1 3 4
# 26 "/usr/include/glib-2.0/gobject/gsourceclosure.h" 2 3 4



void g_source_set_closure (GSource *source,
                           GClosure *closure);

GType g_io_channel_get_type (void);
GType g_io_condition_get_type (void);





# 32 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1 3 4
# 33 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gtypemodule.h" 1 3 4
# 26 "/usr/include/glib-2.0/gobject/gtypemodule.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gobject.h" 1 3 4
# 27 "/usr/include/glib-2.0/gobject/gtypemodule.h" 2 3 4



typedef struct _GTypeModule GTypeModule;
typedef struct _GTypeModuleClass GTypeModuleClass;
# 40 "/usr/include/glib-2.0/gobject/gtypemodule.h" 3 4
struct _GTypeModule
{
  GObject parent_instance;

  guint use_count;
  GSList *type_infos;
  GSList *interface_infos;
  gchar *name;
};

struct _GTypeModuleClass
{
  GObjectClass parent_class;

  gboolean (* load) (GTypeModule *module);
  void (* unload) (GTypeModule *module);


  void (*reserved1) (void);
  void (*reserved2) (void);
  void (*reserved3) (void);
  void (*reserved4) (void);
};

GType g_type_module_get_type (void);
gboolean g_type_module_use (GTypeModule *module);
void g_type_module_unuse (GTypeModule *module);
void g_type_module_set_name (GTypeModule *module,
                                      const gchar *name);
GType g_type_module_register_type (GTypeModule *module,
                                      GType parent_type,
                                      const gchar *type_name,
                                      const GTypeInfo *type_info,
                                      GTypeFlags flags);
void g_type_module_add_interface (GTypeModule *module,
                                      GType instance_type,
                                      GType interface_type,
                                      const GInterfaceInfo *interface_info);


# 34 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gtypeplugin.h" 1 3 4
# 26 "/usr/include/glib-2.0/gobject/gtypeplugin.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1 3 4
# 27 "/usr/include/glib-2.0/gobject/gtypeplugin.h" 2 3 4


# 40 "/usr/include/glib-2.0/gobject/gtypeplugin.h" 3 4
typedef struct _GTypePluginClass GTypePluginClass;
typedef void (*GTypePluginUse) (GTypePlugin *plugin);
typedef void (*GTypePluginUnuse) (GTypePlugin *plugin);
typedef void (*GTypePluginCompleteTypeInfo) (GTypePlugin *plugin,
                                                   GType g_type,
                                                   GTypeInfo *info,
                                                   GTypeValueTable *value_table);
typedef void (*GTypePluginCompleteInterfaceInfo) (GTypePlugin *plugin,
                                                   GType instance_type,
                                                   GType interface_type,
                                                   GInterfaceInfo *info);
struct _GTypePluginClass
{
  GTypeInterface base_iface;

  GTypePluginUse use_plugin;
  GTypePluginUnuse unuse_plugin;
  GTypePluginCompleteTypeInfo complete_type_info;
  GTypePluginCompleteInterfaceInfo complete_interface_info;
};



GType g_type_plugin_get_type (void) ;
void g_type_plugin_use (GTypePlugin *plugin);
void g_type_plugin_unuse (GTypePlugin *plugin);
void g_type_plugin_complete_type_info (GTypePlugin *plugin,
                                                 GType g_type,
                                                 GTypeInfo *info,
                                                 GTypeValueTable *value_table);
void g_type_plugin_complete_interface_info (GTypePlugin *plugin,
                                                 GType instance_type,
                                                 GType interface_type,
                                                 GInterfaceInfo *info);


# 35 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1 3 4
# 36 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gvaluearray.h" 1 3 4
# 28 "/usr/include/glib-2.0/gobject/gvaluearray.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1 3 4
# 29 "/usr/include/glib-2.0/gobject/gvaluearray.h" 2 3 4
# 37 "/usr/include/glib-2.0/gobject/gvaluearray.h" 3 4
typedef struct _GValueArray GValueArray;
struct _GValueArray
{
  guint n_values;
  GValue *values;


  guint n_prealloced;
};



GValue* g_value_array_get_nth (GValueArray *value_array,
                                              guint index_);
GValueArray* g_value_array_new (guint n_prealloced);
void g_value_array_free (GValueArray *value_array);
GValueArray* g_value_array_copy (const GValueArray *value_array);
GValueArray* g_value_array_prepend (GValueArray *value_array,
                                              const GValue *value);
GValueArray* g_value_array_append (GValueArray *value_array,
                                              const GValue *value);
GValueArray* g_value_array_insert (GValueArray *value_array,
                                              guint index_,
                                              const GValue *value);
GValueArray* g_value_array_remove (GValueArray *value_array,
                                              guint index_);
GValueArray* g_value_array_sort (GValueArray *value_array,
                                              GCompareFunc compare_func);
GValueArray* g_value_array_sort_with_data (GValueArray *value_array,
                                              GCompareDataFunc compare_func,
                                              gpointer user_data);
# 37 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 1 "/usr/include/glib-2.0/gobject/gvaluetypes.h" 1 3 4
# 28 "/usr/include/glib-2.0/gobject/gvaluetypes.h" 3 4
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1 3 4
# 29 "/usr/include/glib-2.0/gobject/gvaluetypes.h" 2 3 4


# 49 "/usr/include/glib-2.0/gobject/gvaluetypes.h" 3 4
void g_value_set_char (GValue *value,
                                                 gchar v_char);
gchar g_value_get_char (const GValue *value);
void g_value_set_uchar (GValue *value,
                                                 guchar v_uchar);
guchar g_value_get_uchar (const GValue *value);
void g_value_set_boolean (GValue *value,
                                                 gboolean v_boolean);
gboolean g_value_get_boolean (const GValue *value);
void g_value_set_int (GValue *value,
                                                 gint v_int);
gint g_value_get_int (const GValue *value);
void g_value_set_uint (GValue *value,
                                                 guint v_uint);
guint g_value_get_uint (const GValue *value);
void g_value_set_long (GValue *value,
                                                 glong v_long);
glong g_value_get_long (const GValue *value);
void g_value_set_ulong (GValue *value,
                                                 gulong v_ulong);
gulong g_value_get_ulong (const GValue *value);
void g_value_set_int64 (GValue *value,
                                                 gint64 v_int64);
gint64 g_value_get_int64 (const GValue *value);
void g_value_set_uint64 (GValue *value,
                                                 guint64 v_uint64);
guint64 g_value_get_uint64 (const GValue *value);
void g_value_set_float (GValue *value,
                                                 gfloat v_float);
gfloat g_value_get_float (const GValue *value);
void g_value_set_double (GValue *value,
                                                 gdouble v_double);
gdouble g_value_get_double (const GValue *value);
void g_value_set_string (GValue *value,
                                                 const gchar *v_string);
void g_value_set_static_string (GValue *value,
                                                 const gchar *v_string);
const gchar* g_value_get_string (const GValue *value);
gchar* g_value_dup_string (const GValue *value);
void g_value_set_pointer (GValue *value,
                                                 gpointer v_pointer);
gpointer g_value_get_pointer (const GValue *value);



GType g_pointer_type_register_static (const gchar *name);


gchar* g_strdup_value_contents (const GValue *value);



void g_value_set_string_take_ownership (GValue *value,
                                                 gchar *v_string);



typedef gchar* gchararray;



# 38 "/usr/include/glib-2.0/glib-object.h" 2 3 4
# 27 "/usr/include/pango-1.0/pango/pango-types.h" 2 3 4



typedef struct _PangoLogAttr PangoLogAttr;

typedef struct _PangoEngineLang PangoEngineLang;
typedef struct _PangoEngineShape PangoEngineShape;

typedef struct _PangoFont PangoFont;
typedef struct _PangoRectangle PangoRectangle;


typedef struct _PangoLanguage PangoLanguage;



typedef guint32 PangoGlyph;




struct _PangoRectangle
{
  int x;
  int y;
  int width;
  int height;
};
# 72 "/usr/include/pango-1.0/pango/pango-types.h" 3 4
typedef enum {
  PANGO_DIRECTION_LTR,
  PANGO_DIRECTION_RTL,
  PANGO_DIRECTION_TTB_LTR,
  PANGO_DIRECTION_TTB_RTL
} PangoDirection;



GType pango_language_get_type (void);
PangoLanguage *pango_language_from_string (const char *language);


gboolean pango_language_matches (PangoLanguage *language,
                                       const char *range_list);


# 27 "/usr/include/pango-1.0/pango/pango-font.h" 2 3 4





typedef struct _PangoFontDescription PangoFontDescription;
typedef struct _PangoFontMetrics PangoFontMetrics;
# 43 "/usr/include/pango-1.0/pango/pango-font.h" 3 4
typedef enum {
  PANGO_STYLE_NORMAL,
  PANGO_STYLE_OBLIQUE,
  PANGO_STYLE_ITALIC
} PangoStyle;

typedef enum {
  PANGO_VARIANT_NORMAL,
  PANGO_VARIANT_SMALL_CAPS
} PangoVariant;

typedef enum {
  PANGO_WEIGHT_ULTRALIGHT = 200,
  PANGO_WEIGHT_LIGHT = 300,
  PANGO_WEIGHT_NORMAL = 400,
  PANGO_WEIGHT_BOLD = 700,
  PANGO_WEIGHT_ULTRABOLD = 800,
  PANGO_WEIGHT_HEAVY = 900
} PangoWeight;

typedef enum {
  PANGO_STRETCH_ULTRA_CONDENSED,
  PANGO_STRETCH_EXTRA_CONDENSED,
  PANGO_STRETCH_CONDENSED,
  PANGO_STRETCH_SEMI_CONDENSED,
  PANGO_STRETCH_NORMAL,
  PANGO_STRETCH_SEMI_EXPANDED,
  PANGO_STRETCH_EXPANDED,
  PANGO_STRETCH_EXTRA_EXPANDED,
  PANGO_STRETCH_ULTRA_EXPANDED
} PangoStretch;

typedef enum {
  PANGO_FONT_MASK_FAMILY = 1 << 0,
  PANGO_FONT_MASK_STYLE = 1 << 1,
  PANGO_FONT_MASK_VARIANT = 1 << 2,
  PANGO_FONT_MASK_WEIGHT = 1 << 3,
  PANGO_FONT_MASK_STRETCH = 1 << 4,
  PANGO_FONT_MASK_SIZE = 1 << 5
} PangoFontMask;
# 99 "/usr/include/pango-1.0/pango/pango-font.h" 3 4
GType pango_font_description_get_type (void);
PangoFontDescription *pango_font_description_new (void);
PangoFontDescription *pango_font_description_copy (const PangoFontDescription *desc);
PangoFontDescription *pango_font_description_copy_static (const PangoFontDescription *desc);
guint pango_font_description_hash (const PangoFontDescription *desc);
gboolean pango_font_description_equal (const PangoFontDescription *desc1,
                                                          const PangoFontDescription *desc2);
void pango_font_description_free (PangoFontDescription *desc);
void pango_font_descriptions_free (PangoFontDescription **descs,
                                                          int n_descs);

void pango_font_description_set_family (PangoFontDescription *desc,
                                                               const char *family);
void pango_font_description_set_family_static (PangoFontDescription *desc,
                                                               const char *family);
const char *pango_font_description_get_family (const PangoFontDescription *desc);
void pango_font_description_set_style (PangoFontDescription *desc,
                                                               PangoStyle style);
PangoStyle pango_font_description_get_style (const PangoFontDescription *desc);
void pango_font_description_set_variant (PangoFontDescription *desc,
                                                               PangoVariant variant);
PangoVariant pango_font_description_get_variant (const PangoFontDescription *desc);
void pango_font_description_set_weight (PangoFontDescription *desc,
                                                               PangoWeight weight);
PangoWeight pango_font_description_get_weight (const PangoFontDescription *desc);
void pango_font_description_set_stretch (PangoFontDescription *desc,
                                                               PangoStretch stretch);
PangoStretch pango_font_description_get_stretch (const PangoFontDescription *desc);
void pango_font_description_set_size (PangoFontDescription *desc,
                                                               gint size);
gint pango_font_description_get_size (const PangoFontDescription *desc);

PangoFontMask pango_font_description_get_set_fields (const PangoFontDescription *desc);
void pango_font_description_unset_fields (PangoFontDescription *desc,
                                                     PangoFontMask to_unset);

void pango_font_description_merge (PangoFontDescription *desc,
                                          const PangoFontDescription *desc_to_merge,
                                          gboolean replace_existing);
void pango_font_description_merge_static (PangoFontDescription *desc,
                                          const PangoFontDescription *desc_to_merge,
                                          gboolean replace_existing);

gboolean pango_font_description_better_match (const PangoFontDescription *desc,
                                              const PangoFontDescription *old_match,
                                              const PangoFontDescription *new_match);

PangoFontDescription *pango_font_description_from_string (const char *str);
char * pango_font_description_to_string (const PangoFontDescription *desc);
char * pango_font_description_to_filename (const PangoFontDescription *desc);






GType pango_font_metrics_get_type (void);
PangoFontMetrics *pango_font_metrics_ref (PangoFontMetrics *metrics);
void pango_font_metrics_unref (PangoFontMetrics *metrics);
int pango_font_metrics_get_ascent (PangoFontMetrics *metrics);
int pango_font_metrics_get_descent (PangoFontMetrics *metrics);
int pango_font_metrics_get_approximate_char_width (PangoFontMetrics *metrics);
int pango_font_metrics_get_approximate_digit_width (PangoFontMetrics *metrics);
# 187 "/usr/include/pango-1.0/pango/pango-font.h" 3 4
typedef struct _PangoFontFamily PangoFontFamily;
typedef struct _PangoFontFace PangoFontFace;

GType pango_font_family_get_type (void) ;

void pango_font_family_list_faces (PangoFontFamily *family,
                                                   PangoFontFace ***faces,
                                                   int *n_faces);
const char *pango_font_family_get_name (PangoFontFamily *family);
# 240 "/usr/include/pango-1.0/pango/pango-font.h" 3 4
GType pango_font_face_get_type (void) ;

PangoFontDescription *pango_font_face_describe (PangoFontFace *face);
const char *pango_font_face_get_face_name (PangoFontFace *face);
# 286 "/usr/include/pango-1.0/pango/pango-font.h" 3 4
GType pango_font_get_type (void) ;

PangoFontDescription *pango_font_describe (PangoFont *font);
PangoCoverage * pango_font_get_coverage (PangoFont *font,
                                                    PangoLanguage *language);
PangoEngineShape * pango_font_find_shaper (PangoFont *font,
                                                    PangoLanguage *language,
                                                    guint32 ch);
PangoFontMetrics * pango_font_get_metrics (PangoFont *font,
                                                    PangoLanguage *language);
void pango_font_get_glyph_extents (PangoFont *font,
                                                    PangoGlyph glyph,
                                                    PangoRectangle *ink_rect,
                                                    PangoRectangle *logical_rect);
# 343 "/usr/include/pango-1.0/pango/pango-font.h" 3 4

# 26 "/usr/include/pango-1.0/pango/pango-attributes.h" 2 3 4






typedef struct _PangoColor PangoColor;

struct _PangoColor
{
  guint16 red;
  guint16 green;
  guint16 blue;
};


GType pango_color_get_type (void) ;

PangoColor *pango_color_copy (const PangoColor *src);
void pango_color_free (PangoColor *color);
gboolean pango_color_parse (PangoColor *color,
                                  const char *spec);



typedef struct _PangoAttribute PangoAttribute;
typedef struct _PangoAttrClass PangoAttrClass;

typedef struct _PangoAttrString PangoAttrString;
typedef struct _PangoAttrLanguage PangoAttrLanguage;
typedef struct _PangoAttrInt PangoAttrInt;
typedef struct _PangoAttrFloat PangoAttrFloat;
typedef struct _PangoAttrColor PangoAttrColor;
typedef struct _PangoAttrFontDesc PangoAttrFontDesc;
typedef struct _PangoAttrShape PangoAttrShape;


typedef struct _PangoAttrList PangoAttrList;
typedef struct _PangoAttrIterator PangoAttrIterator;

typedef enum
{
  PANGO_ATTR_INVALID,
  PANGO_ATTR_LANGUAGE,
  PANGO_ATTR_FAMILY,
  PANGO_ATTR_STYLE,
  PANGO_ATTR_WEIGHT,
  PANGO_ATTR_VARIANT,
  PANGO_ATTR_STRETCH,
  PANGO_ATTR_SIZE,
  PANGO_ATTR_FONT_DESC,
  PANGO_ATTR_FOREGROUND,
  PANGO_ATTR_BACKGROUND,
  PANGO_ATTR_UNDERLINE,
  PANGO_ATTR_STRIKETHROUGH,
  PANGO_ATTR_RISE,
  PANGO_ATTR_SHAPE,
  PANGO_ATTR_SCALE
} PangoAttrType;

typedef enum {
  PANGO_UNDERLINE_NONE,
  PANGO_UNDERLINE_SINGLE,
  PANGO_UNDERLINE_DOUBLE,
  PANGO_UNDERLINE_LOW
} PangoUnderline;

struct _PangoAttribute
{
  const PangoAttrClass *klass;
  guint start_index;
  guint end_index;
};

typedef gboolean (*PangoAttrFilterFunc) (PangoAttribute *attribute,
                                         gpointer data);

struct _PangoAttrClass
{

  PangoAttrType type;
  PangoAttribute * (*copy) (const PangoAttribute *attr);
  void (*destroy) (PangoAttribute *attr);
  gboolean (*equal) (const PangoAttribute *attr1, const PangoAttribute *attr2);
};

struct _PangoAttrString
{
  PangoAttribute attr;
  char *value;
};

struct _PangoAttrLanguage
{
  PangoAttribute attr;
  PangoLanguage *value;
};

struct _PangoAttrInt
{
  PangoAttribute attr;
  int value;
};

struct _PangoAttrFloat
{
  PangoAttribute attr;
  double value;
};

struct _PangoAttrColor
{
  PangoAttribute attr;
  PangoColor color;
};

struct _PangoAttrShape
{
  PangoAttribute attr;
  PangoRectangle ink_rect;
  PangoRectangle logical_rect;
};

struct _PangoAttrFontDesc
{
  PangoAttribute attr;
  PangoFontDescription *desc;
};

PangoAttrType pango_attr_type_register (const gchar *name);

PangoAttribute * pango_attribute_copy (const PangoAttribute *attr);
void pango_attribute_destroy (PangoAttribute *attr);
gboolean pango_attribute_equal (const PangoAttribute *attr1,
                                                const PangoAttribute *attr2);

PangoAttribute *pango_attr_language_new (PangoLanguage *language);
PangoAttribute *pango_attr_family_new (const char *family);
PangoAttribute *pango_attr_foreground_new (guint16 red,
                                              guint16 green,
                                              guint16 blue);
PangoAttribute *pango_attr_background_new (guint16 red,
                                              guint16 green,
                                              guint16 blue);
PangoAttribute *pango_attr_size_new (int size);
PangoAttribute *pango_attr_style_new (PangoStyle style);
PangoAttribute *pango_attr_weight_new (PangoWeight weight);
PangoAttribute *pango_attr_variant_new (PangoVariant variant);
PangoAttribute *pango_attr_stretch_new (PangoStretch stretch);
PangoAttribute *pango_attr_font_desc_new (const PangoFontDescription *desc);
PangoAttribute *pango_attr_underline_new (PangoUnderline underline);
PangoAttribute *pango_attr_strikethrough_new (gboolean strikethrough);
PangoAttribute *pango_attr_rise_new (int rise);
PangoAttribute *pango_attr_shape_new (const PangoRectangle *ink_rect,
                                              const PangoRectangle *logical_rect);
PangoAttribute *pango_attr_scale_new (double scale_factor);

GType pango_attr_list_get_type (void) ;
PangoAttrList * pango_attr_list_new (void);
void pango_attr_list_ref (PangoAttrList *list);
void pango_attr_list_unref (PangoAttrList *list);
PangoAttrList * pango_attr_list_copy (PangoAttrList *list);
void pango_attr_list_insert (PangoAttrList *list,
                                                  PangoAttribute *attr);
void pango_attr_list_insert_before (PangoAttrList *list,
                                                  PangoAttribute *attr);
void pango_attr_list_change (PangoAttrList *list,
                                                  PangoAttribute *attr);
void pango_attr_list_splice (PangoAttrList *list,
                                                  PangoAttrList *other,
                                                  gint pos,
                                                  gint len);

PangoAttrList *pango_attr_list_filter (PangoAttrList *list,
                                       PangoAttrFilterFunc func,
                                       gpointer data);

PangoAttrIterator *pango_attr_list_get_iterator (PangoAttrList *list);

void pango_attr_iterator_range (PangoAttrIterator *iterator,
                                                 gint *start,
                                                 gint *end);
gboolean pango_attr_iterator_next (PangoAttrIterator *iterator);
PangoAttrIterator *pango_attr_iterator_copy (PangoAttrIterator *iterator);
void pango_attr_iterator_destroy (PangoAttrIterator *iterator);
PangoAttribute * pango_attr_iterator_get (PangoAttrIterator *iterator,
                                                 PangoAttrType type);
void pango_attr_iterator_get_font (PangoAttrIterator *iterator,
                                                 PangoFontDescription *desc,
                                                 PangoLanguage **language,
                                                 GSList **extra_attrs);
GSList * pango_attr_iterator_get_attrs (PangoAttrIterator *iterator);


gboolean pango_parse_markup (const char *markup_text,
                             int length,
                             gunichar accel_marker,
                             PangoAttrList **attr_list,
                             char **text,
                             gunichar *accel_char,
                             GError **error);


# 26 "/usr/include/pango-1.0/pango/pango.h" 2 3 4
# 1 "/usr/include/pango-1.0/pango/pango-break.h" 1 3 4
# 27 "/usr/include/pango-1.0/pango/pango-break.h" 3 4


# 1 "/usr/include/pango-1.0/pango/pango-item.h" 1 3 4
# 27 "/usr/include/pango-1.0/pango/pango-item.h" 3 4


typedef struct _PangoAnalysis PangoAnalysis;
typedef struct _PangoItem PangoItem;

struct _PangoAnalysis
{
  PangoEngineShape *shape_engine;
  PangoEngineLang *lang_engine;
  PangoFont *font;
  guint8 level;
  PangoLanguage *language;
  GSList *extra_attrs;
};

struct _PangoItem
{
  gint offset;
  gint length;
  gint num_chars;
  PangoAnalysis analysis;
};

PangoItem *pango_item_new (void);
PangoItem *pango_item_copy (PangoItem *item);
void pango_item_free (PangoItem *item);
PangoItem *pango_item_split (PangoItem *orig,
                             int split_index,
                             int split_offset);


# 30 "/usr/include/pango-1.0/pango/pango-break.h" 2 3 4



struct _PangoLogAttr
{
  guint is_line_break : 1;

  guint is_mandatory_break : 1;

  guint is_char_break : 1;

  guint is_white : 1;




  guint is_cursor_position : 1;






  guint is_word_start : 1;
  guint is_word_end : 1;
# 64 "/usr/include/pango-1.0/pango/pango-break.h" 3 4
  guint is_sentence_boundary : 1;
  guint is_sentence_start : 1;
  guint is_sentence_end : 1;
};




void pango_break (const gchar *text,
                  int length,
                  PangoAnalysis *analysis,
                  PangoLogAttr *attrs,
                  int attrs_len);

void pango_find_paragraph_boundary (const gchar *text,
                                    gint length,
                                    gint *paragraph_delimiter_index,
                                    gint *next_paragraph_start);

void pango_get_log_attrs (const char *text,
                          int length,
                          int level,
                          PangoLanguage *language,
                          PangoLogAttr *log_attrs,
                          int attrs_len);
# 105 "/usr/include/pango-1.0/pango/pango-break.h" 3 4

# 27 "/usr/include/pango-1.0/pango/pango.h" 2 3 4
# 1 "/usr/include/pango-1.0/pango/pango-context.h" 1 3 4
# 26 "/usr/include/pango-1.0/pango/pango-context.h" 3 4
# 1 "/usr/include/pango-1.0/pango/pango-fontmap.h" 1 3 4
# 26 "/usr/include/pango-1.0/pango/pango-fontmap.h" 3 4
# 1 "/usr/include/pango-1.0/pango/pango-fontset.h" 1 3 4
# 30 "/usr/include/pango-1.0/pango/pango-fontset.h" 3 4

# 40 "/usr/include/pango-1.0/pango/pango-fontset.h" 3 4
GType pango_fontset_get_type (void) ;

typedef struct _PangoFontset PangoFontset;

PangoFont * pango_fontset_get_font (PangoFontset *fontset,
                                             guint wc);
PangoFontMetrics *pango_fontset_get_metrics (PangoFontset *fontset);
# 102 "/usr/include/pango-1.0/pango/pango-fontset.h" 3 4

# 27 "/usr/include/pango-1.0/pango/pango-fontmap.h" 2 3 4







typedef struct _PangoContext PangoContext;
typedef struct _PangoFontMap PangoFontMap;

GType pango_font_map_get_type (void) ;
PangoFont * pango_font_map_load_font (PangoFontMap *fontmap,
                                            PangoContext *context,
                                            const PangoFontDescription *desc);
PangoFontset *pango_font_map_load_fontset (PangoFontMap *fontmap,
                                            PangoContext *context,
                                            const PangoFontDescription *desc,
                                            PangoLanguage *language);
void pango_font_map_list_families (PangoFontMap *fontmap,
                                            PangoFontFamily ***families,
                                            int *n_families);
# 91 "/usr/include/pango-1.0/pango/pango-fontmap.h" 3 4

# 27 "/usr/include/pango-1.0/pango/pango-context.h" 2 3 4









typedef struct _PangoContextClass PangoContextClass;
# 50 "/usr/include/pango-1.0/pango/pango-context.h" 3 4
GType pango_context_get_type (void) ;







void pango_context_list_families (PangoContext *context,
                                           PangoFontFamily ***families,
                                           int *n_families);
PangoFont * pango_context_load_font (PangoContext *context,
                                           const PangoFontDescription *desc);
PangoFontset *pango_context_load_fontset (PangoContext *context,
                                           const PangoFontDescription *desc,
                                           PangoLanguage *language);

PangoFontMetrics *pango_context_get_metrics (PangoContext *context,
                                               const PangoFontDescription *desc,
                                               PangoLanguage *language);

void pango_context_set_font_description (PangoContext *context,
                                                              const PangoFontDescription *desc);
PangoFontDescription * pango_context_get_font_description (PangoContext *context);
PangoLanguage *pango_context_get_language (PangoContext *context);
void pango_context_set_language (PangoContext *context,
                                                              PangoLanguage *language);
void pango_context_set_base_dir (PangoContext *context,
                                                              PangoDirection direction);
PangoDirection pango_context_get_base_dir (PangoContext *context);





GList *pango_itemize (PangoContext *context,
                      const char *text,
                      int start_index,
                      int length,
                      PangoAttrList *attrs,
                      PangoAttrIterator *cached_iter);



# 28 "/usr/include/pango-1.0/pango/pango.h" 2 3 4

# 1 "/usr/include/pango-1.0/pango/pango-engine.h" 1 3 4
# 28 "/usr/include/pango-1.0/pango/pango-engine.h" 3 4
# 1 "/usr/include/pango-1.0/pango/pango-glyph.h" 1 3 4
# 28 "/usr/include/pango-1.0/pango/pango-glyph.h" 3 4


typedef struct _PangoGlyphGeometry PangoGlyphGeometry;
typedef struct _PangoGlyphVisAttr PangoGlyphVisAttr;
typedef struct _PangoGlyphInfo PangoGlyphInfo;
typedef struct _PangoGlyphString PangoGlyphString;


typedef gint32 PangoGlyphUnit;



struct _PangoGlyphGeometry
{
  PangoGlyphUnit width;
  PangoGlyphUnit x_offset;
  PangoGlyphUnit y_offset;
};



struct _PangoGlyphVisAttr
{
  guint is_cluster_start : 1;
};



struct _PangoGlyphInfo
{
  PangoGlyph glyph;
  PangoGlyphGeometry geometry;
  PangoGlyphVisAttr attr;
};




struct _PangoGlyphString {
  gint num_glyphs;

  PangoGlyphInfo *glyphs;






  gint *log_clusters;


  gint space;
};



PangoGlyphString *pango_glyph_string_new (void);
void pango_glyph_string_set_size (PangoGlyphString *string,
                                               gint new_len);
GType pango_glyph_string_get_type (void);
PangoGlyphString *pango_glyph_string_copy (PangoGlyphString *string);
void pango_glyph_string_free (PangoGlyphString *string);
void pango_glyph_string_extents (PangoGlyphString *glyphs,
                                               PangoFont *font,
                                               PangoRectangle *ink_rect,
                                               PangoRectangle *logical_rect);

void pango_glyph_string_extents_range (PangoGlyphString *glyphs,
                                                     int start,
                                                     int end,
                                                     PangoFont *font,
                                                     PangoRectangle *ink_rect,
                                                     PangoRectangle *logical_rect);

void pango_glyph_string_get_logical_widths (PangoGlyphString *glyphs,
                                            const char *text,
                                            int length,
                                            int embedding_level,
                                            int *logical_widths);

void pango_glyph_string_index_to_x (PangoGlyphString *glyphs,
                                    char *text,
                                    int length,
                                    PangoAnalysis *analysis,
                                    int index_,
                                    gboolean trailing,
                                    int *x_pos);
void pango_glyph_string_x_to_index (PangoGlyphString *glyphs,
                                    char *text,
                                    int length,
                                    PangoAnalysis *analysis,
                                    int x_pos,
                                    int *index_,
                                    int *trailing);



void pango_shape (const gchar *text,
                  gint length,
                  PangoAnalysis *analysis,
                  PangoGlyphString *glyphs);

GList *pango_reorder_items (GList *logical_items);


# 29 "/usr/include/pango-1.0/pango/pango-engine.h" 2 3 4


# 100 "/usr/include/pango-1.0/pango/pango-engine.h" 3 4

# 30 "/usr/include/pango-1.0/pango/pango.h" 2 3 4
# 1 "/usr/include/pango-1.0/pango/pango-enum-types.h" 1 3 4
# 9 "/usr/include/pango-1.0/pango/pango-enum-types.h" 3 4




GType pango_attr_type_get_type (void);


GType pango_underline_get_type (void);




GType pango_coverage_level_get_type (void);




GType pango_style_get_type (void);


GType pango_variant_get_type (void);


GType pango_weight_get_type (void);


GType pango_stretch_get_type (void);


GType pango_font_mask_get_type (void);




GType pango_alignment_get_type (void);


GType pango_wrap_mode_get_type (void);




GType pango_tab_align_get_type (void);




GType pango_direction_get_type (void);



# 31 "/usr/include/pango-1.0/pango/pango.h" 2 3 4




# 1 "/usr/include/pango-1.0/pango/pango-layout.h" 1 3 4
# 27 "/usr/include/pango-1.0/pango/pango-layout.h" 3 4
# 1 "/usr/include/pango-1.0/pango/pango-glyph-item.h" 1 3 4
# 30 "/usr/include/pango-1.0/pango/pango-glyph-item.h" 3 4


typedef struct _PangoGlyphItem PangoGlyphItem;

struct _PangoGlyphItem
{
  PangoItem *item;
  PangoGlyphString *glyphs;
};

PangoGlyphItem *pango_glyph_item_split (PangoGlyphItem *orig,
                                              const char *text,
                                              int split_index);
GSList * pango_glyph_item_apply_attrs (PangoGlyphItem *glyph_item,
                                              const char *text,
                                              PangoAttrList *list);


# 28 "/usr/include/pango-1.0/pango/pango-layout.h" 2 3 4
# 1 "/usr/include/pango-1.0/pango/pango-tabs.h" 1 3 4
# 27 "/usr/include/pango-1.0/pango/pango-tabs.h" 3 4


typedef struct _PangoTabArray PangoTabArray;

typedef enum
{
  PANGO_TAB_LEFT
# 42 "/usr/include/pango-1.0/pango/pango-tabs.h" 3 4
} PangoTabAlign;



PangoTabArray *pango_tab_array_new (gint initial_size,
                                                     gboolean positions_in_pixels);
PangoTabArray *pango_tab_array_new_with_positions (gint size,
                                                     gboolean positions_in_pixels,
                                                     PangoTabAlign first_alignment,
                                                     gint first_position,
                                                     ...);
GType pango_tab_array_get_type (void);
PangoTabArray *pango_tab_array_copy (PangoTabArray *src);
void pango_tab_array_free (PangoTabArray *tab_array);
gint pango_tab_array_get_size (PangoTabArray *tab_array);
void pango_tab_array_resize (PangoTabArray *tab_array,
                                                     gint new_size);
void pango_tab_array_set_tab (PangoTabArray *tab_array,
                                                     gint tab_index,
                                                     PangoTabAlign alignment,
                                                     gint location);
void pango_tab_array_get_tab (PangoTabArray *tab_array,
                                                     gint tab_index,
                                                     PangoTabAlign *alignment,
                                                     gint *location);
void pango_tab_array_get_tabs (PangoTabArray *tab_array,
                                                     PangoTabAlign **alignments,
                                                     gint **locations);

gboolean pango_tab_array_get_positions_in_pixels (PangoTabArray *tab_array);



# 29 "/usr/include/pango-1.0/pango/pango-layout.h" 2 3 4



typedef struct _PangoLayout PangoLayout;
typedef struct _PangoLayoutClass PangoLayoutClass;
typedef struct _PangoLayoutLine PangoLayoutLine;


typedef PangoGlyphItem PangoLayoutRun;

typedef enum {
  PANGO_ALIGN_LEFT,
  PANGO_ALIGN_CENTER,
  PANGO_ALIGN_RIGHT
} PangoAlignment;

typedef enum {
  PANGO_WRAP_WORD,
  PANGO_WRAP_CHAR,
  PANGO_WRAP_WORD_CHAR
} PangoWrapMode;

struct _PangoLayoutLine
{
  PangoLayout *layout;
  gint start_index;
  gint length;
  GSList *runs;
};
# 71 "/usr/include/pango-1.0/pango/pango-layout.h" 3 4
GType pango_layout_get_type (void) ;
PangoLayout *pango_layout_new (PangoContext *context);
PangoLayout *pango_layout_copy (PangoLayout *src);

PangoContext *pango_layout_get_context (PangoLayout *layout);

void pango_layout_set_attributes (PangoLayout *layout,
                                            PangoAttrList *attrs);
PangoAttrList *pango_layout_get_attributes (PangoLayout *layout);

void pango_layout_set_text (PangoLayout *layout,
                                            const char *text,
                                            int length);
const char *pango_layout_get_text (PangoLayout *layout);

void pango_layout_set_markup (PangoLayout *layout,
                                            const char *markup,
                                            int length);

void pango_layout_set_markup_with_accel (PangoLayout *layout,
                                                   const char *markup,
                                                   int length,
                                                   gunichar accel_marker,
                                                   gunichar *accel_char);

void pango_layout_set_font_description (PangoLayout *layout,
                                                  const PangoFontDescription *desc);
void pango_layout_set_width (PangoLayout *layout,
                                                  int width);
int pango_layout_get_width (PangoLayout *layout);
void pango_layout_set_wrap (PangoLayout *layout,
                                                  PangoWrapMode wrap);
PangoWrapMode pango_layout_get_wrap (PangoLayout *layout);
void pango_layout_set_indent (PangoLayout *layout,
                                                  int indent);
int pango_layout_get_indent (PangoLayout *layout);
void pango_layout_set_spacing (PangoLayout *layout,
                                                  int spacing);
int pango_layout_get_spacing (PangoLayout *layout);
void pango_layout_set_justify (PangoLayout *layout,
                                                  gboolean justify);
gboolean pango_layout_get_justify (PangoLayout *layout);
void pango_layout_set_alignment (PangoLayout *layout,
                                                  PangoAlignment alignment);
PangoAlignment pango_layout_get_alignment (PangoLayout *layout);

void pango_layout_set_tabs (PangoLayout *layout,
                                                  PangoTabArray *tabs);

PangoTabArray* pango_layout_get_tabs (PangoLayout *layout);

void pango_layout_set_single_paragraph_mode (PangoLayout *layout,
                                                       gboolean setting);
gboolean pango_layout_get_single_paragraph_mode (PangoLayout *layout);

void pango_layout_context_changed (PangoLayout *layout);

void pango_layout_get_log_attrs (PangoLayout *layout,
                                     PangoLogAttr **attrs,
                                     gint *n_attrs);

void pango_layout_index_to_pos (PangoLayout *layout,
                                            int index_,
                                            PangoRectangle *pos);
void pango_layout_get_cursor_pos (PangoLayout *layout,
                                            int index_,
                                            PangoRectangle *strong_pos,
                                            PangoRectangle *weak_pos);
void pango_layout_move_cursor_visually (PangoLayout *layout,
                                            gboolean strong,
                                            int old_index,
                                            int old_trailing,
                                            int direction,
                                            int *new_index,
                                            int *new_trailing);
gboolean pango_layout_xy_to_index (PangoLayout *layout,
                                            int x,
                                            int y,
                                            int *index_,
                                            int *trailing);
void pango_layout_get_extents (PangoLayout *layout,
                                            PangoRectangle *ink_rect,
                                            PangoRectangle *logical_rect);
void pango_layout_get_pixel_extents (PangoLayout *layout,
                                            PangoRectangle *ink_rect,
                                            PangoRectangle *logical_rect);
void pango_layout_get_size (PangoLayout *layout,
                                            int *width,
                                            int *height);
void pango_layout_get_pixel_size (PangoLayout *layout,
                                            int *width,
                                            int *height);

int pango_layout_get_line_count (PangoLayout *layout);
PangoLayoutLine *pango_layout_get_line (PangoLayout *layout,
                                                    int line);
GSList * pango_layout_get_lines (PangoLayout *layout);

void pango_layout_line_ref (PangoLayoutLine *line);
void pango_layout_line_unref (PangoLayoutLine *line);
gboolean pango_layout_line_x_to_index (PangoLayoutLine *line,
                                         int x_pos,
                                         int *index_,
                                         int *trailing);
void pango_layout_line_index_to_x (PangoLayoutLine *line,
                                         int index_,
                                         gboolean trailing,
                                         int *x_pos);
void pango_layout_line_get_x_ranges (PangoLayoutLine *line,
                                         int start_index,
                                         int end_index,
                                         int **ranges,
                                         int *n_ranges);
void pango_layout_line_get_extents (PangoLayoutLine *line,
                                         PangoRectangle *ink_rect,
                                         PangoRectangle *logical_rect);
void pango_layout_line_get_pixel_extents (PangoLayoutLine *layout_line,
                                              PangoRectangle *ink_rect,
                                              PangoRectangle *logical_rect);

typedef struct _PangoLayoutIter PangoLayoutIter;

PangoLayoutIter *pango_layout_get_iter (PangoLayout *layout);
void pango_layout_iter_free (PangoLayoutIter *iter);

int pango_layout_iter_get_index (PangoLayoutIter *iter);
PangoLayoutRun *pango_layout_iter_get_run (PangoLayoutIter *iter);
PangoLayoutLine *pango_layout_iter_get_line (PangoLayoutIter *iter);
gboolean pango_layout_iter_at_last_line (PangoLayoutIter *iter);

gboolean pango_layout_iter_next_char (PangoLayoutIter *iter);
gboolean pango_layout_iter_next_cluster (PangoLayoutIter *iter);
gboolean pango_layout_iter_next_run (PangoLayoutIter *iter);
gboolean pango_layout_iter_next_line (PangoLayoutIter *iter);

void pango_layout_iter_get_char_extents (PangoLayoutIter *iter,
                                            PangoRectangle *logical_rect);
void pango_layout_iter_get_cluster_extents (PangoLayoutIter *iter,
                                            PangoRectangle *ink_rect,
                                            PangoRectangle *logical_rect);
void pango_layout_iter_get_run_extents (PangoLayoutIter *iter,
                                            PangoRectangle *ink_rect,
                                            PangoRectangle *logical_rect);
void pango_layout_iter_get_line_extents (PangoLayoutIter *iter,
                                            PangoRectangle *ink_rect,
                                            PangoRectangle *logical_rect);



void pango_layout_iter_get_line_yrange (PangoLayoutIter *iter,
                                            int *y0_,
                                            int *y1_);
void pango_layout_iter_get_layout_extents (PangoLayoutIter *iter,
                                            PangoRectangle *ink_rect,
                                            PangoRectangle *logical_rect);
int pango_layout_iter_get_baseline (PangoLayoutIter *iter);


# 36 "/usr/include/pango-1.0/pango/pango.h" 2 3 4
# 34 "/usr/include/gtk-2.0/gdk/gdktypes.h" 2 3 4
# 51 "/usr/include/gtk-2.0/gdk/gdktypes.h" 3 4
# 1 "/usr/lib/gtk-2.0/include/gdkconfig.h" 1 3 4
# 52 "/usr/include/gtk-2.0/gdk/gdktypes.h" 2 3 4
# 66 "/usr/include/gtk-2.0/gdk/gdktypes.h" 3 4
typedef struct _GdkPoint GdkPoint;
typedef struct _GdkRectangle GdkRectangle;
typedef struct _GdkSegment GdkSegment;
typedef struct _GdkSpan GdkSpan;






typedef guint32 GdkWChar;

typedef struct _GdkAtom *GdkAtom;
# 89 "/usr/include/gtk-2.0/gdk/gdktypes.h" 3 4
typedef guint32 GdkNativeWindow;




typedef struct _GdkColor GdkColor;
typedef struct _GdkColormap GdkColormap;
typedef struct _GdkCursor GdkCursor;
typedef struct _GdkFont GdkFont;
typedef struct _GdkGC GdkGC;
typedef struct _GdkImage GdkImage;
typedef struct _GdkRegion GdkRegion;
typedef struct _GdkVisual GdkVisual;

typedef struct _GdkDrawable GdkDrawable;
typedef struct _GdkDrawable GdkBitmap;
typedef struct _GdkDrawable GdkPixmap;
typedef struct _GdkDrawable GdkWindow;
typedef struct _GdkDisplay GdkDisplay;
typedef struct _GdkScreen GdkScreen;

typedef enum
{
  GDK_LSB_FIRST,
  GDK_MSB_FIRST
} GdkByteOrder;



typedef enum
{
  GDK_SHIFT_MASK = 1 << 0,
  GDK_LOCK_MASK = 1 << 1,
  GDK_CONTROL_MASK = 1 << 2,
  GDK_MOD1_MASK = 1 << 3,
  GDK_MOD2_MASK = 1 << 4,
  GDK_MOD3_MASK = 1 << 5,
  GDK_MOD4_MASK = 1 << 6,
  GDK_MOD5_MASK = 1 << 7,
  GDK_BUTTON1_MASK = 1 << 8,
  GDK_BUTTON2_MASK = 1 << 9,
  GDK_BUTTON3_MASK = 1 << 10,
  GDK_BUTTON4_MASK = 1 << 11,
  GDK_BUTTON5_MASK = 1 << 12,


  GDK_RELEASE_MASK = 1 << 30,
  GDK_MODIFIER_MASK = GDK_RELEASE_MASK | 0x1fff
} GdkModifierType;

typedef enum
{
  GDK_INPUT_READ = 1 << 0,
  GDK_INPUT_WRITE = 1 << 1,
  GDK_INPUT_EXCEPTION = 1 << 2
} GdkInputCondition;

typedef enum
{
  GDK_OK = 0,
  GDK_ERROR = -1,
  GDK_ERROR_PARAM = -2,
  GDK_ERROR_FILE = -3,
  GDK_ERROR_MEM = -4
} GdkStatus;





typedef enum
{
  GDK_GRAB_SUCCESS = 0,
  GDK_GRAB_ALREADY_GRABBED = 1,
  GDK_GRAB_INVALID_TIME = 2,
  GDK_GRAB_NOT_VIEWABLE = 3,
  GDK_GRAB_FROZEN = 4
} GdkGrabStatus;

typedef void (*GdkInputFunction) (gpointer data,
                                  gint source,
                                  GdkInputCondition condition);

typedef void (*GdkDestroyNotify) (gpointer data);

struct _GdkPoint
{
  gint x;
  gint y;
};

struct _GdkRectangle
{
  gint x;
  gint y;
  gint width;
  gint height;
};

struct _GdkSegment
{
  gint x1;
  gint y1;
  gint x2;
  gint y2;
};

struct _GdkSpan
{
  gint x;
  gint y;
  gint width;
};
# 5 "/usr/include/gtk-2.0/gdk/gdkcolor.h" 2 3 4
# 17 "/usr/include/gtk-2.0/gdk/gdkcolor.h" 3 4
struct _GdkColor
{
  guint32 pixel;
  guint16 red;
  guint16 green;
  guint16 blue;
};




typedef struct _GdkColormapClass GdkColormapClass;
# 39 "/usr/include/gtk-2.0/gdk/gdkcolor.h" 3 4
struct _GdkColormap
{
  GObject parent_instance;


  gint size;
  GdkColor *colors;


  GdkVisual *visual;

  gpointer windowing_data;
};

struct _GdkColormapClass
{
  GObjectClass parent_class;

};

GType gdk_colormap_get_type (void) ;

GdkColormap* gdk_colormap_new (GdkVisual *visual,
                                   gboolean allocate);


GdkColormap* gdk_colormap_ref (GdkColormap *cmap);
void gdk_colormap_unref (GdkColormap *cmap);



GdkColormap* gdk_colormap_get_system (void);


GdkScreen *gdk_colormap_get_screen (GdkColormap *cmap);


gint gdk_colormap_get_system_size (void);




void gdk_colormap_change (GdkColormap *colormap,
                          gint ncolors);


gint gdk_colormap_alloc_colors (GdkColormap *colormap,
                                   GdkColor *colors,
                                   gint ncolors,
                                   gboolean writeable,
                                   gboolean best_match,
                                   gboolean *success);
gboolean gdk_colormap_alloc_color (GdkColormap *colormap,
                                   GdkColor *color,
                                   gboolean writeable,
                                   gboolean best_match);
void gdk_colormap_free_colors (GdkColormap *colormap,
                                   GdkColor *colors,
                                   gint ncolors);
void gdk_colormap_query_color (GdkColormap *colormap,
                                   gulong pixel,
                                   GdkColor *result);

GdkVisual *gdk_colormap_get_visual (GdkColormap *colormap);

GdkColor *gdk_color_copy (const GdkColor *color);
void gdk_color_free (GdkColor *color);
gint gdk_color_parse (const gchar *spec,
                           GdkColor *color);
guint gdk_color_hash (const GdkColor *colora);
gboolean gdk_color_equal (const GdkColor *colora,
                           const GdkColor *colorb);

GType gdk_color_get_type (void);



void gdk_colors_store (GdkColormap *colormap,
                          GdkColor *colors,
                          gint ncolors);
gint gdk_color_white (GdkColormap *colormap,
                          GdkColor *color);
gint gdk_color_black (GdkColormap *colormap,
                          GdkColor *color);
gint gdk_color_alloc (GdkColormap *colormap,
                          GdkColor *color);
gint gdk_color_change (GdkColormap *colormap,
                          GdkColor *color);




gint gdk_colors_alloc (GdkColormap *colormap,
                          gboolean contiguous,
                          gulong *planes,
                          gint nplanes,
                          gulong *pixels,
                          gint npixels);
void gdk_colors_free (GdkColormap *colormap,
                          gulong *pixels,
                          gint npixels,
                          gulong planes);
# 31 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkcursor.h" 1 3 4
# 14 "/usr/include/gtk-2.0/gdk/gdkcursor.h" 3 4
typedef enum
{
  GDK_X_CURSOR = 0,
  GDK_ARROW = 2,
  GDK_BASED_ARROW_DOWN = 4,
  GDK_BASED_ARROW_UP = 6,
  GDK_BOAT = 8,
  GDK_BOGOSITY = 10,
  GDK_BOTTOM_LEFT_CORNER = 12,
  GDK_BOTTOM_RIGHT_CORNER = 14,
  GDK_BOTTOM_SIDE = 16,
  GDK_BOTTOM_TEE = 18,
  GDK_BOX_SPIRAL = 20,
  GDK_CENTER_PTR = 22,
  GDK_CIRCLE = 24,
  GDK_CLOCK = 26,
  GDK_COFFEE_MUG = 28,
  GDK_CROSS = 30,
  GDK_CROSS_REVERSE = 32,
  GDK_CROSSHAIR = 34,
  GDK_DIAMOND_CROSS = 36,
  GDK_DOT = 38,
  GDK_DOTBOX = 40,
  GDK_DOUBLE_ARROW = 42,
  GDK_DRAFT_LARGE = 44,
  GDK_DRAFT_SMALL = 46,
  GDK_DRAPED_BOX = 48,
  GDK_EXCHANGE = 50,
  GDK_FLEUR = 52,
  GDK_GOBBLER = 54,
  GDK_GUMBY = 56,
  GDK_HAND1 = 58,
  GDK_HAND2 = 60,
  GDK_HEART = 62,
  GDK_ICON = 64,
  GDK_IRON_CROSS = 66,
  GDK_LEFT_PTR = 68,
  GDK_LEFT_SIDE = 70,
  GDK_LEFT_TEE = 72,
  GDK_LEFTBUTTON = 74,
  GDK_LL_ANGLE = 76,
  GDK_LR_ANGLE = 78,
  GDK_MAN = 80,
  GDK_MIDDLEBUTTON = 82,
  GDK_MOUSE = 84,
  GDK_PENCIL = 86,
  GDK_PIRATE = 88,
  GDK_PLUS = 90,
  GDK_QUESTION_ARROW = 92,
  GDK_RIGHT_PTR = 94,
  GDK_RIGHT_SIDE = 96,
  GDK_RIGHT_TEE = 98,
  GDK_RIGHTBUTTON = 100,
  GDK_RTL_LOGO = 102,
  GDK_SAILBOAT = 104,
  GDK_SB_DOWN_ARROW = 106,
  GDK_SB_H_DOUBLE_ARROW = 108,
  GDK_SB_LEFT_ARROW = 110,
  GDK_SB_RIGHT_ARROW = 112,
  GDK_SB_UP_ARROW = 114,
  GDK_SB_V_DOUBLE_ARROW = 116,
  GDK_SHUTTLE = 118,
  GDK_SIZING = 120,
  GDK_SPIDER = 122,
  GDK_SPRAYCAN = 124,
  GDK_STAR = 126,
  GDK_TARGET = 128,
  GDK_TCROSS = 130,
  GDK_TOP_LEFT_ARROW = 132,
  GDK_TOP_LEFT_CORNER = 134,
  GDK_TOP_RIGHT_CORNER = 136,
  GDK_TOP_SIDE = 138,
  GDK_TOP_TEE = 140,
  GDK_TREK = 142,
  GDK_UL_ANGLE = 144,
  GDK_UMBRELLA = 146,
  GDK_UR_ANGLE = 148,
  GDK_WATCH = 150,
  GDK_XTERM = 152,
  GDK_LAST_CURSOR,
  GDK_CURSOR_IS_PIXMAP = -1
} GdkCursorType;

struct _GdkCursor
{
  GdkCursorType type;
  guint ref_count;
};




GType gdk_cursor_get_type (void);

GdkCursor* gdk_cursor_new_for_display (GdkDisplay *display,
                                          GdkCursorType cursor_type);

GdkCursor* gdk_cursor_new (GdkCursorType cursor_type);

GdkCursor* gdk_cursor_new_from_pixmap (GdkPixmap *source,
                                          GdkPixmap *mask,
                                          GdkColor *fg,
                                          GdkColor *bg,
                                          gint x,
                                          gint y);
GdkDisplay* gdk_cursor_get_display (GdkCursor *cursor);
GdkCursor* gdk_cursor_ref (GdkCursor *cursor);
void gdk_cursor_unref (GdkCursor *cursor);
# 32 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkdisplay.h" 1 3 4
# 28 "/usr/include/gtk-2.0/gdk/gdkdisplay.h" 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkevents.h" 1 3 4





# 1 "/usr/include/gtk-2.0/gdk/gdkdnd.h" 1 3 4
# 10 "/usr/include/gtk-2.0/gdk/gdkdnd.h" 3 4
typedef struct _GdkDragContext GdkDragContext;

typedef enum
{
  GDK_ACTION_DEFAULT = 1 << 0,
  GDK_ACTION_COPY = 1 << 1,
  GDK_ACTION_MOVE = 1 << 2,
  GDK_ACTION_LINK = 1 << 3,
  GDK_ACTION_PRIVATE = 1 << 4,
  GDK_ACTION_ASK = 1 << 5
} GdkDragAction;

typedef enum
{
  GDK_DRAG_PROTO_MOTIF,
  GDK_DRAG_PROTO_XDND,
  GDK_DRAG_PROTO_ROOTWIN,

  GDK_DRAG_PROTO_NONE,
  GDK_DRAG_PROTO_WIN32_DROPFILES,
  GDK_DRAG_PROTO_OLE2,
  GDK_DRAG_PROTO_LOCAL
} GdkDragProtocol;





typedef struct _GdkDragContextClass GdkDragContextClass;
# 47 "/usr/include/gtk-2.0/gdk/gdkdnd.h" 3 4
struct _GdkDragContext {
  GObject parent_instance;



  GdkDragProtocol protocol;

  gboolean is_source;

  GdkWindow *source_window;
  GdkWindow *dest_window;

  GList *targets;
  GdkDragAction actions;
  GdkDragAction suggested_action;
  GdkDragAction action;

  guint32 start_time;



  gpointer windowing_data;
};

struct _GdkDragContextClass {
  GObjectClass parent_class;


};



GType gdk_drag_context_get_type (void) ;
GdkDragContext * gdk_drag_context_new (void);


void gdk_drag_context_ref (GdkDragContext *context);
void gdk_drag_context_unref (GdkDragContext *context);




void gdk_drag_status (GdkDragContext *context,
                                         GdkDragAction action,
                                         guint32 time_);
void gdk_drop_reply (GdkDragContext *context,
                                         gboolean ok,
                                         guint32 time_);
void gdk_drop_finish (GdkDragContext *context,
                                         gboolean success,
                                         guint32 time_);
GdkAtom gdk_drag_get_selection (GdkDragContext *context);



GdkDragContext * gdk_drag_begin (GdkWindow *window,
                                      GList *targets);

guint32 gdk_drag_get_protocol_for_display (GdkDisplay *display,
                                           guint32 xid,
                                           GdkDragProtocol *protocol);
void gdk_drag_find_window_for_screen (GdkDragContext *context,
                                           GdkWindow *drag_window,
                                           GdkScreen *screen,
                                           gint x_root,
                                           gint y_root,
                                           GdkWindow **dest_window,
                                           GdkDragProtocol *protocol);


guint32 gdk_drag_get_protocol (guint32 xid,
                               GdkDragProtocol *protocol);
void gdk_drag_find_window (GdkDragContext *context,
                               GdkWindow *drag_window,
                               gint x_root,
                               gint y_root,
                               GdkWindow **dest_window,
                               GdkDragProtocol *protocol);


gboolean gdk_drag_motion (GdkDragContext *context,
                                      GdkWindow *dest_window,
                                      GdkDragProtocol protocol,
                                      gint x_root,
                                      gint y_root,
                                      GdkDragAction suggested_action,
                                      GdkDragAction possible_actions,
                                      guint32 time_);
void gdk_drag_drop (GdkDragContext *context,
                                      guint32 time_);
void gdk_drag_abort (GdkDragContext *context,
                                      guint32 time_);
# 7 "/usr/include/gtk-2.0/gdk/gdkevents.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkinput.h" 1 3 4
# 17 "/usr/include/gtk-2.0/gdk/gdkinput.h" 3 4
typedef struct _GdkDeviceKey GdkDeviceKey;
typedef struct _GdkDeviceAxis GdkDeviceAxis;
typedef struct _GdkDevice GdkDevice;
typedef struct _GdkDeviceClass GdkDeviceClass;
typedef struct _GdkTimeCoord GdkTimeCoord;

typedef enum
{
  GDK_EXTENSION_EVENTS_NONE,
  GDK_EXTENSION_EVENTS_ALL,
  GDK_EXTENSION_EVENTS_CURSOR
} GdkExtensionMode;

typedef enum
{
  GDK_SOURCE_MOUSE,
  GDK_SOURCE_PEN,
  GDK_SOURCE_ERASER,
  GDK_SOURCE_CURSOR
} GdkInputSource;

typedef enum
{
  GDK_MODE_DISABLED,
  GDK_MODE_SCREEN,
  GDK_MODE_WINDOW
} GdkInputMode;

typedef enum
{
  GDK_AXIS_IGNORE,
  GDK_AXIS_X,
  GDK_AXIS_Y,
  GDK_AXIS_PRESSURE,
  GDK_AXIS_XTILT,
  GDK_AXIS_YTILT,
  GDK_AXIS_WHEEL,
  GDK_AXIS_LAST
} GdkAxisUse;

struct _GdkDeviceKey
{
  guint keyval;
  GdkModifierType modifiers;
};

struct _GdkDeviceAxis
{
  GdkAxisUse use;
  gdouble min;
  gdouble max;
};

struct _GdkDevice
{
  GObject parent_instance;


  gchar *name;
  GdkInputSource source;
  GdkInputMode mode;
  gboolean has_cursor;

  gint num_axes;
  GdkDeviceAxis *axes;

  gint num_keys;
  GdkDeviceKey *keys;
};






struct _GdkTimeCoord
{
  guint32 time;
  gdouble axes[128];
};

GType gdk_device_get_type (void);



GList * gdk_devices_list (void);



void gdk_device_set_source (GdkDevice *device,
                                         GdkInputSource source);

gboolean gdk_device_set_mode (GdkDevice *device,
                                         GdkInputMode mode);

void gdk_device_set_key (GdkDevice *device,
                                         guint index_,
                                         guint keyval,
                                         GdkModifierType modifiers);

void gdk_device_set_axis_use (GdkDevice *device,
                                  guint index_,
                                  GdkAxisUse use);
void gdk_device_get_state (GdkDevice *device,
                                  GdkWindow *window,
                                  gdouble *axes,
                                  GdkModifierType *mask);
gboolean gdk_device_get_history (GdkDevice *device,
                                  GdkWindow *window,
                                  guint32 start,
                                  guint32 stop,
                                  GdkTimeCoord ***events,
                                  gint *n_events);
void gdk_device_free_history (GdkTimeCoord **events,
                                  gint n_events);
gboolean gdk_device_get_axis (GdkDevice *device,
                                  gdouble *axes,
                                  GdkAxisUse use,
                                  gdouble *value);

void gdk_input_set_extension_events (GdkWindow *window,
                                     gint mask,
                                     GdkExtensionMode mode);


GdkDevice *gdk_device_get_core_pointer (void);
# 8 "/usr/include/gtk-2.0/gdk/gdkevents.h" 2 3 4
# 19 "/usr/include/gtk-2.0/gdk/gdkevents.h" 3 4
typedef struct _GdkEventAny GdkEventAny;
typedef struct _GdkEventExpose GdkEventExpose;
typedef struct _GdkEventNoExpose GdkEventNoExpose;
typedef struct _GdkEventVisibility GdkEventVisibility;
typedef struct _GdkEventMotion GdkEventMotion;
typedef struct _GdkEventButton GdkEventButton;
typedef struct _GdkEventScroll GdkEventScroll;
typedef struct _GdkEventKey GdkEventKey;
typedef struct _GdkEventFocus GdkEventFocus;
typedef struct _GdkEventCrossing GdkEventCrossing;
typedef struct _GdkEventConfigure GdkEventConfigure;
typedef struct _GdkEventProperty GdkEventProperty;
typedef struct _GdkEventSelection GdkEventSelection;
typedef struct _GdkEventProximity GdkEventProximity;
typedef struct _GdkEventClient GdkEventClient;
typedef struct _GdkEventDND GdkEventDND;
typedef struct _GdkEventWindowState GdkEventWindowState;
typedef struct _GdkEventSetting GdkEventSetting;

typedef union _GdkEvent GdkEvent;

typedef void (*GdkEventFunc) (GdkEvent *event,
                              gpointer data);



typedef void GdkXEvent;



typedef enum {
  GDK_FILTER_CONTINUE,
  GDK_FILTER_TRANSLATE,


  GDK_FILTER_REMOVE
} GdkFilterReturn;

typedef GdkFilterReturn (*GdkFilterFunc) (GdkXEvent *xevent,
                                          GdkEvent *event,
                                          gpointer data);
# 85 "/usr/include/gtk-2.0/gdk/gdkevents.h" 3 4
typedef enum
{
  GDK_NOTHING = -1,
  GDK_DELETE = 0,
  GDK_DESTROY = 1,
  GDK_EXPOSE = 2,
  GDK_MOTION_NOTIFY = 3,
  GDK_BUTTON_PRESS = 4,
  GDK_2BUTTON_PRESS = 5,
  GDK_3BUTTON_PRESS = 6,
  GDK_BUTTON_RELEASE = 7,
  GDK_KEY_PRESS = 8,
  GDK_KEY_RELEASE = 9,
  GDK_ENTER_NOTIFY = 10,
  GDK_LEAVE_NOTIFY = 11,
  GDK_FOCUS_CHANGE = 12,
  GDK_CONFIGURE = 13,
  GDK_MAP = 14,
  GDK_UNMAP = 15,
  GDK_PROPERTY_NOTIFY = 16,
  GDK_SELECTION_CLEAR = 17,
  GDK_SELECTION_REQUEST = 18,
  GDK_SELECTION_NOTIFY = 19,
  GDK_PROXIMITY_IN = 20,
  GDK_PROXIMITY_OUT = 21,
  GDK_DRAG_ENTER = 22,
  GDK_DRAG_LEAVE = 23,
  GDK_DRAG_MOTION = 24,
  GDK_DRAG_STATUS = 25,
  GDK_DROP_START = 26,
  GDK_DROP_FINISHED = 27,
  GDK_CLIENT_EVENT = 28,
  GDK_VISIBILITY_NOTIFY = 29,
  GDK_NO_EXPOSE = 30,
  GDK_SCROLL = 31,
  GDK_WINDOW_STATE = 32,
  GDK_SETTING = 33
} GdkEventType;




typedef enum
{
  GDK_EXPOSURE_MASK = 1 << 1,
  GDK_POINTER_MOTION_MASK = 1 << 2,
  GDK_POINTER_MOTION_HINT_MASK = 1 << 3,
  GDK_BUTTON_MOTION_MASK = 1 << 4,
  GDK_BUTTON1_MOTION_MASK = 1 << 5,
  GDK_BUTTON2_MOTION_MASK = 1 << 6,
  GDK_BUTTON3_MOTION_MASK = 1 << 7,
  GDK_BUTTON_PRESS_MASK = 1 << 8,
  GDK_BUTTON_RELEASE_MASK = 1 << 9,
  GDK_KEY_PRESS_MASK = 1 << 10,
  GDK_KEY_RELEASE_MASK = 1 << 11,
  GDK_ENTER_NOTIFY_MASK = 1 << 12,
  GDK_LEAVE_NOTIFY_MASK = 1 << 13,
  GDK_FOCUS_CHANGE_MASK = 1 << 14,
  GDK_STRUCTURE_MASK = 1 << 15,
  GDK_PROPERTY_CHANGE_MASK = 1 << 16,
  GDK_VISIBILITY_NOTIFY_MASK = 1 << 17,
  GDK_PROXIMITY_IN_MASK = 1 << 18,
  GDK_PROXIMITY_OUT_MASK = 1 << 19,
  GDK_SUBSTRUCTURE_MASK = 1 << 20,
  GDK_SCROLL_MASK = 1 << 21,
  GDK_ALL_EVENTS_MASK = 0x3FFFFE
} GdkEventMask;

typedef enum
{
  GDK_VISIBILITY_UNOBSCURED,
  GDK_VISIBILITY_PARTIAL,
  GDK_VISIBILITY_FULLY_OBSCURED
} GdkVisibilityState;

typedef enum
{
  GDK_SCROLL_UP,
  GDK_SCROLL_DOWN,
  GDK_SCROLL_LEFT,
  GDK_SCROLL_RIGHT
} GdkScrollDirection;
# 176 "/usr/include/gtk-2.0/gdk/gdkevents.h" 3 4
typedef enum
{
  GDK_NOTIFY_ANCESTOR = 0,
  GDK_NOTIFY_VIRTUAL = 1,
  GDK_NOTIFY_INFERIOR = 2,
  GDK_NOTIFY_NONLINEAR = 3,
  GDK_NOTIFY_NONLINEAR_VIRTUAL = 4,
  GDK_NOTIFY_UNKNOWN = 5
} GdkNotifyType;






typedef enum
{
  GDK_CROSSING_NORMAL,
  GDK_CROSSING_GRAB,
  GDK_CROSSING_UNGRAB
} GdkCrossingMode;

typedef enum
{
  GDK_PROPERTY_NEW_VALUE,
  GDK_PROPERTY_DELETE
} GdkPropertyState;

typedef enum
{
  GDK_WINDOW_STATE_WITHDRAWN = 1 << 0,
  GDK_WINDOW_STATE_ICONIFIED = 1 << 1,
  GDK_WINDOW_STATE_MAXIMIZED = 1 << 2,
  GDK_WINDOW_STATE_STICKY = 1 << 3,
  GDK_WINDOW_STATE_FULLSCREEN = 1 << 4
} GdkWindowState;

typedef enum
{
  GDK_SETTING_ACTION_NEW,
  GDK_SETTING_ACTION_CHANGED,
  GDK_SETTING_ACTION_DELETED
} GdkSettingAction;

struct _GdkEventAny
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
};

struct _GdkEventExpose
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkRectangle area;
  GdkRegion *region;
  gint count;
};

struct _GdkEventNoExpose
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
};

struct _GdkEventVisibility
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkVisibilityState state;
};

struct _GdkEventMotion
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  gdouble x;
  gdouble y;
  gdouble *axes;
  guint state;
  gint16 is_hint;
  GdkDevice *device;
  gdouble x_root, y_root;
};

struct _GdkEventButton
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  gdouble x;
  gdouble y;
  gdouble *axes;
  guint state;
  guint button;
  GdkDevice *device;
  gdouble x_root, y_root;
};

struct _GdkEventScroll
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  gdouble x;
  gdouble y;
  guint state;
  GdkScrollDirection direction;
  GdkDevice *device;
  gdouble x_root, y_root;
};

struct _GdkEventKey
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  guint state;
  guint keyval;
  gint length;
  gchar *string;
  guint16 hardware_keycode;
  guint8 group;
};

struct _GdkEventCrossing
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkWindow *subwindow;
  guint32 time;
  gdouble x;
  gdouble y;
  gdouble x_root;
  gdouble y_root;
  GdkCrossingMode mode;
  GdkNotifyType detail;
  gboolean focus;
  guint state;
};

struct _GdkEventFocus
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  gint16 in;
};

struct _GdkEventConfigure
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  gint x, y;
  gint width;
  gint height;
};

struct _GdkEventProperty
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkAtom atom;
  guint32 time;
  guint state;
};

struct _GdkEventSelection
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkAtom selection;
  GdkAtom target;
  GdkAtom property;
  guint32 time;
  GdkNativeWindow requestor;
};




struct _GdkEventProximity
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time;
  GdkDevice *device;
};

struct _GdkEventClient
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkAtom message_type;
  gushort data_format;
  union {
    char b[20];
    short s[10];
    long l[5];
  } data;
};

struct _GdkEventSetting
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkSettingAction action;
  char *name;
};

struct _GdkEventWindowState
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkWindowState changed_mask;
  GdkWindowState new_window_state;
};



struct _GdkEventDND {
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkDragContext *context;

  guint32 time;
  gshort x_root, y_root;
};

union _GdkEvent
{
  GdkEventType type;
  GdkEventAny any;
  GdkEventExpose expose;
  GdkEventNoExpose no_expose;
  GdkEventVisibility visibility;
  GdkEventMotion motion;
  GdkEventButton button;
  GdkEventScroll scroll;
  GdkEventKey key;
  GdkEventCrossing crossing;
  GdkEventFocus focus_change;
  GdkEventConfigure configure;
  GdkEventProperty property;
  GdkEventSelection selection;
  GdkEventProximity proximity;
  GdkEventClient client;
  GdkEventDND dnd;
  GdkEventWindowState window_state;
  GdkEventSetting setting;
};

GType gdk_event_get_type (void);

gboolean gdk_events_pending (void);
GdkEvent* gdk_event_get (void);

GdkEvent* gdk_event_peek (void);
GdkEvent* gdk_event_get_graphics_expose (GdkWindow *window);
void gdk_event_put (GdkEvent *event);

GdkEvent* gdk_event_new (GdkEventType type);
GdkEvent* gdk_event_copy (GdkEvent *event);
void gdk_event_free (GdkEvent *event);

guint32 gdk_event_get_time (GdkEvent *event);
gboolean gdk_event_get_state (GdkEvent *event,
                                         GdkModifierType *state);
gboolean gdk_event_get_coords (GdkEvent *event,
                                         gdouble *x_win,
                                         gdouble *y_win);
gboolean gdk_event_get_root_coords (GdkEvent *event,
                                         gdouble *x_root,
                                         gdouble *y_root);
gboolean gdk_event_get_axis (GdkEvent *event,
                                         GdkAxisUse axis_use,
                                         gdouble *value);
void gdk_event_handler_set (GdkEventFunc func,
                                         gpointer data,
                                         GDestroyNotify notify);

void gdk_event_set_screen (GdkEvent *event,
                                 GdkScreen *screen);
GdkScreen *gdk_event_get_screen (GdkEvent *event);

void gdk_set_show_events (gboolean show_events);
gboolean gdk_get_show_events (void);


void gdk_add_client_message_filter (GdkAtom message_type,
                                    GdkFilterFunc func,
                                    gpointer data);

gboolean gdk_setting_get (const gchar *name,
                          GValue *value);
# 29 "/usr/include/gtk-2.0/gdk/gdkdisplay.h" 2 3 4




typedef struct _GdkDisplayClass GdkDisplayClass;
typedef struct _GdkDisplayPointerHooks GdkDisplayPointerHooks;
# 44 "/usr/include/gtk-2.0/gdk/gdkdisplay.h" 3 4
struct _GdkDisplay
{
  GObject parent_instance;


  GList *queued_events;
  GList *queued_tail;




  guint32 button_click_time[2];
  GdkWindow *button_window[2];
  gint button_number[2];

  guint double_click_time;
  GdkDevice *core_pointer;

  const GdkDisplayPointerHooks *pointer_hooks;

  guint closed : 1;
};

struct _GdkDisplayClass
{
  GObjectClass parent_class;

  const gchar * (*get_display_name) (GdkDisplay *display);
  gint (*get_n_screens) (GdkDisplay *display);
  GdkScreen * (*get_screen) (GdkDisplay *display,
                                                    gint screen_num);
  GdkScreen * (*get_default_screen) (GdkDisplay *display);



  void (*closed) (GdkDisplay *display,
                  gboolean is_error);
};

struct _GdkDisplayPointerHooks
{
  void (*get_pointer) (GdkDisplay *display,
                                    GdkScreen **screen,
                                    gint *x,
                                    gint *y,
                                    GdkModifierType *mask);
  GdkWindow* (*window_get_pointer) (GdkDisplay *display,
                                    GdkWindow *window,
                                    gint *x,
                                    gint *y,
                                    GdkModifierType *mask);
  GdkWindow* (*window_at_pointer) (GdkDisplay *display,
                                    gint *win_x,
                                    gint *win_y);
};

GType gdk_display_get_type (void);
GdkDisplay *gdk_display_open (const gchar *display_name);

const gchar * gdk_display_get_name (GdkDisplay *display);

gint gdk_display_get_n_screens (GdkDisplay *display);
GdkScreen * gdk_display_get_screen (GdkDisplay *display,
                                            gint screen_num);
GdkScreen * gdk_display_get_default_screen (GdkDisplay *display);
void gdk_display_pointer_ungrab (GdkDisplay *display,
                                            guint32 time_);
void gdk_display_keyboard_ungrab (GdkDisplay *display,
                                            guint32 time_);
gboolean gdk_display_pointer_is_grabbed (GdkDisplay *display);
void gdk_display_beep (GdkDisplay *display);
void gdk_display_sync (GdkDisplay *display);
void gdk_display_close (GdkDisplay *display);

GList * gdk_display_list_devices (GdkDisplay *display);

GdkEvent* gdk_display_get_event (GdkDisplay *display);
GdkEvent* gdk_display_peek_event (GdkDisplay *display);
void gdk_display_put_event (GdkDisplay *display,
                                  GdkEvent *event);

void gdk_display_add_client_message_filter (GdkDisplay *display,
                                            GdkAtom message_type,
                                            GdkFilterFunc func,
                                            gpointer data);

void gdk_display_set_double_click_time (GdkDisplay *display,
                                        guint msec);

GdkDisplay *gdk_display_get_default (void);

GdkDevice *gdk_display_get_core_pointer (GdkDisplay *display);

void gdk_display_get_pointer (GdkDisplay *display,
                                                    GdkScreen **screen,
                                                    gint *x,
                                                    gint *y,
                                                    GdkModifierType *mask);
GdkWindow * gdk_display_get_window_at_pointer (GdkDisplay *display,
                                                    gint *win_x,
                                                    gint *win_y);

GdkDisplayPointerHooks *gdk_display_set_pointer_hooks (GdkDisplay *display,
                                                       const GdkDisplayPointerHooks *new_hooks);

GdkDisplay *gdk_display_open_default_libgtk_only (void);


# 33 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gdk/gdkdrawable.h" 1 3 4




# 1 "/usr/include/gtk-2.0/gdk/gdkgc.h" 1 3 4
# 11 "/usr/include/gtk-2.0/gdk/gdkgc.h" 3 4
typedef struct _GdkGCValues GdkGCValues;
typedef struct _GdkGCClass GdkGCClass;







typedef enum
{
  GDK_CAP_NOT_LAST,
  GDK_CAP_BUTT,
  GDK_CAP_ROUND,
  GDK_CAP_PROJECTING
} GdkCapStyle;







typedef enum
{
  GDK_SOLID,
  GDK_TILED,
  GDK_STIPPLED,
  GDK_OPAQUE_STIPPLED
} GdkFill;
# 60 "/usr/include/gtk-2.0/gdk/gdkgc.h" 3 4
typedef enum
{
  GDK_COPY,
  GDK_INVERT,
  GDK_XOR,
  GDK_CLEAR,
  GDK_AND,
  GDK_AND_REVERSE,
  GDK_AND_INVERT,
  GDK_NOOP,
  GDK_OR,
  GDK_EQUIV,
  GDK_OR_REVERSE,
  GDK_COPY_INVERT,
  GDK_OR_INVERT,
  GDK_NAND,
  GDK_NOR,
  GDK_SET
} GdkFunction;






typedef enum
{
  GDK_JOIN_MITER,
  GDK_JOIN_ROUND,
  GDK_JOIN_BEVEL
} GdkJoinStyle;






typedef enum
{
  GDK_LINE_SOLID,
  GDK_LINE_ON_OFF_DASH,
  GDK_LINE_DOUBLE_DASH
} GdkLineStyle;

typedef enum
{
  GDK_CLIP_BY_CHILDREN = 0,
  GDK_INCLUDE_INFERIORS = 1
} GdkSubwindowMode;

typedef enum
{
  GDK_GC_FOREGROUND = 1 << 0,
  GDK_GC_BACKGROUND = 1 << 1,
  GDK_GC_FONT = 1 << 2,
  GDK_GC_FUNCTION = 1 << 3,
  GDK_GC_FILL = 1 << 4,
  GDK_GC_TILE = 1 << 5,
  GDK_GC_STIPPLE = 1 << 6,
  GDK_GC_CLIP_MASK = 1 << 7,
  GDK_GC_SUBWINDOW = 1 << 8,
  GDK_GC_TS_X_ORIGIN = 1 << 9,
  GDK_GC_TS_Y_ORIGIN = 1 << 10,
  GDK_GC_CLIP_X_ORIGIN = 1 << 11,
  GDK_GC_CLIP_Y_ORIGIN = 1 << 12,
  GDK_GC_EXPOSURES = 1 << 13,
  GDK_GC_LINE_WIDTH = 1 << 14,
  GDK_GC_LINE_STYLE = 1 << 15,
  GDK_GC_CAP_STYLE = 1 << 16,
  GDK_GC_JOIN_STYLE = 1 << 17
} GdkGCValuesMask;

struct _GdkGCValues
{
  GdkColor foreground;
  GdkColor background;
  GdkFont *font;
  GdkFunction function;
  GdkFill fill;
  GdkPixmap *tile;
  GdkPixmap *stipple;
  GdkPixmap *clip_mask;
  GdkSubwindowMode subwindow_mode;
  gint ts_x_origin;
  gint ts_y_origin;
  gint clip_x_origin;
  gint clip_y_origin;
  gint graphics_exposures;
  gint line_width;
  GdkLineStyle line_style;
  GdkCapStyle cap_style;
  GdkJoinStyle join_style;
};
# 161 "/usr/include/gtk-2.0/gdk/gdkgc.h" 3 4
struct _GdkGC
{
  GObject parent_instance;

  gint clip_x_origin;
  gint clip_y_origin;
  gint ts_x_origin;
  gint ts_y_origin;

  GdkColormap *colormap;
};

struct _GdkGCClass
{
  GObjectClass parent_class;

  void (*get_values) (GdkGC *gc,
                          GdkGCValues *values);
  void (*set_values) (GdkGC *gc,
                          GdkGCValues *values,
                          GdkGCValuesMask mask);
  void (*set_dashes) (GdkGC *gc,
                          gint dash_offset,
                          gint8 dash_list[],
                          gint n);


  void (*_gdk_reserved1) (void);
  void (*_gdk_reserved2) (void);
  void (*_gdk_reserved3) (void);
  void (*_gdk_reserved4) (void);
};


GType gdk_gc_get_type (void) ;
GdkGC *gdk_gc_new (GdkDrawable *drawable);
GdkGC *gdk_gc_new_with_values (GdkDrawable *drawable,
                                   GdkGCValues *values,
                                   GdkGCValuesMask values_mask);


GdkGC *gdk_gc_ref (GdkGC *gc);
void gdk_gc_unref (GdkGC *gc);


void gdk_gc_get_values (GdkGC *gc,
                                   GdkGCValues *values);
void gdk_gc_set_values (GdkGC *gc,
                                   GdkGCValues *values,
                                   GdkGCValuesMask values_mask);
void gdk_gc_set_foreground (GdkGC *gc,
                                   GdkColor *color);
void gdk_gc_set_background (GdkGC *gc,
                                   GdkColor *color);

void gdk_gc_set_font (GdkGC *gc,
                                   GdkFont *font);

void gdk_gc_set_function (GdkGC *gc,
                                   GdkFunction function);
void gdk_gc_set_fill (GdkGC *gc,
                                   GdkFill fill);
void gdk_gc_set_tile (GdkGC *gc,
                                   GdkPixmap *tile);
void gdk_gc_set_stipple (GdkGC *gc,
                                   GdkPixmap *stipple);
void gdk_gc_set_ts_origin (GdkGC *gc,
                                   gint x,
                                   gint y);
void gdk_gc_set_clip_origin (GdkGC *gc,
                                   gint x,
                                   gint y);
void gdk_gc_set_clip_mask (GdkGC *gc,
                                   GdkBitmap *mask);
void gdk_gc_set_clip_rectangle (GdkGC *gc,
                                   GdkRectangle *rectangle);
void gdk_gc_set_clip_region (GdkGC *gc,
                                   GdkRegion *region);
void gdk_gc_set_subwindow (GdkGC *gc,
                                   GdkSubwindowMode mode);
void gdk_gc_set_exposures (GdkGC *gc,
                                   gboolean exposures);
void gdk_gc_set_line_attributes (GdkGC *gc,
                                   gint line_width,
                                   GdkLineStyle line_style,
                                   GdkCapStyle cap_style,
                                   GdkJoinStyle join_style);
void gdk_gc_set_dashes (GdkGC *gc,
                                   gint dash_offset,
                                   gint8 dash_list[],
                                   gint n);
void gdk_gc_offset (GdkGC *gc,
                                   gint x_offset,
                                   gint y_offset);
void gdk_gc_copy (GdkGC *dst_gc,
                                   GdkGC *src_gc);


void gdk_gc_set_colormap (GdkGC *gc,
                                      GdkColormap *colormap);
GdkColormap *gdk_gc_get_colormap (GdkGC *gc);
void gdk_gc_set_rgb_fg_color (GdkGC *gc,
                                      GdkColor *color);
void gdk_gc_set_rgb_bg_color (GdkGC *gc,
                                      GdkColor *color);
GdkScreen * gdk_gc_get_screen (GdkGC *gc);
# 6 "/usr/include/gtk-2.0/gdk/gdkdrawable.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkrgb.h" 1 3 4
# 36 "/usr/include/gtk-2.0/gdk/gdkrgb.h" 3 4
typedef struct _GdkRgbCmap GdkRgbCmap;

struct _GdkRgbCmap {
  guint32 colors[256];
  gint n_colors;


  GSList *info_list;
};


void gdk_rgb_init (void);

gulong gdk_rgb_xpixel_from_rgb (guint32 rgb) ;
void gdk_rgb_gc_set_foreground (GdkGC *gc,
                                  guint32 rgb);
void gdk_rgb_gc_set_background (GdkGC *gc,
                                  guint32 rgb);



void gdk_rgb_find_color (GdkColormap *colormap,
                                  GdkColor *color);

typedef enum
{
  GDK_RGB_DITHER_NONE,
  GDK_RGB_DITHER_NORMAL,
  GDK_RGB_DITHER_MAX
} GdkRgbDither;

void gdk_draw_rgb_image (GdkDrawable *drawable,
                                             GdkGC *gc,
                                             gint x,
                                             gint y,
                                             gint width,
                                             gint height,
                                             GdkRgbDither dith,
                                             guchar *rgb_buf,
                                             gint rowstride);
void gdk_draw_rgb_image_dithalign (GdkDrawable *drawable,
                                             GdkGC *gc,
                                             gint x,
                                             gint y,
                                             gint width,
                                             gint height,
                                             GdkRgbDither dith,
                                             guchar *rgb_buf,
                                             gint rowstride,
                                             gint xdith,
                                             gint ydith);
void gdk_draw_rgb_32_image (GdkDrawable *drawable,
                                             GdkGC *gc,
                                             gint x,
                                             gint y,
                                             gint width,
                                             gint height,
                                             GdkRgbDither dith,
                                             guchar *buf,
                                             gint rowstride);
void gdk_draw_rgb_32_image_dithalign (GdkDrawable *drawable,
                                             GdkGC *gc,
                                             gint x,
                                             gint y,
                                             gint width,
                                             gint height,
                                             GdkRgbDither dith,
                                             guchar *buf,
                                             gint rowstride,
                                             gint xdith,
                                             gint ydith);
void gdk_draw_gray_image (GdkDrawable *drawable,
                                             GdkGC *gc,
                                             gint x,
                                             gint y,
                                             gint width,
                                             gint height,
                                             GdkRgbDither dith,
                                             guchar *buf,
                                             gint rowstride);
void gdk_draw_indexed_image (GdkDrawable *drawable,
                                             GdkGC *gc,
                                             gint x,
                                             gint y,
                                             gint width,
                                             gint height,
                                             GdkRgbDither dith,
                                             guchar *buf,
                                             gint rowstride,
                                             GdkRgbCmap *cmap);
GdkRgbCmap *gdk_rgb_cmap_new (guint32 *colors,
                                             gint n_colors);
void gdk_rgb_cmap_free (GdkRgbCmap *cmap);

void gdk_rgb_set_verbose (gboolean verbose);


void gdk_rgb_set_install (gboolean install);
void gdk_rgb_set_min_colors (gint min_colors);


GdkColormap *gdk_rgb_get_colormap (void);
GdkVisual * gdk_rgb_get_visual (void);
gboolean gdk_rgb_ditherable (void);
# 7 "/usr/include/gtk-2.0/gdk/gdkdrawable.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h" 1 3 4
# 30 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h" 3 4
# 1 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h" 1 3 4
# 9 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h" 3 4
extern const guint gdk_pixbuf_major_version, gdk_pixbuf_minor_version, gdk_pixbuf_micro_version;
extern const char *gdk_pixbuf_version;
# 31 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h" 2 3 4







typedef enum
{
        GDK_PIXBUF_ALPHA_BILEVEL,
        GDK_PIXBUF_ALPHA_FULL
} GdkPixbufAlphaMode;





typedef enum {
        GDK_COLORSPACE_RGB
} GdkColorspace;


typedef struct _GdkPixbuf GdkPixbuf;
typedef struct _GdkPixbufAnimation GdkPixbufAnimation;
typedef struct _GdkPixbufAnimationIter GdkPixbufAnimationIter;
# 70 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h" 3 4
typedef void (* GdkPixbufDestroyNotify) (guchar *pixels, gpointer data);



typedef enum {

        GDK_PIXBUF_ERROR_CORRUPT_IMAGE,

        GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,

        GDK_PIXBUF_ERROR_BAD_OPTION,

        GDK_PIXBUF_ERROR_UNKNOWN_TYPE,

        GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION,
        GDK_PIXBUF_ERROR_FAILED
} GdkPixbufError;

GQuark gdk_pixbuf_error_quark (void) ;



GType gdk_pixbuf_get_type (void) ;




GdkPixbuf *gdk_pixbuf_ref (GdkPixbuf *pixbuf);
void gdk_pixbuf_unref (GdkPixbuf *pixbuf);




GdkColorspace gdk_pixbuf_get_colorspace (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_n_channels (const GdkPixbuf *pixbuf);
gboolean gdk_pixbuf_get_has_alpha (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_bits_per_sample (const GdkPixbuf *pixbuf);
guchar *gdk_pixbuf_get_pixels (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_width (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_height (const GdkPixbuf *pixbuf);
int gdk_pixbuf_get_rowstride (const GdkPixbuf *pixbuf);




GdkPixbuf *gdk_pixbuf_new (GdkColorspace colorspace, gboolean has_alpha, int bits_per_sample,
                           int width, int height);



GdkPixbuf *gdk_pixbuf_copy (const GdkPixbuf *pixbuf);


GdkPixbuf *gdk_pixbuf_new_subpixbuf (GdkPixbuf *src_pixbuf,
                                     int src_x,
                                     int src_y,
                                     int width,
                                     int height);



GdkPixbuf *gdk_pixbuf_new_from_file (const char *filename,
                                     GError **error);

GdkPixbuf *gdk_pixbuf_new_from_data (const guchar *data,
                                     GdkColorspace colorspace,
                                     gboolean has_alpha,
                                     int bits_per_sample,
                                     int width, int height,
                                     int rowstride,
                                     GdkPixbufDestroyNotify destroy_fn,
                                     gpointer destroy_fn_data);

GdkPixbuf *gdk_pixbuf_new_from_xpm_data (const char **data);
GdkPixbuf* gdk_pixbuf_new_from_inline (gint data_length,
                                         const guint8 *data,
                                         gboolean copy_pixels,
                                         GError **error);


void gdk_pixbuf_fill (GdkPixbuf *pixbuf,
                                         guint32 pixel);



gboolean gdk_pixbuf_save (GdkPixbuf *pixbuf,
                                    const char *filename,
                                    const char *type,
                                    GError **error,
                                    ...);

gboolean gdk_pixbuf_savev (GdkPixbuf *pixbuf,
                                    const char *filename,
                                    const char *type,
                                    char **option_keys,
                                    char **option_values,
                                    GError **error);


GdkPixbuf *gdk_pixbuf_add_alpha (const GdkPixbuf *pixbuf, gboolean substitute_color,
                                 guchar r, guchar g, guchar b);


void gdk_pixbuf_copy_area (const GdkPixbuf *src_pixbuf,
                           int src_x, int src_y,
                           int width, int height,
                           GdkPixbuf *dest_pixbuf,
                           int dest_x, int dest_y);


void gdk_pixbuf_saturate_and_pixelate (const GdkPixbuf *src,
                                       GdkPixbuf *dest,
                                       gfloat saturation,
                                       gboolean pixelate);
# 193 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h" 3 4
typedef enum {
        GDK_INTERP_NEAREST,
        GDK_INTERP_TILES,
        GDK_INTERP_BILINEAR,
        GDK_INTERP_HYPER
} GdkInterpType;

void gdk_pixbuf_scale (const GdkPixbuf *src,
                                 GdkPixbuf *dest,
                                 int dest_x,
                                 int dest_y,
                                 int dest_width,
                                 int dest_height,
                                 double offset_x,
                                 double offset_y,
                                 double scale_x,
                                 double scale_y,
                                 GdkInterpType interp_type);
void gdk_pixbuf_composite (const GdkPixbuf *src,
                                 GdkPixbuf *dest,
                                 int dest_x,
                                 int dest_y,
                                 int dest_width,
                                 int dest_height,
                                 double offset_x,
                                 double offset_y,
                                 double scale_x,
                                 double scale_y,
                                 GdkInterpType interp_type,
                                 int overall_alpha);
void gdk_pixbuf_composite_color (const GdkPixbuf *src,
                                 GdkPixbuf *dest,
                                 int dest_x,
                                 int dest_y,
                                 int dest_width,
                                 int dest_height,
                                 double offset_x,
                                 double offset_y,
                                 double scale_x,
                                 double scale_y,
                                 GdkInterpType interp_type,
                                 int overall_alpha,
                                 int check_x,
                                 int check_y,
                                 int check_size,
                                 guint32 color1,
                                 guint32 color2);

GdkPixbuf *gdk_pixbuf_scale_simple (const GdkPixbuf *src,
                                              int dest_width,
                                              int dest_height,
                                              GdkInterpType interp_type);

GdkPixbuf *gdk_pixbuf_composite_color_simple (const GdkPixbuf *src,
                                              int dest_width,
                                              int dest_height,
                                              GdkInterpType interp_type,
                                              int overall_alpha,
                                              int check_size,
                                              guint32 color1,
                                              guint32 color2);





GType gdk_pixbuf_animation_get_type (void) ;

GdkPixbufAnimation *gdk_pixbuf_animation_new_from_file (const char *filename,
                                                          GError **error);


GdkPixbufAnimation *gdk_pixbuf_animation_ref (GdkPixbufAnimation *animation);
void gdk_pixbuf_animation_unref (GdkPixbufAnimation *animation);


int gdk_pixbuf_animation_get_width (GdkPixbufAnimation *animation);
int gdk_pixbuf_animation_get_height (GdkPixbufAnimation *animation);
gboolean gdk_pixbuf_animation_is_static_image (GdkPixbufAnimation *animation);
GdkPixbuf *gdk_pixbuf_animation_get_static_image (GdkPixbufAnimation *animation);

GdkPixbufAnimationIter *gdk_pixbuf_animation_get_iter (GdkPixbufAnimation *animation,
                                                                              const GTimeVal *start_time);
GType gdk_pixbuf_animation_iter_get_type (void) ;
int gdk_pixbuf_animation_iter_get_delay_time (GdkPixbufAnimationIter *iter);
GdkPixbuf *gdk_pixbuf_animation_iter_get_pixbuf (GdkPixbufAnimationIter *iter);
gboolean gdk_pixbuf_animation_iter_on_currently_loading_frame (GdkPixbufAnimationIter *iter);
gboolean gdk_pixbuf_animation_iter_advance (GdkPixbufAnimationIter *iter,
                                                                              const GTimeVal *current_time);




const gchar * gdk_pixbuf_get_option (GdkPixbuf *pixbuf,
                                              const gchar *key);



typedef struct _GdkPixbufFormat GdkPixbufFormat;

GSList *gdk_pixbuf_get_formats (void);
gchar *gdk_pixbuf_format_get_name (GdkPixbufFormat *format);
gchar *gdk_pixbuf_format_get_description (GdkPixbufFormat *format);
gchar **gdk_pixbuf_format_get_mime_types (GdkPixbufFormat *format);
gchar **gdk_pixbuf_format_get_extensions (GdkPixbufFormat *format);
gboolean gdk_pixbuf_format_is_writable (GdkPixbufFormat *format);



# 1 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h" 1 3 4
# 29 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h" 3 4

# 39 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h" 3 4
typedef struct _GdkPixbufLoader GdkPixbufLoader;
struct _GdkPixbufLoader
{
  GObject parent_instance;


  gpointer priv;
};

typedef struct _GdkPixbufLoaderClass GdkPixbufLoaderClass;
struct _GdkPixbufLoaderClass
{
  GObjectClass parent_class;

  void (*size_prepared) (GdkPixbufLoader *loader,
                              int width,
                              int height);

  void (*area_prepared) (GdkPixbufLoader *loader);


  void (*area_updated) (GdkPixbufLoader *loader,
                              int x,
                              int y,
                              int width,
                              int height);

  void (*closed) (GdkPixbufLoader *loader);
};

GType gdk_pixbuf_loader_get_type (void) ;
GdkPixbufLoader * gdk_pixbuf_loader_new (void);
GdkPixbufLoader * gdk_pixbuf_loader_new_with_type (const char *image_type,
                                                      GError **error);
void gdk_pixbuf_loader_set_size (GdkPixbufLoader *loader,
                                                 int width,
                                                 int height);
gboolean gdk_pixbuf_loader_write (GdkPixbufLoader *loader,
                                                      const guchar *buf,
                                                      gsize count,
                                                      GError **error);
GdkPixbuf * gdk_pixbuf_loader_get_pixbuf (GdkPixbufLoader *loader);
GdkPixbufAnimation * gdk_pixbuf_loader_get_animation (GdkPixbufLoader *loader);
gboolean gdk_pixbuf_loader_close (GdkPixbufLoader *loader,
                                                      GError **error);
GdkPixbufFormat *gdk_pixbuf_loader_get_format (GdkPixbufLoader *loader);


# 303 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h" 1 3 4
# 9 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h" 3 4




GType gdk_pixbuf_alpha_mode_get_type (void);


GType gdk_colorspace_get_type (void);


GType gdk_pixbuf_error_get_type (void);


GType gdk_interp_type_get_type (void);



# 304 "/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h" 2 3 4
# 8 "/usr/include/gtk-2.0/gdk/gdkdrawable.h" 2 3 4





typedef struct _GdkDrawableClass GdkDrawableClass;
# 22 "/usr/include/gtk-2.0/gdk/gdkdrawable.h" 3 4
struct _GdkDrawable
{
  GObject parent_instance;
};

struct _GdkDrawableClass
{
  GObjectClass parent_class;

  GdkGC *(*create_gc) (GdkDrawable *drawable,
                          GdkGCValues *values,
                          GdkGCValuesMask mask);
  void (*draw_rectangle) (GdkDrawable *drawable,
                          GdkGC *gc,
                          gboolean filled,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
  void (*draw_arc) (GdkDrawable *drawable,
                          GdkGC *gc,
                          gboolean filled,
                          gint x,
                          gint y,
                          gint width,
                          gint height,
                          gint angle1,
                          gint angle2);
  void (*draw_polygon) (GdkDrawable *drawable,
                          GdkGC *gc,
                          gboolean filled,
                          GdkPoint *points,
                          gint npoints);
  void (*draw_text) (GdkDrawable *drawable,
                          GdkFont *font,
                          GdkGC *gc,
                          gint x,
                          gint y,
                          const gchar *text,
                          gint text_length);
  void (*draw_text_wc) (GdkDrawable *drawable,
                          GdkFont *font,
                          GdkGC *gc,
                          gint x,
                          gint y,
                          const GdkWChar *text,
                          gint text_length);
  void (*draw_drawable) (GdkDrawable *drawable,
                          GdkGC *gc,
                          GdkDrawable *src,
                          gint xsrc,
                          gint ysrc,
                          gint xdest,
                          gint ydest,
                          gint width,
                          gint height);
  void (*draw_points) (GdkDrawable *drawable,
                          GdkGC *gc,
                          GdkPoint *points,
                          gint npoints);
  void (*draw_segments) (GdkDrawable *drawable,
                          GdkGC *gc,
                          GdkSegment *segs,
                          gint nsegs);
 void (*draw_lines) (GdkDrawable *drawable,
                          GdkGC *gc,
                          GdkPoint *points,
                          gint npoints);

  void (*draw_glyphs) (GdkDrawable *drawable,
                          GdkGC *gc,
                          PangoFont *font,
                          gint x,
                          gint y,
                          PangoGlyphString *glyphs);

  void (*draw_image) (GdkDrawable *drawable,
                          GdkGC *gc,
                          GdkImage *image,
                          gint xsrc,
                          gint ysrc,
                          gint xdest,
                          gint ydest,
                          gint width,
                          gint height);

  gint (*get_depth) (GdkDrawable *drawable);
  void (*get_size) (GdkDrawable *drawable,
                          gint *width,
                          gint *height);

  void (*set_colormap) (GdkDrawable *drawable,
                          GdkColormap *cmap);

  GdkColormap* (*get_colormap) (GdkDrawable *drawable);
  GdkVisual* (*get_visual) (GdkDrawable *drawable);
  GdkScreen* (*get_screen) (GdkDrawable *drawable);

  GdkImage* (*get_image) (GdkDrawable *drawable,
                              gint x,
                              gint y,
                              gint width,
                              gint height);

  GdkRegion* (*get_clip_region) (GdkDrawable *drawable);
  GdkRegion* (*get_visible_region) (GdkDrawable *drawable);

  GdkDrawable* (*get_composite_drawable) (GdkDrawable *drawable,
                                          gint x,
                                          gint y,
                                          gint width,
                                          gint height,
                                          gint *composite_x_offset,
                                          gint *composite_y_offset);

  void (*draw_pixbuf) (GdkDrawable *drawable,
                               GdkGC *gc,
                               GdkPixbuf *pixbuf,
                               gint src_x,
                               gint src_y,
                               gint dest_x,
                               gint dest_y,
                               gint width,
                               gint height,
                               GdkRgbDither dither,
                               gint x_dither,
                               gint y_dither);
  GdkImage* (*_copy_to_image) (GdkDrawable *drawable,
                                  GdkImage *image,
                                  gint src_x,
                                  gint src_y,
                                  gint dest_x,
                                  gint dest_y,
                                  gint width,
                                  gint height);


  void (*_gdk_reserved1) (void);
  void (*_gdk_reserved2) (void);
  void (*_gdk_reserved3) (void);
  void (*_gdk_reserved4) (void);
  void (*_gdk_reserved5) (void);
  void (*_gdk_reserved6) (void);
  void (*_gdk_reserved7) (void);
  void (*_gdk_reserved9) (void);
  void (*_gdk_reserved10) (void);
  void (*_gdk_reserved11) (void);
  void (*_gdk_reserved12) (void);
  void (*_gdk_reserved13) (void);
  void (*_gdk_reserved14) (void);
  void (*_gdk_reserved15) (void);
  void (*_gdk_reserved16) (void);
};

GType gdk_drawable_get_type (void);





void gdk_drawable_set_data (GdkDrawable *drawable,
                                           const gchar *key,
                                           gpointer data,
                                           GDestroyNotify destroy_func);
gpointer gdk_drawable_get_data (GdkDrawable *drawable,
                                           const gchar *key);


void gdk_drawable_get_size (GdkDrawable *drawable,
                                           gint *width,
                                           gint *height);
void gdk_drawable_set_colormap (GdkDrawable *drawable,
                                           GdkColormap *colormap);
GdkColormap* gdk_drawable_get_colormap (GdkDrawable *drawable);
GdkVisual* gdk_drawable_get_visual (GdkDrawable *drawable);
gint gdk_drawable_get_depth (GdkDrawable *drawable);
GdkScreen* gdk_drawable_get_screen (GdkDrawable *drawable);
GdkDisplay* gdk_drawable_get_display (GdkDrawable *drawable);


GdkDrawable* gdk_drawable_ref (GdkDrawable *drawable);
void gdk_drawable_unref (GdkDrawable *drawable);




void gdk_draw_point (GdkDrawable *drawable,
                         GdkGC *gc,
                         gint x,
                         gint y);
void gdk_draw_line (GdkDrawable *drawable,
                         GdkGC *gc,
                         gint x1_,
                         gint y1_,
                         gint x2_,
                         gint y2_);
void gdk_draw_rectangle (GdkDrawable *drawable,
                         GdkGC *gc,
                         gboolean filled,
                         gint x,
                         gint y,
                         gint width,
                         gint height);
void gdk_draw_arc (GdkDrawable *drawable,
                         GdkGC *gc,
                         gboolean filled,
                         gint x,
                         gint y,
                         gint width,
                         gint height,
                         gint angle1,
                         gint angle2);
void gdk_draw_polygon (GdkDrawable *drawable,
                         GdkGC *gc,
                         gboolean filled,
                         GdkPoint *points,
                         gint npoints);


void gdk_draw_string (GdkDrawable *drawable,
                         GdkFont *font,
                         GdkGC *gc,
                         gint x,
                         gint y,
                         const gchar *string);



void gdk_draw_text (GdkDrawable *drawable,
                         GdkFont *font,
                         GdkGC *gc,
                         gint x,
                         gint y,
                         const gchar *text,
                         gint text_length);

void gdk_draw_text_wc (GdkDrawable *drawable,
                         GdkFont *font,
                         GdkGC *gc,
                         gint x,
                         gint y,
                         const GdkWChar *text,
                         gint text_length);

void gdk_draw_drawable (GdkDrawable *drawable,
                         GdkGC *gc,
                         GdkDrawable *src,
                         gint xsrc,
                         gint ysrc,
                         gint xdest,
                         gint ydest,
                         gint width,
                         gint height);
void gdk_draw_image (GdkDrawable *drawable,
                         GdkGC *gc,
                         GdkImage *image,
                         gint xsrc,
                         gint ysrc,
                         gint xdest,
                         gint ydest,
                         gint width,
                         gint height);
void gdk_draw_points (GdkDrawable *drawable,
                         GdkGC *gc,
                         GdkPoint *points,
                         gint npoints);
void gdk_draw_segments (GdkDrawable *drawable,
                         GdkGC *gc,
                         GdkSegment *segs,
                         gint nsegs);
void gdk_draw_lines (GdkDrawable *drawable,
                         GdkGC *gc,
                         GdkPoint *points,
                         gint npoints);
void gdk_draw_pixbuf (GdkDrawable *drawable,
                         GdkGC *gc,
                         GdkPixbuf *pixbuf,
                         gint src_x,
                         gint src_y,
                         gint dest_x,
                         gint dest_y,
                         gint width,
                         gint height,
                         GdkRgbDither dither,
                         gint x_dither,
                         gint y_dither);

void gdk_draw_glyphs (GdkDrawable *drawable,
                           GdkGC *gc,
                           PangoFont *font,
                           gint x,
                           gint y,
                           PangoGlyphString *glyphs);
void gdk_draw_layout_line (GdkDrawable *drawable,
                           GdkGC *gc,
                           gint x,
                           gint y,
                           PangoLayoutLine *line);
void gdk_draw_layout (GdkDrawable *drawable,
                           GdkGC *gc,
                           gint x,
                           gint y,
                           PangoLayout *layout);

void gdk_draw_layout_line_with_colors (GdkDrawable *drawable,
                                       GdkGC *gc,
                                       gint x,
                                       gint y,
                                       PangoLayoutLine *line,
                                       GdkColor *foreground,
                                       GdkColor *background);
void gdk_draw_layout_with_colors (GdkDrawable *drawable,
                                       GdkGC *gc,
                                       gint x,
                                       gint y,
                                       PangoLayout *layout,
                                       GdkColor *foreground,
                                       GdkColor *background);






GdkImage* gdk_drawable_get_image (GdkDrawable *drawable,
                                  gint x,
                                  gint y,
                                  gint width,
                                  gint height);

GdkRegion *gdk_drawable_get_clip_region (GdkDrawable *drawable);
GdkRegion *gdk_drawable_get_visible_region (GdkDrawable *drawable);
# 35 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkenumtypes.h" 1 3 4
# 9 "/usr/include/gtk-2.0/gdk/gdkenumtypes.h" 3 4




GType gdk_cursor_type_get_type (void);




GType gdk_drag_action_get_type (void);


GType gdk_drag_protocol_get_type (void);




GType gdk_filter_return_get_type (void);


GType gdk_event_type_get_type (void);


GType gdk_event_mask_get_type (void);


GType gdk_visibility_state_get_type (void);


GType gdk_scroll_direction_get_type (void);


GType gdk_notify_type_get_type (void);


GType gdk_crossing_mode_get_type (void);


GType gdk_property_state_get_type (void);


GType gdk_window_state_get_type (void);


GType gdk_setting_action_get_type (void);




GType gdk_font_type_get_type (void);




GType gdk_cap_style_get_type (void);


GType gdk_fill_get_type (void);


GType gdk_function_get_type (void);


GType gdk_join_style_get_type (void);


GType gdk_line_style_get_type (void);


GType gdk_subwindow_mode_get_type (void);


GType gdk_gc_values_mask_get_type (void);




GType gdk_image_type_get_type (void);




GType gdk_extension_mode_get_type (void);


GType gdk_input_source_get_type (void);


GType gdk_input_mode_get_type (void);


GType gdk_axis_use_get_type (void);




GType gdk_prop_mode_get_type (void);




GType gdk_fill_rule_get_type (void);


GType gdk_overlap_type_get_type (void);




GType gdk_rgb_dither_get_type (void);




GType gdk_byte_order_get_type (void);


GType gdk_modifier_type_get_type (void);


GType gdk_input_condition_get_type (void);


GType gdk_status_get_type (void);


GType gdk_grab_status_get_type (void);




GType gdk_visual_type_get_type (void);




GType gdk_window_class_get_type (void);


GType gdk_window_type_get_type (void);


GType gdk_window_attributes_type_get_type (void);


GType gdk_window_hints_get_type (void);


GType gdk_window_type_hint_get_type (void);


GType gdk_wm_decoration_get_type (void);


GType gdk_wm_function_get_type (void);


GType gdk_gravity_get_type (void);


GType gdk_window_edge_get_type (void);



# 36 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gdk/gdkfont.h" 1 3 4
# 19 "/usr/include/gtk-2.0/gdk/gdkfont.h" 3 4
typedef enum
{
  GDK_FONT_FONT,
  GDK_FONT_FONTSET
} GdkFontType;

struct _GdkFont
{
  GdkFontType type;
  gint ascent;
  gint descent;
};

GType gdk_font_get_type (void);

GdkFont* gdk_font_ref (GdkFont *font);
void gdk_font_unref (GdkFont *font);
gint gdk_font_id (const GdkFont *font);
gboolean gdk_font_equal (const GdkFont *fonta,
                             const GdkFont *fontb);

GdkFont *gdk_font_load_for_display (GdkDisplay *display,
                                                const gchar *font_name);
GdkFont *gdk_fontset_load_for_display (GdkDisplay *display,
                                                const gchar *fontset_name);
GdkFont *gdk_font_from_description_for_display (GdkDisplay *display,
                                                PangoFontDescription *font_desc);




GdkFont* gdk_font_load (const gchar *font_name);
GdkFont* gdk_fontset_load (const gchar *fontset_name);
GdkFont* gdk_font_from_description (PangoFontDescription *font_desc);


gint gdk_string_width (GdkFont *font,
                             const gchar *string);
gint gdk_text_width (GdkFont *font,
                             const gchar *text,
                             gint text_length);
gint gdk_text_width_wc (GdkFont *font,
                             const GdkWChar *text,
                             gint text_length);
gint gdk_char_width (GdkFont *font,
                             gchar character);
gint gdk_char_width_wc (GdkFont *font,
                             GdkWChar character);
gint gdk_string_measure (GdkFont *font,
                             const gchar *string);
gint gdk_text_measure (GdkFont *font,
                             const gchar *text,
                             gint text_length);
gint gdk_char_measure (GdkFont *font,
                             gchar character);
gint gdk_string_height (GdkFont *font,
                             const gchar *string);
gint gdk_text_height (GdkFont *font,
                             const gchar *text,
                             gint text_length);
gint gdk_char_height (GdkFont *font,
                             gchar character);

void gdk_text_extents (GdkFont *font,
                             const gchar *text,
                             gint text_length,
                             gint *lbearing,
                             gint *rbearing,
                             gint *width,
                             gint *ascent,
                             gint *descent);
void gdk_text_extents_wc (GdkFont *font,
                             const GdkWChar *text,
                             gint text_length,
                             gint *lbearing,
                             gint *rbearing,
                             gint *width,
                             gint *ascent,
                             gint *descent);
void gdk_string_extents (GdkFont *font,
                             const gchar *string,
                             gint *lbearing,
                             gint *rbearing,
                             gint *width,
                             gint *ascent,
                             gint *descent);

GdkDisplay * gdk_font_get_display (GdkFont *font);
# 38 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gdk/gdkimage.h" 1 3 4
# 21 "/usr/include/gtk-2.0/gdk/gdkimage.h" 3 4
typedef enum
{
  GDK_IMAGE_NORMAL,
  GDK_IMAGE_SHARED,
  GDK_IMAGE_FASTEST
} GdkImageType;

typedef struct _GdkImageClass GdkImageClass;
# 37 "/usr/include/gtk-2.0/gdk/gdkimage.h" 3 4
struct _GdkImage
{
  GObject parent_instance;

  GdkImageType type;
  GdkVisual *visual;
  GdkByteOrder byte_order;
  gint width;
  gint height;
  guint16 depth;
  guint16 bpp;
  guint16 bpl;
  guint16 bits_per_pixel;
  gpointer mem;

  GdkColormap *colormap;

  gpointer windowing_data;
};

struct _GdkImageClass
{
  GObjectClass parent_class;
};

GType gdk_image_get_type (void) ;

GdkImage* gdk_image_new (GdkImageType type,
                                GdkVisual *visual,
                                gint width,
                                gint height);


GdkImage* gdk_image_get (GdkDrawable *drawable,
                                gint x,
                                gint y,
                                gint width,
                                gint height);

GdkImage * gdk_image_ref (GdkImage *image);
void gdk_image_unref (GdkImage *image);


void gdk_image_put_pixel (GdkImage *image,
                                gint x,
                                gint y,
                                guint32 pixel);
guint32 gdk_image_get_pixel (GdkImage *image,
                                gint x,
                                gint y);

void gdk_image_set_colormap (GdkImage *image,
                                   GdkColormap *colormap);
GdkColormap* gdk_image_get_colormap (GdkImage *image);
# 40 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gdk/gdkkeys.h" 1 3 4
# 36 "/usr/include/gtk-2.0/gdk/gdkkeys.h" 3 4
typedef struct _GdkKeymapKey GdkKeymapKey;


struct _GdkKeymapKey
{
  guint keycode;
  gint group;
  gint level;
};
# 54 "/usr/include/gtk-2.0/gdk/gdkkeys.h" 3 4
typedef struct _GdkKeymap GdkKeymap;
typedef struct _GdkKeymapClass GdkKeymapClass;
# 64 "/usr/include/gtk-2.0/gdk/gdkkeys.h" 3 4
struct _GdkKeymap
{
  GObject parent_instance;
  GdkDisplay *display;
};

struct _GdkKeymapClass
{
  GObjectClass parent_class;

  void (*direction_changed) (GdkKeymap *keymap);
  void (*keys_changed) (GdkKeymap *keymap);
};

GType gdk_keymap_get_type (void) ;


GdkKeymap* gdk_keymap_get_default (void);

GdkKeymap* gdk_keymap_get_for_display (GdkDisplay *display);


guint gdk_keymap_lookup_key (GdkKeymap *keymap,
                                                    const GdkKeymapKey *key);
gboolean gdk_keymap_translate_keyboard_state (GdkKeymap *keymap,
                                                    guint hardware_keycode,
                                                    GdkModifierType state,
                                                    gint group,
                                                    guint *keyval,
                                                    gint *effective_group,
                                                    gint *level,
                                                    GdkModifierType *consumed_modifiers);
gboolean gdk_keymap_get_entries_for_keyval (GdkKeymap *keymap,
                                                    guint keyval,
                                                    GdkKeymapKey **keys,
                                                    gint *n_keys);
gboolean gdk_keymap_get_entries_for_keycode (GdkKeymap *keymap,
                                                    guint hardware_keycode,
                                                    GdkKeymapKey **keys,
                                                    guint **keyvals,
                                                    gint *n_entries);
PangoDirection gdk_keymap_get_direction (GdkKeymap *keymap);



gchar* gdk_keyval_name (guint keyval) ;
guint gdk_keyval_from_name (const gchar *keyval_name);
void gdk_keyval_convert_case (guint symbol,
                                  guint *lower,
                                  guint *upper);
guint gdk_keyval_to_upper (guint keyval) ;
guint gdk_keyval_to_lower (guint keyval) ;
gboolean gdk_keyval_is_upper (guint keyval) ;
gboolean gdk_keyval_is_lower (guint keyval) ;

guint32 gdk_keyval_to_unicode (guint keyval) ;
guint gdk_unicode_to_keyval (guint32 wc) ;
# 42 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h" 1 3 4
# 33 "/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h" 3 4


typedef struct _GdkDisplayManager GdkDisplayManager;
typedef struct _GdkDisplayManagerClass GdkDisplayManagerClass;
# 45 "/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h" 3 4
struct _GdkDisplayManagerClass
{
  GObjectClass parent_class;

  void (*display_opened) (GdkDisplayManager *display_manager,
                          GdkDisplay *display);
};

GType gdk_display_manager_get_type (void) ;

GdkDisplayManager *gdk_display_manager_get (void);
GdkDisplay * gdk_display_manager_get_default_display (GdkDisplayManager *display_manager);
void gdk_display_manager_set_default_display (GdkDisplayManager *display_manager,
                                                            GdkDisplay *display);
GSList * gdk_display_manager_list_displays (GdkDisplayManager *display_manager);


# 43 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkpango.h" 1 3 4
# 31 "/usr/include/gtk-2.0/gdk/gdkpango.h" 3 4
PangoContext *gdk_pango_context_get_for_screen (GdkScreen *screen);

PangoContext *gdk_pango_context_get (void);

void gdk_pango_context_set_colormap (PangoContext *context,
                                                GdkColormap *colormap);
# 45 "/usr/include/gtk-2.0/gdk/gdkpango.h" 3 4
GdkRegion *gdk_pango_layout_line_get_clip_region (PangoLayoutLine *line,
                                                     gint x_origin,
                                                     gint y_origin,
                                                     gint *index_ranges,
                                                     gint n_ranges);
GdkRegion *gdk_pango_layout_get_clip_region (PangoLayout *layout,
                                                     gint x_origin,
                                                     gint y_origin,
                                                     gint *index_ranges,
                                                     gint n_ranges);





typedef struct _GdkPangoAttrStipple GdkPangoAttrStipple;
typedef struct _GdkPangoAttrEmbossed GdkPangoAttrEmbossed;

struct _GdkPangoAttrStipple
{
  PangoAttribute attr;
  GdkBitmap *stipple;
};

struct _GdkPangoAttrEmbossed
{
  PangoAttribute attr;
  gboolean embossed;
};

PangoAttribute *gdk_pango_attr_stipple_new (GdkBitmap *stipple);
PangoAttribute *gdk_pango_attr_embossed_new (gboolean embossed);
# 44 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkpixbuf.h" 1 3 4
# 14 "/usr/include/gtk-2.0/gdk/gdkpixbuf.h" 3 4
void gdk_pixbuf_render_threshold_alpha (GdkPixbuf *pixbuf,
                                          GdkBitmap *bitmap,
                                          int src_x,
                                          int src_y,
                                          int dest_x,
                                          int dest_y,
                                          int width,
                                          int height,
                                          int alpha_threshold);
void gdk_pixbuf_render_to_drawable (GdkPixbuf *pixbuf,
                                          GdkDrawable *drawable,
                                          GdkGC *gc,
                                          int src_x,
                                          int src_y,
                                          int dest_x,
                                          int dest_y,
                                          int width,
                                          int height,
                                          GdkRgbDither dither,
                                          int x_dither,
                                          int y_dither);
void gdk_pixbuf_render_to_drawable_alpha (GdkPixbuf *pixbuf,
                                          GdkDrawable *drawable,
                                          int src_x,
                                          int src_y,
                                          int dest_x,
                                          int dest_y,
                                          int width,
                                          int height,
                                          GdkPixbufAlphaMode alpha_mode,
                                          int alpha_threshold,
                                          GdkRgbDither dither,
                                          int x_dither,
                                          int y_dither);

void gdk_pixbuf_render_pixmap_and_mask_for_colormap (GdkPixbuf *pixbuf,
                                                     GdkColormap *colormap,
                                                     GdkPixmap **pixmap_return,
                                                     GdkBitmap **mask_return,
                                                     int alpha_threshold);

void gdk_pixbuf_render_pixmap_and_mask (GdkPixbuf *pixbuf,
                                                     GdkPixmap **pixmap_return,
                                                     GdkBitmap **mask_return,
                                                     int alpha_threshold);




GdkPixbuf *gdk_pixbuf_get_from_drawable (GdkPixbuf *dest,
                                         GdkDrawable *src,
                                         GdkColormap *cmap,
                                         int src_x,
                                         int src_y,
                                         int dest_x,
                                         int dest_y,
                                         int width,
                                         int height);

GdkPixbuf *gdk_pixbuf_get_from_image (GdkPixbuf *dest,
                                         GdkImage *src,
                                         GdkColormap *cmap,
                                         int src_x,
                                         int src_y,
                                         int dest_x,
                                         int dest_y,
                                         int width,
                                         int height);
# 45 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkpixmap.h" 1 3 4
# 11 "/usr/include/gtk-2.0/gdk/gdkpixmap.h" 3 4
typedef struct _GdkPixmapObject GdkPixmapObject;
typedef struct _GdkPixmapObjectClass GdkPixmapObjectClass;
# 22 "/usr/include/gtk-2.0/gdk/gdkpixmap.h" 3 4
struct _GdkPixmapObject
{
  GdkDrawable parent_instance;

  GdkDrawable *impl;

  gint depth;
};

struct _GdkPixmapObjectClass
{
  GdkDrawableClass parent_class;

};

GType gdk_pixmap_get_type (void) ;



GdkPixmap* gdk_pixmap_new (GdkDrawable *drawable,
                                         gint width,
                                         gint height,
                                         gint depth);
GdkBitmap* gdk_bitmap_create_from_data (GdkDrawable *drawable,
                                         const gchar *data,
                                         gint width,
                                         gint height);
GdkPixmap* gdk_pixmap_create_from_data (GdkDrawable *drawable,
                                         const gchar *data,
                                         gint width,
                                         gint height,
                                         gint depth,
                                         GdkColor *fg,
                                         GdkColor *bg);

GdkPixmap* gdk_pixmap_create_from_xpm (GdkDrawable *drawable,
                                                  GdkBitmap **mask,
                                                  GdkColor *transparent_color,
                                                  const gchar *filename);
GdkPixmap* gdk_pixmap_colormap_create_from_xpm (GdkDrawable *drawable,
                                                  GdkColormap *colormap,
                                                  GdkBitmap **mask,
                                                  GdkColor *transparent_color,
                                                  const gchar *filename);
GdkPixmap* gdk_pixmap_create_from_xpm_d (GdkDrawable *drawable,
                                                  GdkBitmap **mask,
                                                  GdkColor *transparent_color,
                                                  gchar **data);
GdkPixmap* gdk_pixmap_colormap_create_from_xpm_d (GdkDrawable *drawable,
                                                  GdkColormap *colormap,
                                                  GdkBitmap **mask,
                                                  GdkColor *transparent_color,
                                                  gchar **data);




GdkPixmap* gdk_pixmap_foreign_new (GdkNativeWindow anid);
GdkPixmap* gdk_pixmap_lookup (GdkNativeWindow anid);


GdkPixmap* gdk_pixmap_foreign_new_for_display (GdkDisplay *display,
                                                  GdkNativeWindow anid);
GdkPixmap* gdk_pixmap_lookup_for_display (GdkDisplay *display,
                                                  GdkNativeWindow anid);
# 46 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkproperty.h" 1 3 4
# 10 "/usr/include/gtk-2.0/gdk/gdkproperty.h" 3 4
typedef enum
{
  GDK_PROP_MODE_REPLACE,
  GDK_PROP_MODE_PREPEND,
  GDK_PROP_MODE_APPEND
} GdkPropMode;

GdkAtom gdk_atom_intern (const gchar *atom_name,
                         gboolean only_if_exists);
gchar* gdk_atom_name (GdkAtom atom);

gboolean gdk_property_get (GdkWindow *window,
                              GdkAtom property,
                              GdkAtom type,
                              gulong offset,
                              gulong length,
                              gint pdelete,
                              GdkAtom *actual_property_type,
                              gint *actual_format,
                              gint *actual_length,
                              guchar **data);
void gdk_property_change (GdkWindow *window,
                              GdkAtom property,
                              GdkAtom type,
                              gint format,
                              GdkPropMode mode,
                              const guchar *data,
                              gint nelements);
void gdk_property_delete (GdkWindow *window,
                              GdkAtom property);

gint gdk_text_property_to_text_list (GdkAtom encoding,
                                     gint format,
                                     const guchar *text,
                                     gint length,
                                     gchar ***list);
gint gdk_text_property_to_utf8_list (GdkAtom encoding,
                                     gint format,
                                     const guchar *text,
                                     gint length,
                                     gchar ***list);
gboolean gdk_utf8_to_compound_text (const gchar *str,
                                    GdkAtom *encoding,
                                    gint *format,
                                    guchar **ctext,
                                    gint *length);
gint gdk_string_to_compound_text (const gchar *str,
                                     GdkAtom *encoding,
                                     gint *format,
                                     guchar **ctext,
                                     gint *length);


gint gdk_text_property_to_text_list_for_display (GdkDisplay *display,
                                                 GdkAtom encoding,
                                                 gint format,
                                                 const guchar *text,
                                                 gint length,
                                                 gchar ***list);
gint gdk_text_property_to_utf8_list_for_display (GdkDisplay *display,
                                                 GdkAtom encoding,
                                                 gint format,
                                                 const guchar *text,
                                                 gint length,
                                                 gchar ***list);

gchar *gdk_utf8_to_string_target (const gchar *str);
gint gdk_string_to_compound_text_for_display (GdkDisplay *display,
                                                  const gchar *str,
                                                  GdkAtom *encoding,
                                                  gint *format,
                                                  guchar **ctext,
                                                  gint *length);
gboolean gdk_utf8_to_compound_text_for_display (GdkDisplay *display,
                                                  const gchar *str,
                                                  GdkAtom *encoding,
                                                  gint *format,
                                                  guchar **ctext,
                                                  gint *length);

void gdk_free_text_list (gchar **list);
void gdk_free_compound_text (guchar *ctext);
# 47 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkregion.h" 1 3 4
# 14 "/usr/include/gtk-2.0/gdk/gdkregion.h" 3 4
typedef enum
{
  GDK_EVEN_ODD_RULE,
  GDK_WINDING_RULE
} GdkFillRule;






typedef enum
{
  GDK_OVERLAP_RECTANGLE_IN,
  GDK_OVERLAP_RECTANGLE_OUT,
  GDK_OVERLAP_RECTANGLE_PART
} GdkOverlapType;

typedef void (*GdkSpanFunc) (GdkSpan *span,
                             gpointer data);

GdkRegion *gdk_region_new (void);
GdkRegion *gdk_region_polygon (GdkPoint *points,
                                 gint npoints,
                                 GdkFillRule fill_rule);
GdkRegion *gdk_region_copy (GdkRegion *region);
GdkRegion *gdk_region_rectangle (GdkRectangle *rectangle);
void gdk_region_destroy (GdkRegion *region);

void gdk_region_get_clipbox (GdkRegion *region,
                                          GdkRectangle *rectangle);
void gdk_region_get_rectangles (GdkRegion *region,
                                          GdkRectangle **rectangles,
                                          gint *n_rectangles);

gboolean gdk_region_empty (GdkRegion *region);
gboolean gdk_region_equal (GdkRegion *region1,
                                    GdkRegion *region2);
gboolean gdk_region_point_in (GdkRegion *region,
                                    int x,
                                    int y);
GdkOverlapType gdk_region_rect_in (GdkRegion *region,
                                    GdkRectangle *rect);

void gdk_region_offset (GdkRegion *region,
                                 gint dx,
                                 gint dy);
void gdk_region_shrink (GdkRegion *region,
                                 gint dx,
                                 gint dy);
void gdk_region_union_with_rect (GdkRegion *region,
                                 GdkRectangle *rect);
void gdk_region_intersect (GdkRegion *source1,
                                 GdkRegion *source2);
void gdk_region_union (GdkRegion *source1,
                                 GdkRegion *source2);
void gdk_region_subtract (GdkRegion *source1,
                                 GdkRegion *source2);
void gdk_region_xor (GdkRegion *source1,
                                 GdkRegion *source2);

void gdk_region_spans_intersect_foreach (GdkRegion *region,
                                         GdkSpan *spans,
                                         int n_spans,
                                         gboolean sorted,
                                         GdkSpanFunc function,
                                         gpointer data);
# 48 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gdk/gdkscreen.h" 1 3 4
# 30 "/usr/include/gtk-2.0/gdk/gdkscreen.h" 3 4


typedef struct _GdkScreenClass GdkScreenClass;
# 41 "/usr/include/gtk-2.0/gdk/gdkscreen.h" 3 4
struct _GdkScreen
{
  GObject parent_instance;

  guint closed : 1;
};

struct _GdkScreenClass
{
  GObjectClass parent_class;

  void (*size_changed) (GdkScreen *screen);
};

GType gdk_screen_get_type (void);
GdkColormap *gdk_screen_get_default_colormap (GdkScreen *screen);
void gdk_screen_set_default_colormap (GdkScreen *screen,
                                               GdkColormap *colormap);
GdkColormap* gdk_screen_get_system_colormap (GdkScreen *screen);
GdkVisual* gdk_screen_get_system_visual (GdkScreen *screen);
GdkColormap *gdk_screen_get_rgb_colormap (GdkScreen *screen);
GdkVisual * gdk_screen_get_rgb_visual (GdkScreen *screen);

GdkWindow * gdk_screen_get_root_window (GdkScreen *screen);
GdkDisplay * gdk_screen_get_display (GdkScreen *screen);
gint gdk_screen_get_number (GdkScreen *screen);
gint gdk_screen_get_width (GdkScreen *screen);
gint gdk_screen_get_height (GdkScreen *screen);
gint gdk_screen_get_width_mm (GdkScreen *screen);
gint gdk_screen_get_height_mm (GdkScreen *screen);

GList * gdk_screen_list_visuals (GdkScreen *screen);
GList * gdk_screen_get_toplevel_windows (GdkScreen *screen);
gchar * gdk_screen_make_display_name (GdkScreen *screen);

gint gdk_screen_get_n_monitors (GdkScreen *screen);
void gdk_screen_get_monitor_geometry (GdkScreen *screen,
                                                gint monitor_num,
                                                GdkRectangle *dest);
gint gdk_screen_get_monitor_at_point (GdkScreen *screen,
                                                gint x,
                                                gint y);
gint gdk_screen_get_monitor_at_window (GdkScreen *screen,
                                                GdkWindow *window);

void gdk_screen_broadcast_client_message (GdkScreen *screen,
                                                    GdkEvent *event);

GdkScreen *gdk_screen_get_default (void);

gboolean gdk_screen_get_setting (GdkScreen *screen,
                                   const gchar *name,
                                   GValue *value);


# 50 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkselection.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gdk/gdkselection.h" 3 4
typedef GdkAtom GdkSelection;
typedef GdkAtom GdkTarget;
typedef GdkAtom GdkSelectionType;







gboolean gdk_selection_owner_set (GdkWindow *owner,
                                    GdkAtom selection,
                                    guint32 time_,
                                    gboolean send_event);
GdkWindow* gdk_selection_owner_get (GdkAtom selection);


gboolean gdk_selection_owner_set_for_display (GdkDisplay *display,
                                                GdkWindow *owner,
                                                GdkAtom selection,
                                                guint32 time_,
                                                gboolean send_event);
GdkWindow *gdk_selection_owner_get_for_display (GdkDisplay *display,
                                                GdkAtom selection);

void gdk_selection_convert (GdkWindow *requestor,
                                    GdkAtom selection,
                                    GdkAtom target,
                                    guint32 time_);
gboolean gdk_selection_property_get (GdkWindow *requestor,
                                       guchar **data,
                                       GdkAtom *prop_type,
                                       gint *prop_format);


void gdk_selection_send_notify (guint32 requestor,
                                      GdkAtom selection,
                                      GdkAtom target,
                                      GdkAtom property,
                                      guint32 time_);


void gdk_selection_send_notify_for_display (GdkDisplay *display,
                                                  guint32 requestor,
                                                  GdkAtom selection,
                                                  GdkAtom target,
                                                  GdkAtom property,
                                                  guint32 time_);
# 51 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gdk/gdkvisual.h" 1 3 4






# 15 "/usr/include/gtk-2.0/gdk/gdkvisual.h" 3 4
typedef struct _GdkVisualClass GdkVisualClass;
# 25 "/usr/include/gtk-2.0/gdk/gdkvisual.h" 3 4
typedef enum
{
  GDK_VISUAL_STATIC_GRAY,
  GDK_VISUAL_GRAYSCALE,
  GDK_VISUAL_STATIC_COLOR,
  GDK_VISUAL_PSEUDO_COLOR,
  GDK_VISUAL_TRUE_COLOR,
  GDK_VISUAL_DIRECT_COLOR
} GdkVisualType;
# 47 "/usr/include/gtk-2.0/gdk/gdkvisual.h" 3 4
struct _GdkVisual
{
  GObject parent_instance;

  GdkVisualType type;
  gint depth;
  GdkByteOrder byte_order;
  gint colormap_size;
  gint bits_per_rgb;

  guint32 red_mask;
  gint red_shift;
  gint red_prec;

  guint32 green_mask;
  gint green_shift;
  gint green_prec;

  guint32 blue_mask;
  gint blue_shift;
  gint blue_prec;
};

GType gdk_visual_get_type (void);


gint gdk_visual_get_best_depth (void);
GdkVisualType gdk_visual_get_best_type (void);
GdkVisual* gdk_visual_get_system (void);
GdkVisual* gdk_visual_get_best (void);
GdkVisual* gdk_visual_get_best_with_depth (gint depth);
GdkVisual* gdk_visual_get_best_with_type (GdkVisualType visual_type);
GdkVisual* gdk_visual_get_best_with_both (gint depth,
                                              GdkVisualType visual_type);

void gdk_query_depths (gint **depths,
                             gint *count);
void gdk_query_visual_types (GdkVisualType **visual_types,
                             gint *count);

GList* gdk_list_visuals (void);


GdkScreen *gdk_visual_get_screen (GdkVisual *visual);







# 53 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gdk/gdkwindow.h" 1 3 4
# 12 "/usr/include/gtk-2.0/gdk/gdkwindow.h" 3 4
typedef struct _GdkGeometry GdkGeometry;
typedef struct _GdkWindowAttr GdkWindowAttr;
typedef struct _GdkPointerHooks GdkPointerHooks;
# 25 "/usr/include/gtk-2.0/gdk/gdkwindow.h" 3 4
typedef enum
{
  GDK_INPUT_OUTPUT,
  GDK_INPUT_ONLY
} GdkWindowClass;
# 44 "/usr/include/gtk-2.0/gdk/gdkwindow.h" 3 4
typedef enum
{
  GDK_WINDOW_ROOT,
  GDK_WINDOW_TOPLEVEL,
  GDK_WINDOW_CHILD,
  GDK_WINDOW_DIALOG,
  GDK_WINDOW_TEMP,
  GDK_WINDOW_FOREIGN
} GdkWindowType;
# 62 "/usr/include/gtk-2.0/gdk/gdkwindow.h" 3 4
typedef enum
{
  GDK_WA_TITLE = 1 << 1,
  GDK_WA_X = 1 << 2,
  GDK_WA_Y = 1 << 3,
  GDK_WA_CURSOR = 1 << 4,
  GDK_WA_COLORMAP = 1 << 5,
  GDK_WA_VISUAL = 1 << 6,
  GDK_WA_WMCLASS = 1 << 7,
  GDK_WA_NOREDIR = 1 << 8
} GdkWindowAttributesType;



typedef enum
{
  GDK_HINT_POS = 1 << 0,
  GDK_HINT_MIN_SIZE = 1 << 1,
  GDK_HINT_MAX_SIZE = 1 << 2,
  GDK_HINT_BASE_SIZE = 1 << 3,
  GDK_HINT_ASPECT = 1 << 4,
  GDK_HINT_RESIZE_INC = 1 << 5,
  GDK_HINT_WIN_GRAVITY = 1 << 6,
  GDK_HINT_USER_POS = 1 << 7,
  GDK_HINT_USER_SIZE = 1 << 8
} GdkWindowHints;
# 102 "/usr/include/gtk-2.0/gdk/gdkwindow.h" 3 4
typedef enum
{
  GDK_WINDOW_TYPE_HINT_NORMAL,
  GDK_WINDOW_TYPE_HINT_DIALOG,
  GDK_WINDOW_TYPE_HINT_MENU,
  GDK_WINDOW_TYPE_HINT_TOOLBAR,
  GDK_WINDOW_TYPE_HINT_SPLASHSCREEN,
  GDK_WINDOW_TYPE_HINT_UTILITY,
  GDK_WINDOW_TYPE_HINT_DOCK,
  GDK_WINDOW_TYPE_HINT_DESKTOP
} GdkWindowTypeHint;







typedef enum
{
  GDK_DECOR_ALL = 1 << 0,
  GDK_DECOR_BORDER = 1 << 1,
  GDK_DECOR_RESIZEH = 1 << 2,
  GDK_DECOR_TITLE = 1 << 3,
  GDK_DECOR_MENU = 1 << 4,
  GDK_DECOR_MINIMIZE = 1 << 5,
  GDK_DECOR_MAXIMIZE = 1 << 6
} GdkWMDecoration;

typedef enum
{
  GDK_FUNC_ALL = 1 << 0,
  GDK_FUNC_RESIZE = 1 << 1,
  GDK_FUNC_MOVE = 1 << 2,
  GDK_FUNC_MINIMIZE = 1 << 3,
  GDK_FUNC_MAXIMIZE = 1 << 4,
  GDK_FUNC_CLOSE = 1 << 5
} GdkWMFunction;





typedef enum
{
  GDK_GRAVITY_NORTH_WEST = 1,
  GDK_GRAVITY_NORTH,
  GDK_GRAVITY_NORTH_EAST,
  GDK_GRAVITY_WEST,
  GDK_GRAVITY_CENTER,
  GDK_GRAVITY_EAST,
  GDK_GRAVITY_SOUTH_WEST,
  GDK_GRAVITY_SOUTH,
  GDK_GRAVITY_SOUTH_EAST,
  GDK_GRAVITY_STATIC
} GdkGravity;


typedef enum
{
  GDK_WINDOW_EDGE_NORTH_WEST,
  GDK_WINDOW_EDGE_NORTH,
  GDK_WINDOW_EDGE_NORTH_EAST,
  GDK_WINDOW_EDGE_WEST,
  GDK_WINDOW_EDGE_EAST,
  GDK_WINDOW_EDGE_SOUTH_WEST,
  GDK_WINDOW_EDGE_SOUTH,
  GDK_WINDOW_EDGE_SOUTH_EAST
} GdkWindowEdge;

struct _GdkWindowAttr
{
  gchar *title;
  gint event_mask;
  gint x, y;
  gint width;
  gint height;
  GdkWindowClass wclass;
  GdkVisual *visual;
  GdkColormap *colormap;
  GdkWindowType window_type;
  GdkCursor *cursor;
  gchar *wmclass_name;
  gchar *wmclass_class;
  gboolean override_redirect;
};

struct _GdkGeometry
{
  gint min_width;
  gint min_height;
  gint max_width;
  gint max_height;
  gint base_width;
  gint base_height;
  gint width_inc;
  gint height_inc;
  gdouble min_aspect;
  gdouble max_aspect;
  GdkGravity win_gravity;
};

struct _GdkPointerHooks
{
  GdkWindow* (*get_pointer) (GdkWindow *window,
                                   gint *x,
                                   gint *y,
                                   GdkModifierType *mask);
  GdkWindow* (*window_at_pointer) (GdkScreen *screen,
                                   gint *win_x,
                                   gint *win_y);
};

typedef struct _GdkWindowObject GdkWindowObject;
typedef struct _GdkWindowObjectClass GdkWindowObjectClass;
# 226 "/usr/include/gtk-2.0/gdk/gdkwindow.h" 3 4
struct _GdkWindowObject
{
  GdkDrawable parent_instance;

  GdkDrawable *impl;

  GdkWindowObject *parent;

  gpointer user_data;

  gint x;
  gint y;

  gint extension_events;

  GList *filters;
  GList *children;

  GdkColor bg_color;
  GdkPixmap *bg_pixmap;

  GSList *paint_stack;

  GdkRegion *update_area;
  guint update_freeze_count;

  guint8 window_type;
  guint8 depth;
  guint8 resize_count;

  GdkWindowState state;

  guint guffaw_gravity : 1;
  guint input_only : 1;
  guint modal_hint : 1;

  guint destroyed : 2;

  GdkEventMask event_mask;
};

struct _GdkWindowObjectClass
{
  GdkDrawableClass parent_class;
};



GType gdk_window_object_get_type (void) ;
GdkWindow* gdk_window_new (GdkWindow *parent,
                                                GdkWindowAttr *attributes,
                                                gint attributes_mask);
void gdk_window_destroy (GdkWindow *window);
GdkWindowType gdk_window_get_window_type (GdkWindow *window);
GdkWindow* gdk_window_at_pointer (gint *win_x,
                                                gint *win_y);
void gdk_window_show (GdkWindow *window);
void gdk_window_hide (GdkWindow *window);
void gdk_window_withdraw (GdkWindow *window);
void gdk_window_show_unraised (GdkWindow *window);
void gdk_window_move (GdkWindow *window,
                                                gint x,
                                                gint y);
void gdk_window_resize (GdkWindow *window,
                                                gint width,
                                                gint height);
void gdk_window_move_resize (GdkWindow *window,
                                                gint x,
                                                gint y,
                                                gint width,
                                                gint height);
void gdk_window_reparent (GdkWindow *window,
                                                GdkWindow *new_parent,
                                                gint x,
                                                gint y);
void gdk_window_clear (GdkWindow *window);
void gdk_window_clear_area (GdkWindow *window,
                                                gint x,
                                                gint y,
                                                gint width,
                                                gint height);
void gdk_window_clear_area_e (GdkWindow *window,
                                                gint x,
                                                gint y,
                                                gint width,
                                                gint height);
void gdk_window_raise (GdkWindow *window);
void gdk_window_lower (GdkWindow *window);
void gdk_window_focus (GdkWindow *window,
                                                guint32 timestamp);
void gdk_window_set_user_data (GdkWindow *window,
                                                gpointer user_data);
void gdk_window_set_override_redirect (GdkWindow *window,
                                                gboolean override_redirect);
void gdk_window_add_filter (GdkWindow *window,
                                                GdkFilterFunc function,
                                                gpointer data);
void gdk_window_remove_filter (GdkWindow *window,
                                                GdkFilterFunc function,
                                                gpointer data);
void gdk_window_scroll (GdkWindow *window,
                                                gint dx,
                                                gint dy);







void gdk_window_shape_combine_mask (GdkWindow *window,
                                     GdkBitmap *mask,
                                     gint x,
                                     gint y);
void gdk_window_shape_combine_region (GdkWindow *window,
                                      GdkRegion *shape_region,
                                      gint offset_x,
                                      gint offset_y);
# 352 "/usr/include/gtk-2.0/gdk/gdkwindow.h" 3 4
void gdk_window_set_child_shapes (GdkWindow *window);
# 361 "/usr/include/gtk-2.0/gdk/gdkwindow.h" 3 4
void gdk_window_merge_child_shapes (GdkWindow *window);







gboolean gdk_window_is_visible (GdkWindow *window);
gboolean gdk_window_is_viewable (GdkWindow *window);

GdkWindowState gdk_window_get_state (GdkWindow *window);




gboolean gdk_window_set_static_gravities (GdkWindow *window,
                                          gboolean use_static);



GdkWindow* gdk_window_foreign_new (GdkNativeWindow anid);
GdkWindow* gdk_window_lookup (GdkNativeWindow anid);

GdkWindow *gdk_window_foreign_new_for_display (GdkDisplay *display,
                                                  GdkNativeWindow anid);
GdkWindow* gdk_window_lookup_for_display (GdkDisplay *display,
                                             GdkNativeWindow anid);





void gdk_window_set_hints (GdkWindow *window,
                                          gint x,
                                          gint y,
                                          gint min_width,
                                          gint min_height,
                                          gint max_width,
                                          gint max_height,
                                          gint flags);

void gdk_window_set_type_hint (GdkWindow *window,
                                           GdkWindowTypeHint hint);
void gdk_window_set_modal_hint (GdkWindow *window,
                                           gboolean modal);

void gdk_window_set_skip_taskbar_hint (GdkWindow *window,
                                       gboolean skips_taskbar);
void gdk_window_set_skip_pager_hint (GdkWindow *window,
                                       gboolean skips_pager);

void gdk_window_set_geometry_hints (GdkWindow *window,
                                             GdkGeometry *geometry,
                                             GdkWindowHints geom_mask);
void gdk_set_sm_client_id (const gchar *sm_client_id);

void gdk_window_begin_paint_rect (GdkWindow *window,
                                             GdkRectangle *rectangle);
void gdk_window_begin_paint_region (GdkWindow *window,
                                             GdkRegion *region);
void gdk_window_end_paint (GdkWindow *window);

void gdk_window_set_title (GdkWindow *window,
                                            const gchar *title);
void gdk_window_set_role (GdkWindow *window,
                                            const gchar *role);
void gdk_window_set_transient_for (GdkWindow *window,
                                            GdkWindow *parent);
void gdk_window_set_background (GdkWindow *window,
                                          GdkColor *color);
void gdk_window_set_back_pixmap (GdkWindow *window,
                                          GdkPixmap *pixmap,
                                          gboolean parent_relative);
void gdk_window_set_cursor (GdkWindow *window,
                                          GdkCursor *cursor);
void gdk_window_get_user_data (GdkWindow *window,
                                          gpointer *data);
void gdk_window_get_geometry (GdkWindow *window,
                                          gint *x,
                                          gint *y,
                                          gint *width,
                                          gint *height,
                                          gint *depth);
void gdk_window_get_position (GdkWindow *window,
                                          gint *x,
                                          gint *y);
gint gdk_window_get_origin (GdkWindow *window,
                                          gint *x,
                                          gint *y);



gboolean gdk_window_get_deskrelative_origin (GdkWindow *window,
                                          gint *x,
                                          gint *y);


void gdk_window_get_root_origin (GdkWindow *window,
                                          gint *x,
                                          gint *y);
void gdk_window_get_frame_extents (GdkWindow *window,
                                            GdkRectangle *rect);
GdkWindow* gdk_window_get_pointer (GdkWindow *window,
                                          gint *x,
                                          gint *y,
                                          GdkModifierType *mask);
GdkWindow * gdk_window_get_parent (GdkWindow *window);
GdkWindow * gdk_window_get_toplevel (GdkWindow *window);

GList * gdk_window_get_children (GdkWindow *window);
GList * gdk_window_peek_children (GdkWindow *window);
GdkEventMask gdk_window_get_events (GdkWindow *window);
void gdk_window_set_events (GdkWindow *window,
                                          GdkEventMask event_mask);

void gdk_window_set_icon_list (GdkWindow *window,
                                          GList *pixbufs);
void gdk_window_set_icon (GdkWindow *window,
                                          GdkWindow *icon_window,
                                          GdkPixmap *pixmap,
                                          GdkBitmap *mask);
void gdk_window_set_icon_name (GdkWindow *window,
                                          const gchar *name);
void gdk_window_set_group (GdkWindow *window,
                                          GdkWindow *leader);
void gdk_window_set_decorations (GdkWindow *window,
                                          GdkWMDecoration decorations);
gboolean gdk_window_get_decorations (GdkWindow *window,
                                          GdkWMDecoration *decorations);
void gdk_window_set_functions (GdkWindow *window,
                                          GdkWMFunction functions);

GList * gdk_window_get_toplevels (void);


void gdk_window_iconify (GdkWindow *window);
void gdk_window_deiconify (GdkWindow *window);
void gdk_window_stick (GdkWindow *window);
void gdk_window_unstick (GdkWindow *window);
void gdk_window_maximize (GdkWindow *window);
void gdk_window_unmaximize (GdkWindow *window);
void gdk_window_fullscreen (GdkWindow *window);
void gdk_window_unfullscreen (GdkWindow *window);

void gdk_window_register_dnd (GdkWindow *window);

void gdk_window_begin_resize_drag (GdkWindow *window,
                                   GdkWindowEdge edge,
                                   gint button,
                                   gint root_x,
                                   gint root_y,
                                   guint32 timestamp);
void gdk_window_begin_move_drag (GdkWindow *window,
                                   gint button,
                                   gint root_x,
                                   gint root_y,
                                   guint32 timestamp);


void gdk_window_invalidate_rect (GdkWindow *window,
                                                 GdkRectangle *rect,
                                                 gboolean invalidate_children);
void gdk_window_invalidate_region (GdkWindow *window,
                                                 GdkRegion *region,
                                                 gboolean invalidate_children);
void gdk_window_invalidate_maybe_recurse (GdkWindow *window,
                                                 GdkRegion *region,
                                                 gboolean (*child_func) (GdkWindow *, gpointer),
                                                 gpointer user_data);
GdkRegion *gdk_window_get_update_area (GdkWindow *window);

void gdk_window_freeze_updates (GdkWindow *window);
void gdk_window_thaw_updates (GdkWindow *window);

void gdk_window_process_all_updates (void);
void gdk_window_process_updates (GdkWindow *window,
                                           gboolean update_children);


void gdk_window_set_debug_updates (gboolean setting);

void gdk_window_constrain_size (GdkGeometry *geometry,
                                           guint flags,
                                           gint width,
                                           gint height,
                                           gint *new_width,
                                           gint *new_height);

void gdk_window_get_internal_paint_info (GdkWindow *window,
                                         GdkDrawable **real_drawable,
                                         gint *x_offset,
                                         gint *y_offset);


GdkPointerHooks *gdk_set_pointer_hooks (const GdkPointerHooks *new_hooks);


GdkWindow *gdk_get_default_root_window (void);
# 54 "/usr/include/gtk-2.0/gdk/gdk.h" 2 3 4
# 63 "/usr/include/gtk-2.0/gdk/gdk.h" 3 4
void gdk_parse_args (gint *argc,
                                         gchar ***argv);
void gdk_init (gint *argc,
                                         gchar ***argv);
gboolean gdk_init_check (gint *argc,
                                         gchar ***argv);


void gdk_exit (gint error_code);

gchar* gdk_set_locale (void);

const char *gdk_get_program_class (void);
void gdk_set_program_class (const char *program_class);



void gdk_error_trap_push (void);
gint gdk_error_trap_pop (void);


void gdk_set_use_xshm (gboolean use_xshm);
gboolean gdk_get_use_xshm (void);


gchar* gdk_get_display (void);
const gchar* gdk_get_display_arg_name (void);



gint gdk_input_add_full (gint source,
                           GdkInputCondition condition,
                           GdkInputFunction function,
                           gpointer data,
                           GdkDestroyNotify destroy);


gint gdk_input_add (gint source,
                           GdkInputCondition condition,
                           GdkInputFunction function,
                           gpointer data);
void gdk_input_remove (gint tag);


GdkGrabStatus gdk_pointer_grab (GdkWindow *window,
                                      gboolean owner_events,
                                      GdkEventMask event_mask,
                                      GdkWindow *confine_to,
                                      GdkCursor *cursor,
                                      guint32 time_);
GdkGrabStatus gdk_keyboard_grab (GdkWindow *window,
                                      gboolean owner_events,
                                      guint32 time_);


void gdk_pointer_ungrab (guint32 time_);
void gdk_keyboard_ungrab (guint32 time_);
gboolean gdk_pointer_is_grabbed (void);

gint gdk_screen_width (void) ;
gint gdk_screen_height (void) ;

gint gdk_screen_width_mm (void) ;
gint gdk_screen_height_mm (void) ;

void gdk_beep (void);


void gdk_flush (void);


void gdk_set_double_click_time (guint msec);




gboolean gdk_rectangle_intersect (GdkRectangle *src1,
                                  GdkRectangle *src2,
                                  GdkRectangle *dest);
void gdk_rectangle_union (GdkRectangle *src1,
                                  GdkRectangle *src2,
                                  GdkRectangle *dest);

GType gdk_rectangle_get_type (void);





gchar *gdk_wcstombs (const GdkWChar *src);
gint gdk_mbstowcs (GdkWChar *dest,
                                  const gchar *src,
                                  gint dest_max);



gboolean gdk_event_send_client_message (GdkEvent *event,
                                             GdkNativeWindow winid);
void gdk_event_send_clientmessage_toall (GdkEvent *event);

gboolean gdk_event_send_client_message_for_display (GdkDisplay *display,
                                                    GdkEvent *event,
                                                    GdkNativeWindow winid);

void gdk_notify_startup_complete (void);




extern GMutex *gdk_threads_mutex;

void gdk_threads_enter (void);
void gdk_threads_leave (void);
void gdk_threads_init (void);
# 32 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkenums.h" 1 3 4
# 38 "/usr/include/gtk-2.0/gtk/gtkenums.h" 3 4
typedef enum
{
  GTK_ANCHOR_CENTER,
  GTK_ANCHOR_NORTH,
  GTK_ANCHOR_NORTH_WEST,
  GTK_ANCHOR_NORTH_EAST,
  GTK_ANCHOR_SOUTH,
  GTK_ANCHOR_SOUTH_WEST,
  GTK_ANCHOR_SOUTH_EAST,
  GTK_ANCHOR_WEST,
  GTK_ANCHOR_EAST,
  GTK_ANCHOR_N = GTK_ANCHOR_NORTH,
  GTK_ANCHOR_NW = GTK_ANCHOR_NORTH_WEST,
  GTK_ANCHOR_NE = GTK_ANCHOR_NORTH_EAST,
  GTK_ANCHOR_S = GTK_ANCHOR_SOUTH,
  GTK_ANCHOR_SW = GTK_ANCHOR_SOUTH_WEST,
  GTK_ANCHOR_SE = GTK_ANCHOR_SOUTH_EAST,
  GTK_ANCHOR_W = GTK_ANCHOR_WEST,
  GTK_ANCHOR_E = GTK_ANCHOR_EAST
} GtkAnchorType;


typedef enum
{
  GTK_ARROW_UP,
  GTK_ARROW_DOWN,
  GTK_ARROW_LEFT,
  GTK_ARROW_RIGHT
} GtkArrowType;


typedef enum
{
  GTK_EXPAND = 1 << 0,
  GTK_SHRINK = 1 << 1,
  GTK_FILL = 1 << 2
} GtkAttachOptions;


typedef enum
{
  GTK_BUTTONBOX_DEFAULT_STYLE,
  GTK_BUTTONBOX_SPREAD,
  GTK_BUTTONBOX_EDGE,
  GTK_BUTTONBOX_START,
  GTK_BUTTONBOX_END
} GtkButtonBoxStyle;


typedef enum
{
  GTK_CURVE_TYPE_LINEAR,
  GTK_CURVE_TYPE_SPLINE,
  GTK_CURVE_TYPE_FREE
} GtkCurveType;

typedef enum {
  GTK_DELETE_CHARS,
  GTK_DELETE_WORD_ENDS,


  GTK_DELETE_WORDS,
  GTK_DELETE_DISPLAY_LINES,
  GTK_DELETE_DISPLAY_LINE_ENDS,
  GTK_DELETE_PARAGRAPH_ENDS,
  GTK_DELETE_PARAGRAPHS,
  GTK_DELETE_WHITESPACE
} GtkDeleteType;


typedef enum
{
  GTK_DIR_TAB_FORWARD,
  GTK_DIR_TAB_BACKWARD,
  GTK_DIR_UP,
  GTK_DIR_DOWN,
  GTK_DIR_LEFT,
  GTK_DIR_RIGHT
} GtkDirectionType;


typedef enum
{
  GTK_EXPANDER_COLLAPSED,
  GTK_EXPANDER_SEMI_COLLAPSED,
  GTK_EXPANDER_SEMI_EXPANDED,
  GTK_EXPANDER_EXPANDED
} GtkExpanderStyle;


typedef enum
{
  GTK_ICON_SIZE_INVALID,
  GTK_ICON_SIZE_MENU,
  GTK_ICON_SIZE_SMALL_TOOLBAR,
  GTK_ICON_SIZE_LARGE_TOOLBAR,
  GTK_ICON_SIZE_BUTTON,
  GTK_ICON_SIZE_DND,
  GTK_ICON_SIZE_DIALOG
} GtkIconSize;



typedef enum
{
  GTK_SIDE_TOP,
  GTK_SIDE_BOTTOM,
  GTK_SIDE_LEFT,
  GTK_SIDE_RIGHT
} GtkSideType;



typedef enum
{
  GTK_TEXT_DIR_NONE,
  GTK_TEXT_DIR_LTR,
  GTK_TEXT_DIR_RTL
} GtkTextDirection;


typedef enum
{
  GTK_JUSTIFY_LEFT,
  GTK_JUSTIFY_RIGHT,
  GTK_JUSTIFY_CENTER,
  GTK_JUSTIFY_FILL
} GtkJustification;



typedef enum
{
  GTK_MATCH_ALL,
  GTK_MATCH_ALL_TAIL,
  GTK_MATCH_HEAD,
  GTK_MATCH_TAIL,
  GTK_MATCH_EXACT,
  GTK_MATCH_LAST
} GtkMatchType;



typedef enum
{
  GTK_MENU_DIR_PARENT,
  GTK_MENU_DIR_CHILD,
  GTK_MENU_DIR_NEXT,
  GTK_MENU_DIR_PREV
} GtkMenuDirectionType;

typedef enum
{
  GTK_PIXELS,
  GTK_INCHES,
  GTK_CENTIMETERS
} GtkMetricType;

typedef enum {
  GTK_MOVEMENT_LOGICAL_POSITIONS,
  GTK_MOVEMENT_VISUAL_POSITIONS,
  GTK_MOVEMENT_WORDS,
  GTK_MOVEMENT_DISPLAY_LINES,
  GTK_MOVEMENT_DISPLAY_LINE_ENDS,
  GTK_MOVEMENT_PARAGRAPHS,
  GTK_MOVEMENT_PARAGRAPH_ENDS,
  GTK_MOVEMENT_PAGES,
  GTK_MOVEMENT_BUFFER_ENDS
} GtkMovementStep;


typedef enum
{
  GTK_ORIENTATION_HORIZONTAL,
  GTK_ORIENTATION_VERTICAL
} GtkOrientation;


typedef enum
{
  GTK_CORNER_TOP_LEFT,
  GTK_CORNER_BOTTOM_LEFT,
  GTK_CORNER_TOP_RIGHT,
  GTK_CORNER_BOTTOM_RIGHT
} GtkCornerType;


typedef enum
{
  GTK_PACK_START,
  GTK_PACK_END
} GtkPackType;


typedef enum
{
  GTK_PATH_PRIO_LOWEST = 0,
  GTK_PATH_PRIO_GTK = 4,
  GTK_PATH_PRIO_APPLICATION = 8,
  GTK_PATH_PRIO_THEME = 10,
  GTK_PATH_PRIO_RC = 12,
  GTK_PATH_PRIO_HIGHEST = 15
} GtkPathPriorityType;



typedef enum
{
  GTK_PATH_WIDGET,
  GTK_PATH_WIDGET_CLASS,
  GTK_PATH_CLASS
} GtkPathType;


typedef enum
{
  GTK_POLICY_ALWAYS,
  GTK_POLICY_AUTOMATIC,
  GTK_POLICY_NEVER
} GtkPolicyType;

typedef enum
{
  GTK_POS_LEFT,
  GTK_POS_RIGHT,
  GTK_POS_TOP,
  GTK_POS_BOTTOM
} GtkPositionType;


typedef enum
{
  GTK_PREVIEW_COLOR,
  GTK_PREVIEW_GRAYSCALE
} GtkPreviewType;



typedef enum
{
  GTK_RELIEF_NORMAL,
  GTK_RELIEF_HALF,
  GTK_RELIEF_NONE
} GtkReliefStyle;


typedef enum
{
  GTK_RESIZE_PARENT,
  GTK_RESIZE_QUEUE,
  GTK_RESIZE_IMMEDIATE
} GtkResizeMode;



typedef enum
{
  GTK_RUN_FIRST = G_SIGNAL_RUN_FIRST,
  GTK_RUN_LAST = G_SIGNAL_RUN_LAST,
  GTK_RUN_BOTH = (GTK_RUN_FIRST | GTK_RUN_LAST),
  GTK_RUN_NO_RECURSE = G_SIGNAL_NO_RECURSE,
  GTK_RUN_ACTION = G_SIGNAL_ACTION,
  GTK_RUN_NO_HOOKS = G_SIGNAL_NO_HOOKS
} GtkSignalRunType;



typedef enum
{
  GTK_SCROLL_NONE,
  GTK_SCROLL_JUMP,
  GTK_SCROLL_STEP_BACKWARD,
  GTK_SCROLL_STEP_FORWARD,
  GTK_SCROLL_PAGE_BACKWARD,
  GTK_SCROLL_PAGE_FORWARD,
  GTK_SCROLL_STEP_UP,
  GTK_SCROLL_STEP_DOWN,
  GTK_SCROLL_PAGE_UP,
  GTK_SCROLL_PAGE_DOWN,
  GTK_SCROLL_STEP_LEFT,
  GTK_SCROLL_STEP_RIGHT,
  GTK_SCROLL_PAGE_LEFT,
  GTK_SCROLL_PAGE_RIGHT,
  GTK_SCROLL_START,
  GTK_SCROLL_END
} GtkScrollType;


typedef enum
{
  GTK_SELECTION_NONE,
  GTK_SELECTION_SINGLE,
  GTK_SELECTION_BROWSE,
  GTK_SELECTION_MULTIPLE,
  GTK_SELECTION_EXTENDED = GTK_SELECTION_MULTIPLE
} GtkSelectionMode;


typedef enum
{
  GTK_SHADOW_NONE,
  GTK_SHADOW_IN,
  GTK_SHADOW_OUT,
  GTK_SHADOW_ETCHED_IN,
  GTK_SHADOW_ETCHED_OUT
} GtkShadowType;


typedef enum
{
  GTK_STATE_NORMAL,
  GTK_STATE_ACTIVE,
  GTK_STATE_PRELIGHT,
  GTK_STATE_SELECTED,
  GTK_STATE_INSENSITIVE
} GtkStateType;



typedef enum
{
  GTK_DIRECTION_LEFT,
  GTK_DIRECTION_RIGHT
} GtkSubmenuDirection;


typedef enum
{
  GTK_TOP_BOTTOM,
  GTK_LEFT_RIGHT
} GtkSubmenuPlacement;



typedef enum
{
  GTK_TOOLBAR_ICONS,
  GTK_TOOLBAR_TEXT,
  GTK_TOOLBAR_BOTH,
  GTK_TOOLBAR_BOTH_HORIZ
} GtkToolbarStyle;


typedef enum
{
  GTK_UPDATE_CONTINUOUS,
  GTK_UPDATE_DISCONTINUOUS,
  GTK_UPDATE_DELAYED
} GtkUpdateType;


typedef enum
{
  GTK_VISIBILITY_NONE,
  GTK_VISIBILITY_PARTIAL,
  GTK_VISIBILITY_FULL
} GtkVisibility;


typedef enum
{
  GTK_WIN_POS_NONE,
  GTK_WIN_POS_CENTER,
  GTK_WIN_POS_MOUSE,
  GTK_WIN_POS_CENTER_ALWAYS,
  GTK_WIN_POS_CENTER_ON_PARENT
} GtkWindowPosition;


typedef enum
{
  GTK_WINDOW_TOPLEVEL,
  GTK_WINDOW_POPUP
} GtkWindowType;


typedef enum
{
  GTK_WRAP_NONE,
  GTK_WRAP_CHAR,
  GTK_WRAP_WORD
} GtkWrapMode;


typedef enum
{
  GTK_SORT_ASCENDING,
  GTK_SORT_DESCENDING
} GtkSortType;


typedef enum
{
  GTK_IM_PREEDIT_NOTHING,
  GTK_IM_PREEDIT_CALLBACK
} GtkIMPreeditStyle;

typedef enum
{
  GTK_IM_STATUS_NOTHING,
  GTK_IM_STATUS_CALLBACK
} GtkIMStatusStyle;
# 33 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h" 2 3 4


# 47 "/usr/include/gtk-2.0/gtk/gtkaccelgroup.h" 3 4
typedef enum
{
  GTK_ACCEL_VISIBLE = 1 << 0,
  GTK_ACCEL_LOCKED = 1 << 1,
  GTK_ACCEL_MASK = 0x07
} GtkAccelFlags;



typedef struct _GtkAccelGroup GtkAccelGroup;
typedef struct _GtkAccelGroupClass GtkAccelGroupClass;
typedef struct _GtkAccelKey GtkAccelKey;
typedef struct _GtkAccelGroupEntry GtkAccelGroupEntry;
typedef gboolean (*GtkAccelGroupActivate) (GtkAccelGroup *accel_group,
                                           GObject *acceleratable,
                                           guint keyval,
                                           GdkModifierType modifier);

typedef gboolean (*GtkAccelGroupFindFunc) (GtkAccelKey *key,
                                           GClosure *closure,
                                           gpointer data);

struct _GtkAccelGroup
{
  GObject parent;
  guint lock_count;
  GdkModifierType modifier_mask;
  GSList *acceleratables;
  guint n_accels;
  GtkAccelGroupEntry *priv_accels;
};

struct _GtkAccelGroupClass
{
  GObjectClass parent_class;

  void (*accel_changed) (GtkAccelGroup *accel_group,
                                 guint keyval,
                                 GdkModifierType modifier,
                                 GClosure *accel_closure);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

struct _GtkAccelKey
{
  guint accel_key;
  GdkModifierType accel_mods;
  guint accel_flags : 16;
};



GType gtk_accel_group_get_type (void);
GtkAccelGroup* gtk_accel_group_new (void);
void gtk_accel_group_lock (GtkAccelGroup *accel_group);
void gtk_accel_group_unlock (GtkAccelGroup *accel_group);
void gtk_accel_group_connect (GtkAccelGroup *accel_group,
                                                   guint accel_key,
                                                   GdkModifierType accel_mods,
                                                   GtkAccelFlags accel_flags,
                                                   GClosure *closure);
void gtk_accel_group_connect_by_path (GtkAccelGroup *accel_group,
                                                   const gchar *accel_path,
                                                   GClosure *closure);
gboolean gtk_accel_group_disconnect (GtkAccelGroup *accel_group,
                                                   GClosure *closure);
gboolean gtk_accel_group_disconnect_key (GtkAccelGroup *accel_group,
                                                   guint accel_key,
                                                   GdkModifierType accel_mods);



void _gtk_accel_group_attach (GtkAccelGroup *accel_group,
                                                 GObject *object);
void _gtk_accel_group_detach (GtkAccelGroup *accel_group,
                                                 GObject *object);
gboolean gtk_accel_groups_activate (GObject *object,
                                                 guint accel_key,
                                                 GdkModifierType accel_mods);
GSList* gtk_accel_groups_from_object (GObject *object);
GtkAccelKey* gtk_accel_group_find (GtkAccelGroup *accel_group,
                                                 GtkAccelGroupFindFunc find_func,
                                                 gpointer data);
GtkAccelGroup* gtk_accel_group_from_accel_closure (GClosure *closure);



gboolean gtk_accelerator_valid (guint keyval,
                                               GdkModifierType modifiers) ;
void gtk_accelerator_parse (const gchar *accelerator,
                                               guint *accelerator_key,
                                               GdkModifierType *accelerator_mods);
gchar* gtk_accelerator_name (guint accelerator_key,
                                               GdkModifierType accelerator_mods);
void gtk_accelerator_set_default_mod_mask (GdkModifierType default_mod_mask);
guint gtk_accelerator_get_default_mod_mask (void);



GtkAccelGroupEntry* gtk_accel_group_query (GtkAccelGroup *accel_group,
                                                 guint accel_key,
                                                 GdkModifierType accel_mods,
                                                 guint *n_entries);

void _gtk_accel_group_reconnect (GtkAccelGroup *accel_group,
                                                 GQuark accel_path_quark);

struct _GtkAccelGroupEntry
{
  GtkAccelKey key;
  GClosure *closure;
  GQuark accel_path_quark;
};








# 33 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h" 1 3 4
# 34 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtklabel.h" 1 3 4
# 31 "/usr/include/gtk-2.0/gtk/gtklabel.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkmisc.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkmisc.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkobject.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkobject.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktypeutils.h" 1 3 4
# 34 "/usr/include/gtk-2.0/gtk/gtktypeutils.h" 3 4

# 62 "/usr/include/gtk-2.0/gtk/gtktypeutils.h" 3 4
typedef GType GtkFundamentalType;
# 89 "/usr/include/gtk-2.0/gtk/gtktypeutils.h" 3 4
typedef GType GtkType;



typedef GTypeInstance GtkTypeObject;
typedef GTypeClass GtkTypeClass;
typedef GBaseInitFunc GtkClassInitFunc;
typedef GInstanceInitFunc GtkObjectInitFunc;







# 1 "/usr/include/gtk-2.0/gtk/gtktypebuiltins.h" 1 3 4
# 9 "/usr/include/gtk-2.0/gtk/gtktypebuiltins.h" 3 4




GType gtk_accel_flags_get_type (void);




GType gtk_calendar_display_options_get_type (void);




GType gtk_cell_type_get_type (void);


GType gtk_clist_drag_pos_get_type (void);


GType gtk_button_action_get_type (void);




GType gtk_ctree_pos_get_type (void);


GType gtk_ctree_line_style_get_type (void);


GType gtk_ctree_expander_style_get_type (void);


GType gtk_ctree_expansion_type_get_type (void);




GType gtk_cell_renderer_state_get_type (void);


GType gtk_cell_renderer_mode_get_type (void);




GType gtk_debug_flag_get_type (void);




GType gtk_dialog_flags_get_type (void);


GType gtk_response_type_get_type (void);




GType gtk_dest_defaults_get_type (void);


GType gtk_target_flags_get_type (void);




GType gtk_anchor_type_get_type (void);


GType gtk_arrow_type_get_type (void);


GType gtk_attach_options_get_type (void);


GType gtk_button_box_style_get_type (void);


GType gtk_curve_type_get_type (void);


GType gtk_delete_type_get_type (void);


GType gtk_direction_type_get_type (void);


GType gtk_expander_style_get_type (void);


GType gtk_icon_size_get_type (void);


GType gtk_side_type_get_type (void);


GType gtk_text_direction_get_type (void);


GType gtk_justification_get_type (void);


GType gtk_match_type_get_type (void);


GType gtk_menu_direction_type_get_type (void);


GType gtk_metric_type_get_type (void);


GType gtk_movement_step_get_type (void);


GType gtk_orientation_get_type (void);


GType gtk_corner_type_get_type (void);


GType gtk_pack_type_get_type (void);


GType gtk_path_priority_type_get_type (void);


GType gtk_path_type_get_type (void);


GType gtk_policy_type_get_type (void);


GType gtk_position_type_get_type (void);


GType gtk_preview_type_get_type (void);


GType gtk_relief_style_get_type (void);


GType gtk_resize_mode_get_type (void);


GType gtk_signal_run_type_get_type (void);


GType gtk_scroll_type_get_type (void);


GType gtk_selection_mode_get_type (void);


GType gtk_shadow_type_get_type (void);


GType gtk_state_type_get_type (void);


GType gtk_submenu_direction_get_type (void);


GType gtk_submenu_placement_get_type (void);


GType gtk_toolbar_style_get_type (void);


GType gtk_update_type_get_type (void);


GType gtk_visibility_get_type (void);


GType gtk_window_position_get_type (void);


GType gtk_window_type_get_type (void);


GType gtk_wrap_mode_get_type (void);


GType gtk_sort_type_get_type (void);


GType gtk_im_preedit_style_get_type (void);


GType gtk_im_status_style_get_type (void);




GType gtk_image_type_get_type (void);




GType gtk_message_type_get_type (void);


GType gtk_buttons_type_get_type (void);




GType gtk_notebook_tab_get_type (void);




GType gtk_object_flags_get_type (void);


GType gtk_arg_flags_get_type (void);




GType gtk_private_flags_get_type (void);




GType gtk_progress_bar_style_get_type (void);


GType gtk_progress_bar_orientation_get_type (void);




GType gtk_rc_flags_get_type (void);


GType gtk_rc_token_type_get_type (void);




GType gtk_size_group_mode_get_type (void);




GType gtk_spin_button_update_policy_get_type (void);


GType gtk_spin_type_get_type (void);




GType gtk_text_search_flags_get_type (void);




GType gtk_text_window_type_get_type (void);




GType gtk_toolbar_child_type_get_type (void);


GType gtk_toolbar_space_style_get_type (void);




GType gtk_tree_view_mode_get_type (void);




GType gtk_tree_model_flags_get_type (void);




GType gtk_tree_view_drop_position_get_type (void);




GType gtk_tree_view_column_sizing_get_type (void);




GType gtk_widget_flags_get_type (void);


GType gtk_widget_help_type_get_type (void);



# 105 "/usr/include/gtk-2.0/gtk/gtktypeutils.h" 2 3 4





GType gtk_identifier_get_type (void);





typedef struct _GtkArg GtkArg;
typedef struct _GtkObject GtkObject;
typedef gboolean (*GtkFunction) (gpointer data);
typedef void (*GtkDestroyNotify) (gpointer data);
typedef void (*GtkCallbackMarshal) (GtkObject *object,
                                     gpointer data,
                                     guint n_args,
                                     GtkArg *args);
typedef void (*GtkSignalFunc) (void);



typedef struct _GtkTypeInfo GtkTypeInfo;
typedef GSignalCMarshaller GtkSignalMarshaller;






struct _GtkArg
{
  GtkType type;
  gchar *name;







  union {

    gchar char_data;
    guchar uchar_data;
    gboolean bool_data;
    gint int_data;
    guint uint_data;
    glong long_data;
    gulong ulong_data;
    gfloat float_data;
    gdouble double_data;
    gchar *string_data;
    GtkObject *object_data;
    gpointer pointer_data;


    struct {
      GtkSignalFunc f;
      gpointer d;
    } signal_data;
  } d;
};
# 218 "/usr/include/gtk-2.0/gtk/gtktypeutils.h" 3 4
struct _GtkTypeInfo
{
  gchar *type_name;
  guint object_size;
  guint class_size;
  GtkClassInitFunc class_init_func;
  GtkObjectInitFunc object_init_func;
  gpointer reserved_1;
  gpointer reserved_2;
  GtkClassInitFunc base_class_init_func;
};



gpointer gtk_type_class (GtkType type);



GtkType gtk_type_unique (GtkType parent_type,
                                 const GtkTypeInfo *gtkinfo);
gpointer gtk_type_new (GtkType type);
# 249 "/usr/include/gtk-2.0/gtk/gtktypeutils.h" 3 4
typedef GEnumValue GtkEnumValue;
typedef GFlagsValue GtkFlagValue;
GtkEnumValue* gtk_type_enum_get_values (GtkType enum_type);
GtkFlagValue* gtk_type_flags_get_values (GtkType flags_type);
GtkEnumValue* gtk_type_enum_find_value (GtkType enum_type,
                                                 const gchar *value_name);
GtkFlagValue* gtk_type_flags_find_value (GtkType flags_type,
                                                 const gchar *value_name);





void gtk_type_init (GTypeDebugFlags debug_flags);



# 33 "/usr/include/gtk-2.0/gtk/gtkobject.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkdebug.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkdebug.h" 3 4


typedef enum {
  GTK_DEBUG_MISC = 1 << 0,
  GTK_DEBUG_PLUGSOCKET = 1 << 1,
  GTK_DEBUG_TEXT = 1 << 2,
  GTK_DEBUG_TREE = 1 << 3,
  GTK_DEBUG_UPDATES = 1 << 4,
  GTK_DEBUG_KEYBINDINGS = 1 << 5,
  GTK_DEBUG_MULTIHEAD = 1 << 6
} GtkDebugFlag;
# 66 "/usr/include/gtk-2.0/gtk/gtkdebug.h" 3 4
extern guint gtk_debug_flags;


# 34 "/usr/include/gtk-2.0/gtk/gtkobject.h" 2 3 4


# 58 "/usr/include/gtk-2.0/gtk/gtkobject.h" 3 4
typedef enum
{
  GTK_IN_DESTRUCTION = 1 << 0,
  GTK_FLOATING = 1 << 1,
  GTK_RESERVED_1 = 1 << 2,
  GTK_RESERVED_2 = 1 << 3
} GtkObjectFlags;
# 76 "/usr/include/gtk-2.0/gtk/gtkobject.h" 3 4
typedef struct _GtkObjectClass GtkObjectClass;


struct _GtkObject
{
  GObject parent_instance;






  guint32 flags;
};

struct _GtkObjectClass
{
  GObjectClass parent_class;


  void (*set_arg) (GtkObject *object,
                   GtkArg *arg,
                   guint arg_id);
  void (*get_arg) (GtkObject *object,
                   GtkArg *arg,
                   guint arg_id);
# 111 "/usr/include/gtk-2.0/gtk/gtkobject.h" 3 4
  void (*destroy) (GtkObject *object);
};





GtkType gtk_object_get_type (void) ;

GtkObject* gtk_object_new (GtkType type,
                                           const gchar *first_property_name,
                                           ...);

void gtk_object_sink (GtkObject *object);
void gtk_object_destroy (GtkObject *object);





GtkObject* gtk_object_ref (GtkObject *object);
void gtk_object_unref (GtkObject *object);
void gtk_object_weakref (GtkObject *object,
                           GtkDestroyNotify notify,
                           gpointer data);
void gtk_object_weakunref (GtkObject *object,
                           GtkDestroyNotify notify,
                           gpointer data);
# 152 "/usr/include/gtk-2.0/gtk/gtkobject.h" 3 4
void gtk_object_set_data (GtkObject *object,
                                      const gchar *key,
                                      gpointer data);
void gtk_object_set_data_full (GtkObject *object,
                                      const gchar *key,
                                      gpointer data,
                                      GtkDestroyNotify destroy);
void gtk_object_remove_data (GtkObject *object,
                                      const gchar *key);
gpointer gtk_object_get_data (GtkObject *object,
                                      const gchar *key);
void gtk_object_remove_no_notify (GtkObject *object,
                                      const gchar *key);






void gtk_object_set_user_data (GtkObject *object,
                                   gpointer data);
gpointer gtk_object_get_user_data (GtkObject *object);





void gtk_object_set_data_by_id (GtkObject *object,
                                         GQuark data_id,
                                         gpointer data);
void gtk_object_set_data_by_id_full (GtkObject *object,
                                         GQuark data_id,
                                         gpointer data,
                                         GtkDestroyNotify destroy);
gpointer gtk_object_get_data_by_id (GtkObject *object,
                                         GQuark data_id);
void gtk_object_remove_data_by_id (GtkObject *object,
                                         GQuark data_id);
void gtk_object_remove_no_notify_by_id (GtkObject *object,
                                         GQuark key_id);





typedef enum
{
  GTK_ARG_READABLE = G_PARAM_READABLE,
  GTK_ARG_WRITABLE = G_PARAM_WRITABLE,
  GTK_ARG_CONSTRUCT = G_PARAM_CONSTRUCT,
  GTK_ARG_CONSTRUCT_ONLY = G_PARAM_CONSTRUCT_ONLY,
  GTK_ARG_CHILD_ARG = 1 << 4
} GtkArgFlags;

void gtk_object_get (GtkObject *object,
                                 const gchar *first_property_name,
                                 ...);
void gtk_object_set (GtkObject *object,
                                 const gchar *first_property_name,
                                 ...);
void gtk_object_add_arg_type (const gchar *arg_name,
                                         GtkType arg_type,
                                         guint arg_flags,
                                         guint arg_id);




# 33 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkadjustment.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkadjustment.h" 3 4
typedef struct _GtkAdjustment GtkAdjustment;
typedef struct _GtkAdjustmentClass GtkAdjustmentClass;

struct _GtkAdjustment
{
  GtkObject parent_instance;

  gdouble lower;
  gdouble upper;
  gdouble value;
  gdouble step_increment;
  gdouble page_increment;
  gdouble page_size;
};

struct _GtkAdjustmentClass
{
  GtkObjectClass parent_class;

  void (* changed) (GtkAdjustment *adjustment);
  void (* value_changed) (GtkAdjustment *adjustment);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_adjustment_get_type (void) ;
GtkObject* gtk_adjustment_new (gdouble value,
                                                 gdouble lower,
                                                 gdouble upper,
                                                 gdouble step_increment,
                                                 gdouble page_increment,
                                                 gdouble page_size);
void gtk_adjustment_changed (GtkAdjustment *adjustment);
void gtk_adjustment_value_changed (GtkAdjustment *adjustment);
void gtk_adjustment_clamp_page (GtkAdjustment *adjustment,
                                                 gdouble lower,
                                                 gdouble upper);
gdouble gtk_adjustment_get_value (GtkAdjustment *adjustment);
void gtk_adjustment_set_value (GtkAdjustment *adjustment,
                                                 gdouble value);
# 34 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkstyle.h" 1 3 4
# 51 "/usr/include/gtk-2.0/gtk/gtkstyle.h" 3 4
typedef struct _GtkBorder GtkBorder;
typedef struct _GtkStyle GtkStyle;
typedef struct _GtkStyleClass GtkStyleClass;
typedef struct _GtkThemeEngine GtkThemeEngine;
typedef struct _GtkRcStyle GtkRcStyle;
typedef struct _GtkIconSet GtkIconSet;
typedef struct _GtkIconSource GtkIconSource;
typedef struct _GtkRcProperty GtkRcProperty;
typedef struct _GtkSettings GtkSettings;
typedef gboolean (*GtkRcPropertyParser) (const GParamSpec *pspec,
                                         const GString *rc_string,
                                         GValue *property_value);




typedef struct _GtkWidget GtkWidget;



struct _GtkStyle
{
  GObject parent_instance;



  GdkColor fg[5];
  GdkColor bg[5];
  GdkColor light[5];
  GdkColor dark[5];
  GdkColor mid[5];
  GdkColor text[5];
  GdkColor base[5];
  GdkColor text_aa[5];

  GdkColor black;
  GdkColor white;
  PangoFontDescription *font_desc;

  gint xthickness;
  gint ythickness;

  GdkGC *fg_gc[5];
  GdkGC *bg_gc[5];
  GdkGC *light_gc[5];
  GdkGC *dark_gc[5];
  GdkGC *mid_gc[5];
  GdkGC *text_gc[5];
  GdkGC *base_gc[5];
  GdkGC *text_aa_gc[5];
  GdkGC *black_gc;
  GdkGC *white_gc;

  GdkPixmap *bg_pixmap[5];



  gint attach_count;

  gint depth;
  GdkColormap *colormap;
  GdkFont *private_font;
  PangoFontDescription *private_font_desc;


  GtkRcStyle *rc_style;

  GSList *styles;
  GArray *property_cache;
  GSList *icon_factories;
};

struct _GtkStyleClass
{
  GObjectClass parent_class;





  void (*realize) (GtkStyle *style);




  void (*unrealize) (GtkStyle *style);



  void (*copy) (GtkStyle *style,
                                 GtkStyle *src);






  GtkStyle *(*clone) (GtkStyle *style);




  void (*init_from_rc) (GtkStyle *style,
                                 GtkRcStyle *rc_style);

  void (*set_background) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type);


  GdkPixbuf * (* render_icon) (GtkStyle *style,
                                 const GtkIconSource *source,
                                 GtkTextDirection direction,
                                 GtkStateType state,
                                 GtkIconSize size,
                                 GtkWidget *widget,
                                 const gchar *detail);




  void (*draw_hline) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x1,
                                 gint x2,
                                 gint y);
  void (*draw_vline) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint y1_,
                                 gint y2_,
                                 gint x);
  void (*draw_shadow) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);
  void (*draw_polygon) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 GdkPoint *point,
                                 gint npoints,
                                 gboolean fill);
  void (*draw_arrow) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 GtkArrowType arrow_type,
                                 gboolean fill,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);
  void (*draw_diamond) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);
  void (*draw_string) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 const gchar *string);
  void (*draw_box) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);
  void (*draw_flat_box) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);
  void (*draw_check) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);
  void (*draw_option) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);
  void (*draw_tab) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);
  void (*draw_shadow_gap) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height,
                                 GtkPositionType gap_side,
                                 gint gap_x,
                                 gint gap_width);
  void (*draw_box_gap) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height,
                                 GtkPositionType gap_side,
                                 gint gap_x,
                                 gint gap_width);
  void (*draw_extension) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height,
                                 GtkPositionType gap_side);
  void (*draw_focus) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);
  void (*draw_slider) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height,
                                 GtkOrientation orientation);
  void (*draw_handle) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GtkShadowType shadow_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height,
                                 GtkOrientation orientation);

  void (*draw_expander) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 GtkExpanderStyle expander_style);
  void (*draw_layout) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 gboolean use_text,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 gint x,
                                 gint y,
                                 PangoLayout *layout);
  void (*draw_resize_grip) (GtkStyle *style,
                                 GdkWindow *window,
                                 GtkStateType state_type,
                                 GdkRectangle *area,
                                 GtkWidget *widget,
                                 const gchar *detail,
                                 GdkWindowEdge edge,
                                 gint x,
                                 gint y,
                                 gint width,
                                 gint height);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
  void (*_gtk_reserved5) (void);
  void (*_gtk_reserved6) (void);
  void (*_gtk_reserved7) (void);
  void (*_gtk_reserved8) (void);
  void (*_gtk_reserved9) (void);
  void (*_gtk_reserved10) (void);
  void (*_gtk_reserved11) (void);
  void (*_gtk_reserved12) (void);
};

struct _GtkBorder
{
  gint left;
  gint right;
  gint top;
  gint bottom;
};

GType gtk_style_get_type (void) ;
GtkStyle* gtk_style_new (void);
GtkStyle* gtk_style_copy (GtkStyle *style);
GtkStyle* gtk_style_attach (GtkStyle *style,
                                              GdkWindow *window);
void gtk_style_detach (GtkStyle *style);


GtkStyle* gtk_style_ref (GtkStyle *style);
void gtk_style_unref (GtkStyle *style);

GdkFont * gtk_style_get_font (GtkStyle *style);
void gtk_style_set_font (GtkStyle *style,
                                              GdkFont *font);


void gtk_style_set_background (GtkStyle *style,
                                              GdkWindow *window,
                                              GtkStateType state_type);
void gtk_style_apply_default_background (GtkStyle *style,
                                              GdkWindow *window,
                                              gboolean set_bg,
                                              GtkStateType state_type,
                                              GdkRectangle *area,
                                              gint x,
                                              gint y,
                                              gint width,
                                              gint height);

GtkIconSet* gtk_style_lookup_icon_set (GtkStyle *style,
                                       const gchar *stock_id);
GdkPixbuf* gtk_style_render_icon (GtkStyle *style,
                                       const GtkIconSource *source,
                                       GtkTextDirection direction,
                                       GtkStateType state,
                                       GtkIconSize size,
                                       GtkWidget *widget,
                                       const gchar *detail);

void gtk_draw_hline (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          gint x1,
                          gint x2,
                          gint y);
void gtk_draw_vline (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          gint y1_,
                          gint y2_,
                          gint x);
void gtk_draw_shadow (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
void gtk_draw_polygon (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          GdkPoint *points,
                          gint npoints,
                          gboolean fill);
void gtk_draw_arrow (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          GtkArrowType arrow_type,
                          gboolean fill,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
void gtk_draw_diamond (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
void gtk_draw_box (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
void gtk_draw_flat_box (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
void gtk_draw_check (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
void gtk_draw_option (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
void gtk_draw_tab (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
void gtk_draw_shadow_gap (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height,
                          GtkPositionType gap_side,
                          gint gap_x,
                          gint gap_width);
void gtk_draw_box_gap (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height,
                          GtkPositionType gap_side,
                          gint gap_x,
                          gint gap_width);
void gtk_draw_extension (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height,
                          GtkPositionType gap_side);
void gtk_draw_focus (GtkStyle *style,
                          GdkWindow *window,
                          gint x,
                          gint y,
                          gint width,
                          gint height);
void gtk_draw_slider (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height,
                          GtkOrientation orientation);
void gtk_draw_handle (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          GtkShadowType shadow_type,
                          gint x,
                          gint y,
                          gint width,
                          gint height,
                          GtkOrientation orientation);
void gtk_draw_expander (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          gint x,
                          gint y,
                          GtkExpanderStyle expander_style);
void gtk_draw_layout (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          gboolean use_text,
                          gint x,
                          gint y,
                          PangoLayout *layout);
void gtk_draw_resize_grip (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GdkWindowEdge edge,
                           gint x,
                           gint y,
                           gint width,
                           gint height);


void gtk_paint_hline (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x1,
                           gint x2,
                           gint y);
void gtk_paint_vline (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint y1_,
                           gint y2_,
                           gint x);
void gtk_paint_shadow (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_polygon (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           GdkPoint *points,
                           gint npoints,
                           gboolean fill);
void gtk_paint_arrow (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           GtkArrowType arrow_type,
                           gboolean fill,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_diamond (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_box (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_flat_box (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_check (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_option (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_tab (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_shadow_gap (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height,
                           GtkPositionType gap_side,
                           gint gap_x,
                           gint gap_width);
void gtk_paint_box_gap (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height,
                           GtkPositionType gap_side,
                           gint gap_x,
                           gint gap_width);
void gtk_paint_extension (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height,
                           GtkPositionType gap_side);
void gtk_paint_focus (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height);
void gtk_paint_slider (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height,
                           GtkOrientation orientation);
void gtk_paint_handle (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GtkShadowType shadow_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           gint width,
                           gint height,
                           GtkOrientation orientation);
void gtk_paint_expander (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           GtkExpanderStyle expander_style);
void gtk_paint_layout (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           gboolean use_text,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           PangoLayout *layout);

void gtk_paint_resize_grip (GtkStyle *style,
                            GdkWindow *window,
                            GtkStateType state_type,
                            GdkRectangle *area,
                            GtkWidget *widget,
                            const gchar *detail,
                            GdkWindowEdge edge,
                            gint x,
                            gint y,
                            gint width,
                            gint height);


GType gtk_border_get_type (void);
GtkBorder *gtk_border_copy (const GtkBorder *border_);
void gtk_border_free ( GtkBorder *border_);


const GValue* _gtk_style_peek_property_value (GtkStyle *style,
                                              GType widget_type,
                                              GParamSpec *pspec,
                                              GtkRcPropertyParser parser);

void _gtk_style_init_for_settings (GtkStyle *style,
                                   GtkSettings *settings);




void gtk_draw_string (GtkStyle *style,
                          GdkWindow *window,
                          GtkStateType state_type,
                          gint x,
                          gint y,
                          const gchar *string);
void gtk_paint_string (GtkStyle *style,
                           GdkWindow *window,
                           GtkStateType state_type,
                           GdkRectangle *area,
                           GtkWidget *widget,
                           const gchar *detail,
                           gint x,
                           gint y,
                           const gchar *string);


GdkGC *_gtk_get_insertion_cursor_gc (GtkWidget *widget,
                                     gboolean is_primary);
void _gtk_draw_insertion_cursor (GtkWidget *widget,
                                     GdkDrawable *drawable,
                                     GdkGC *gc,
                                     GdkRectangle *location,
                                     GtkTextDirection direction,
                                     gboolean draw_arrow);
# 35 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtksettings.h" 1 3 4
# 21 "/usr/include/gtk-2.0/gtk/gtksettings.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkrc.h" 1 3 4
# 38 "/usr/include/gtk-2.0/gtk/gtkrc.h" 3 4
typedef struct _GtkIconFactory GtkIconFactory;
typedef struct _GtkRcContext GtkRcContext;

typedef struct _GtkRcStyleClass GtkRcStyleClass;
# 50 "/usr/include/gtk-2.0/gtk/gtkrc.h" 3 4
typedef enum
{
  GTK_RC_FG = 1 << 0,
  GTK_RC_BG = 1 << 1,
  GTK_RC_TEXT = 1 << 2,
  GTK_RC_BASE = 1 << 3
} GtkRcFlags;

struct _GtkRcStyle
{
  GObject parent_instance;



  gchar *name;
  gchar *bg_pixmap_name[5];
  PangoFontDescription *font_desc;

  GtkRcFlags color_flags[5];
  GdkColor fg[5];
  GdkColor bg[5];
  GdkColor text[5];
  GdkColor base[5];

  gint xthickness;
  gint ythickness;


  GArray *rc_properties;


  GSList *rc_style_lists;

  GSList *icon_factories;

  guint engine_specified : 1;
};

struct _GtkRcStyleClass
{
  GObjectClass parent_class;






  GtkRcStyle * (*create_rc_style) (GtkRcStyle *rc_style);





  guint (*parse) (GtkRcStyle *rc_style,
                       GtkSettings *settings,
                       GScanner *scanner);




  void (*merge) (GtkRcStyle *dest,
                       GtkRcStyle *src);



  GtkStyle * (*create_style) (GtkRcStyle *rc_style);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

void _gtk_rc_init (void);
void gtk_rc_add_default_file (const gchar *filename);
void gtk_rc_set_default_files (gchar **filenames);
gchar** gtk_rc_get_default_files (void);
GtkStyle* gtk_rc_get_style (GtkWidget *widget);
GtkStyle* gtk_rc_get_style_by_paths (GtkSettings *settings,
                                         const char *widget_path,
                                         const char *class_path,
                                         GType type);

gboolean gtk_rc_reparse_all_for_settings (GtkSettings *settings,
                                          gboolean force_load);
gchar* gtk_rc_find_pixmap_in_path (GtkSettings *settings,
                                     GScanner *scanner,
                                     const gchar *pixmap_file);

void gtk_rc_parse (const gchar *filename);
void gtk_rc_parse_string (const gchar *rc_string);
gboolean gtk_rc_reparse_all (void);


void gtk_rc_add_widget_name_style (GtkRcStyle *rc_style,
                                         const gchar *pattern);
void gtk_rc_add_widget_class_style (GtkRcStyle *rc_style,
                                         const gchar *pattern);
void gtk_rc_add_class_style (GtkRcStyle *rc_style,
                                         const gchar *pattern);



GType gtk_rc_style_get_type (void) ;
GtkRcStyle* gtk_rc_style_new (void);
GtkRcStyle* gtk_rc_style_copy (GtkRcStyle *orig);
void gtk_rc_style_ref (GtkRcStyle *rc_style);
void gtk_rc_style_unref (GtkRcStyle *rc_style);

gchar* gtk_rc_find_module_in_path (const gchar *module_file);
gchar* gtk_rc_get_theme_dir (void);
gchar* gtk_rc_get_module_dir (void);
gchar* gtk_rc_get_im_module_path (void);
gchar* gtk_rc_get_im_module_file (void);


typedef enum {
  GTK_RC_TOKEN_INVALID = G_TOKEN_LAST,
  GTK_RC_TOKEN_INCLUDE,
  GTK_RC_TOKEN_NORMAL,
  GTK_RC_TOKEN_ACTIVE,
  GTK_RC_TOKEN_PRELIGHT,
  GTK_RC_TOKEN_SELECTED,
  GTK_RC_TOKEN_INSENSITIVE,
  GTK_RC_TOKEN_FG,
  GTK_RC_TOKEN_BG,
  GTK_RC_TOKEN_TEXT,
  GTK_RC_TOKEN_BASE,
  GTK_RC_TOKEN_XTHICKNESS,
  GTK_RC_TOKEN_YTHICKNESS,
  GTK_RC_TOKEN_FONT,
  GTK_RC_TOKEN_FONTSET,
  GTK_RC_TOKEN_FONT_NAME,
  GTK_RC_TOKEN_BG_PIXMAP,
  GTK_RC_TOKEN_PIXMAP_PATH,
  GTK_RC_TOKEN_STYLE,
  GTK_RC_TOKEN_BINDING,
  GTK_RC_TOKEN_BIND,
  GTK_RC_TOKEN_WIDGET,
  GTK_RC_TOKEN_WIDGET_CLASS,
  GTK_RC_TOKEN_CLASS,
  GTK_RC_TOKEN_LOWEST,
  GTK_RC_TOKEN_GTK,
  GTK_RC_TOKEN_APPLICATION,
  GTK_RC_TOKEN_THEME,
  GTK_RC_TOKEN_RC,
  GTK_RC_TOKEN_HIGHEST,
  GTK_RC_TOKEN_ENGINE,
  GTK_RC_TOKEN_MODULE_PATH,
  GTK_RC_TOKEN_IM_MODULE_PATH,
  GTK_RC_TOKEN_IM_MODULE_FILE,
  GTK_RC_TOKEN_STOCK,
  GTK_RC_TOKEN_LTR,
  GTK_RC_TOKEN_RTL,
  GTK_RC_TOKEN_LAST
} GtkRcTokenType;

GScanner* gtk_rc_scanner_new (void);
guint gtk_rc_parse_color (GScanner *scanner,
                                 GdkColor *color);
guint gtk_rc_parse_state (GScanner *scanner,
                                 GtkStateType *state);
guint gtk_rc_parse_priority (GScanner *scanner,
                                 GtkPathPriorityType *priority);





struct _GtkRcProperty
{

  GQuark type_name;
  GQuark property_name;


  gchar *origin;
  GValue value;
};
const GtkRcProperty* _gtk_rc_style_lookup_rc_property (GtkRcStyle *rc_style,
                                                       GQuark type_name,
                                                       GQuark property_name);

const gchar* _gtk_rc_context_get_default_font_name (GtkSettings *settings);
void _gtk_rc_reset_styles (GtkSettings *settings);
# 22 "/usr/include/gtk-2.0/gtk/gtksettings.h" 2 3 4


# 36 "/usr/include/gtk-2.0/gtk/gtksettings.h" 3 4
typedef struct _GtkSettingsClass GtkSettingsClass;
typedef struct _GtkSettingsValue GtkSettingsValue;
typedef struct _GtkSettingsPropertyValue GtkSettingsPropertyValue;



struct _GtkSettings
{
  GObject parent_instance;

  GData *queued_settings;
  GtkSettingsPropertyValue *property_values;

  GtkRcContext *rc_context;
  GdkScreen *screen;
};
struct _GtkSettingsClass
{
  GObjectClass parent_class;

};
struct _GtkSettingsValue
{



  gchar *origin;




  GValue value;
};



GType gtk_settings_get_type (void);

GtkSettings* gtk_settings_get_default (void);

GtkSettings* gtk_settings_get_for_screen (GdkScreen *screen);

void gtk_settings_install_property (GParamSpec *pspec);
void gtk_settings_install_property_parser (GParamSpec *pspec,
                                                      GtkRcPropertyParser parser);


gboolean gtk_rc_property_parse_color (const GParamSpec *pspec,
                                            const GString *gstring,
                                            GValue *property_value);
gboolean gtk_rc_property_parse_enum (const GParamSpec *pspec,
                                            const GString *gstring,
                                            GValue *property_value);
gboolean gtk_rc_property_parse_flags (const GParamSpec *pspec,
                                            const GString *gstring,
                                            GValue *property_value);
gboolean gtk_rc_property_parse_requisition (const GParamSpec *pspec,
                                            const GString *gstring,
                                            GValue *property_value);
gboolean gtk_rc_property_parse_border (const GParamSpec *pspec,
                                            const GString *gstring,
                                            GValue *property_value);


void gtk_settings_set_property_value (GtkSettings *settings,
                                                  const gchar *name,
                                                  const GtkSettingsValue *svalue);
void gtk_settings_set_string_property (GtkSettings *settings,
                                                  const gchar *name,
                                                  const gchar *v_string,
                                                  const gchar *origin);
void gtk_settings_set_long_property (GtkSettings *settings,
                                                  const gchar *name,
                                                  glong v_long,
                                                  const gchar *origin);
void gtk_settings_set_double_property (GtkSettings *settings,
                                                  const gchar *name,
                                                  gdouble v_double,
                                                  const gchar *origin);



void _gtk_settings_set_property_value_from_rc (GtkSettings *settings,
                                               const gchar *name,
                                               const GtkSettingsValue *svalue);
void _gtk_settings_reset_rc_values (GtkSettings *settings);

void _gtk_settings_handle_event (GdkEventSetting *event);
GtkRcPropertyParser _gtk_rc_property_parser_from_type (GType type);
gboolean _gtk_settings_parse_convert (GtkRcPropertyParser parser,
                                                       const GValue *src_value,
                                                       GParamSpec *pspec,
                                                       GValue *dest_value);



# 36 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkobject.h" 1 3 4
# 28 "/usr/include/atk-1.0/atk/atkobject.h" 3 4
# 1 "/usr/include/atk-1.0/atk/atkstate.h" 1 3 4
# 67 "/usr/include/atk-1.0/atk/atkstate.h" 3 4
typedef enum
{
  ATK_STATE_INVALID,
  ATK_STATE_ACTIVE,
  ATK_STATE_ARMED,
  ATK_STATE_BUSY,
  ATK_STATE_CHECKED,
  ATK_STATE_DEFUNCT,
  ATK_STATE_EDITABLE,
  ATK_STATE_ENABLED,
  ATK_STATE_EXPANDABLE,
  ATK_STATE_EXPANDED,
  ATK_STATE_FOCUSABLE,
  ATK_STATE_FOCUSED,
  ATK_STATE_HORIZONTAL,
  ATK_STATE_ICONIFIED,
  ATK_STATE_MODAL,
  ATK_STATE_MULTI_LINE,
  ATK_STATE_MULTISELECTABLE,
  ATK_STATE_OPAQUE,
  ATK_STATE_PRESSED,
  ATK_STATE_RESIZABLE,
  ATK_STATE_SELECTABLE,
  ATK_STATE_SELECTED,
  ATK_STATE_SENSITIVE,
  ATK_STATE_SHOWING,
  ATK_STATE_SINGLE_LINE,
  ATK_STATE_STALE,
  ATK_STATE_TRANSIENT,
  ATK_STATE_VERTICAL,
  ATK_STATE_VISIBLE,
  ATK_STATE_MANAGES_DESCENDANTS,
  ATK_STATE_LAST_DEFINED
} AtkStateType;

typedef guint64 AtkState;

AtkStateType atk_state_type_register (const gchar *name);

const gchar* atk_state_type_get_name (AtkStateType type);
AtkStateType atk_state_type_for_name (const gchar *name);
# 29 "/usr/include/atk-1.0/atk/atkobject.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkrelationtype.h" 1 3 4
# 50 "/usr/include/atk-1.0/atk/atkrelationtype.h" 3 4
typedef enum
{
  ATK_RELATION_NULL = 0,
  ATK_RELATION_CONTROLLED_BY,
  ATK_RELATION_CONTROLLER_FOR,
  ATK_RELATION_LABEL_FOR,
  ATK_RELATION_LABELLED_BY,
  ATK_RELATION_MEMBER_OF,
  ATK_RELATION_NODE_CHILD_OF,
  ATK_RELATION_FLOWS_TO,
  ATK_RELATION_FLOWS_FROM,
  ATK_RELATION_SUBWINDOW_OF,
  ATK_RELATION_EMBEDS,
  ATK_RELATION_EMBEDDED_BY,
  ATK_RELATION_LAST_DEFINED
} AtkRelationType;
# 30 "/usr/include/atk-1.0/atk/atkobject.h" 2 3 4
# 121 "/usr/include/atk-1.0/atk/atkobject.h" 3 4
typedef enum
{
  ATK_ROLE_INVALID = 0,
  ATK_ROLE_ACCEL_LABEL,
  ATK_ROLE_ALERT,
  ATK_ROLE_ANIMATION,
  ATK_ROLE_ARROW,
  ATK_ROLE_CALENDAR,
  ATK_ROLE_CANVAS,
  ATK_ROLE_CHECK_BOX,
  ATK_ROLE_CHECK_MENU_ITEM,
  ATK_ROLE_COLOR_CHOOSER,
  ATK_ROLE_COLUMN_HEADER,
  ATK_ROLE_COMBO_BOX,
  ATK_ROLE_DATE_EDITOR,
  ATK_ROLE_DESKTOP_ICON,
  ATK_ROLE_DESKTOP_FRAME,
  ATK_ROLE_DIAL,
  ATK_ROLE_DIALOG,
  ATK_ROLE_DIRECTORY_PANE,
  ATK_ROLE_DRAWING_AREA,
  ATK_ROLE_FILE_CHOOSER,
  ATK_ROLE_FILLER,
  ATK_ROLE_FONT_CHOOSER,
  ATK_ROLE_FRAME,
  ATK_ROLE_GLASS_PANE,
  ATK_ROLE_HTML_CONTAINER,
  ATK_ROLE_ICON,
  ATK_ROLE_IMAGE,
  ATK_ROLE_INTERNAL_FRAME,
  ATK_ROLE_LABEL,
  ATK_ROLE_LAYERED_PANE,
  ATK_ROLE_LIST,
  ATK_ROLE_LIST_ITEM,
  ATK_ROLE_MENU,
  ATK_ROLE_MENU_BAR,
  ATK_ROLE_MENU_ITEM,
  ATK_ROLE_OPTION_PANE,
  ATK_ROLE_PAGE_TAB,
  ATK_ROLE_PAGE_TAB_LIST,
  ATK_ROLE_PANEL,
  ATK_ROLE_PASSWORD_TEXT,
  ATK_ROLE_POPUP_MENU,
  ATK_ROLE_PROGRESS_BAR,
  ATK_ROLE_PUSH_BUTTON,
  ATK_ROLE_RADIO_BUTTON,
  ATK_ROLE_RADIO_MENU_ITEM,
  ATK_ROLE_ROOT_PANE,
  ATK_ROLE_ROW_HEADER,
  ATK_ROLE_SCROLL_BAR,
  ATK_ROLE_SCROLL_PANE,
  ATK_ROLE_SEPARATOR,
  ATK_ROLE_SLIDER,
  ATK_ROLE_SPLIT_PANE,
  ATK_ROLE_SPIN_BUTTON,
  ATK_ROLE_STATUSBAR,
  ATK_ROLE_TABLE,
  ATK_ROLE_TABLE_CELL,
  ATK_ROLE_TABLE_COLUMN_HEADER,
  ATK_ROLE_TABLE_ROW_HEADER,
  ATK_ROLE_TEAR_OFF_MENU_ITEM,
  ATK_ROLE_TERMINAL,
  ATK_ROLE_TEXT,
  ATK_ROLE_TOGGLE_BUTTON,
  ATK_ROLE_TOOL_BAR,
  ATK_ROLE_TOOL_TIP,
  ATK_ROLE_TREE,
  ATK_ROLE_TREE_TABLE,
  ATK_ROLE_UNKNOWN,
  ATK_ROLE_VIEWPORT,
  ATK_ROLE_WINDOW,
  ATK_ROLE_HEADER,
  ATK_ROLE_FOOTER,
  ATK_ROLE_PARAGRAPH,
  ATK_ROLE_RULER,
  ATK_ROLE_APPLICATION,
  ATK_ROLE_LAST_DEFINED
} AtkRole;

AtkRole atk_role_register (const gchar *name);
# 215 "/usr/include/atk-1.0/atk/atkobject.h" 3 4
typedef enum
{
  ATK_LAYER_INVALID,
  ATK_LAYER_BACKGROUND,
  ATK_LAYER_CANVAS,
  ATK_LAYER_WIDGET,
  ATK_LAYER_MDI,
  ATK_LAYER_POPUP,
  ATK_LAYER_OVERLAY,
  ATK_LAYER_WINDOW
} AtkLayer;
# 240 "/usr/include/atk-1.0/atk/atkobject.h" 3 4
typedef struct _AtkImplementor AtkImplementor;
typedef struct _AtkImplementorIface AtkImplementorIface;


typedef struct _AtkObject AtkObject;
typedef struct _AtkObjectClass AtkObjectClass;
typedef struct _AtkRelationSet AtkRelationSet;
typedef struct _AtkStateSet AtkStateSet;

struct _AtkPropertyValues
{
  const gchar *property_name;
  GValue old_value;
  GValue new_value;
};

typedef struct _AtkPropertyValues AtkPropertyValues;

typedef gboolean (*AtkFunction) (gpointer data);
# 271 "/usr/include/atk-1.0/atk/atkobject.h" 3 4
typedef void (*AtkPropertyChangeHandler) (AtkObject*, AtkPropertyValues*);


struct _AtkObject
{
  GObject parent;

  gchar *description;
  gchar *name;
  AtkObject *accessible_parent;
  AtkRole role;
  AtkRelationSet *relation_set;
  AtkLayer layer;
};

struct _AtkObjectClass
{
  GObjectClass parent;




  const gchar* (* get_name) (AtkObject *accessible);



  const gchar* (* get_description) (AtkObject *accessible);



  AtkObject* (*get_parent) (AtkObject *accessible);




  gint (* get_n_children) (AtkObject *accessible);





  AtkObject* (* ref_child) (AtkObject *accessible,
                                                    gint i);




  gint (* get_index_in_parent) (AtkObject *accessible);



  AtkRelationSet* (* ref_relation_set) (AtkObject *accessible);



  AtkRole (* get_role) (AtkObject *accessible);
  AtkLayer (* get_layer) (AtkObject *accessible);
  gint (* get_mdi_zorder) (AtkObject *accessible);



  AtkStateSet* (* ref_state_set) (AtkObject *accessible);



  void (* set_name) (AtkObject *accessible,
                                                   const gchar *name);



  void (* set_description) (AtkObject *accessible,
                                                   const gchar *description);



  void (* set_parent) (AtkObject *accessible,
                                                   AtkObject *parent);



  void (* set_role) (AtkObject *accessible,
                                                   AtkRole role);



guint (* connect_property_change_handler) (AtkObject
                 *accessible,
                                                                  AtkPropertyChangeHandler *handler);




void (* remove_property_change_handler) (AtkObject
                *accessible,
                                                                  guint
                handler_id);
void (* initialize) (AtkObject *accessible,
                                                                  gpointer data);




  void (* children_changed) (AtkObject *accessible,
                                                   guint change_index,
                                                   gpointer changed_child);




  void (* focus_event) (AtkObject *accessible,
                                                   gboolean focus_in);




  void (* property_change) (AtkObject *accessible,
                                                   AtkPropertyValues *values);




  void (* state_change) (AtkObject *accessible,
                                                   const gchar *name,
                                                   gboolean state_set);




  void (*visible_data_changed) (AtkObject *accessible);







  void (*active_descendant_changed) (AtkObject *accessible,
                                                        gpointer *child);

  AtkFunction pad1;
  AtkFunction pad2;
  AtkFunction pad3;

};

GType atk_object_get_type (void);

struct _AtkImplementorIface
{
  GTypeInterface parent;

  AtkObject* (*ref_accessible) (AtkImplementor *implementor);
};
GType atk_implementor_get_type (void);
# 438 "/usr/include/atk-1.0/atk/atkobject.h" 3 4
AtkObject* atk_implementor_ref_accessible (AtkImplementor *implementor);





const gchar* atk_object_get_name (AtkObject *accessible);
const gchar* atk_object_get_description (AtkObject *accessible);
AtkObject* atk_object_get_parent (AtkObject *accessible);
gint atk_object_get_n_accessible_children (AtkObject *accessible);
AtkObject* atk_object_ref_accessible_child (AtkObject *accessible,
                                                                   gint i);
AtkRelationSet* atk_object_ref_relation_set (AtkObject *accessible);
AtkRole atk_object_get_role (AtkObject *accessible);
AtkLayer atk_object_get_layer (AtkObject *accessible);
gint atk_object_get_mdi_zorder (AtkObject *accessible);
AtkStateSet* atk_object_ref_state_set (AtkObject *accessible);
gint atk_object_get_index_in_parent (AtkObject *accessible);
void atk_object_set_name (AtkObject *accessible,
                                                                   const gchar *name);
void atk_object_set_description (AtkObject *accessible,
                                                                   const gchar *description);
void atk_object_set_parent (AtkObject *accessible,
                                                                   AtkObject *parent);
void atk_object_set_role (AtkObject *accessible,
                                                                   AtkRole role);


guint atk_object_connect_property_change_handler (AtkObject *accessible,
                                                                  AtkPropertyChangeHandler *handler);
void atk_object_remove_property_change_handler (AtkObject *accessible,
                                                                  guint handler_id);

void atk_object_notify_state_change (AtkObject *accessible,
                                                                  AtkState state,
                                                                  gboolean value);
void atk_object_initialize (AtkObject *accessible,
                                                                  gpointer data);

const gchar* atk_role_get_name (AtkRole role);
AtkRole atk_role_for_name (const gchar *name);



gboolean atk_object_add_relationship (AtkObject *object,
                                                                AtkRelationType relationship,
                                                                AtkObject *target);
gboolean atk_object_remove_relationship (AtkObject *object,
                                                                AtkRelationType relationship,
                                                                AtkObject *target);
const gchar* atk_role_get_localized_name (AtkRole role);
# 37 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 2 3 4
# 46 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 3 4
typedef enum
{
  GTK_TOPLEVEL = 1 << 4,
  GTK_NO_WINDOW = 1 << 5,
  GTK_REALIZED = 1 << 6,
  GTK_MAPPED = 1 << 7,
  GTK_VISIBLE = 1 << 8,
  GTK_SENSITIVE = 1 << 9,
  GTK_PARENT_SENSITIVE = 1 << 10,
  GTK_CAN_FOCUS = 1 << 11,
  GTK_HAS_FOCUS = 1 << 12,




  GTK_CAN_DEFAULT = 1 << 13,




  GTK_HAS_DEFAULT = 1 << 14,

  GTK_HAS_GRAB = 1 << 15,
  GTK_RC_STYLE = 1 << 16,
  GTK_COMPOSITE_CHILD = 1 << 17,
  GTK_NO_REPARENT = 1 << 18,
  GTK_APP_PAINTABLE = 1 << 19,




  GTK_RECEIVES_DEFAULT = 1 << 20,

  GTK_DOUBLE_BUFFERED = 1 << 21
} GtkWidgetFlags;


typedef enum
{
  GTK_WIDGET_HELP_TOOLTIP,
  GTK_WIDGET_HELP_WHATS_THIS
} GtkWidgetHelpType;
# 138 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 3 4
typedef struct _GtkRequisition GtkRequisition;
typedef GdkRectangle GtkAllocation;
typedef struct _GtkSelectionData GtkSelectionData;
typedef struct _GtkWidgetClass GtkWidgetClass;
typedef struct _GtkWidgetAuxInfo GtkWidgetAuxInfo;
typedef struct _GtkWidgetShapeInfo GtkWidgetShapeInfo;
typedef struct _GtkClipboard GtkClipboard;
typedef void (*GtkCallback) (GtkWidget *widget,
                                        gpointer data);




struct _GtkRequisition
{
  gint width;
  gint height;
};






struct _GtkWidget
{






  GtkObject object;






  guint16 private_flags;




  guint8 state;







  guint8 saved_state;







  gchar *name;
# 207 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 3 4
  GtkStyle *style;



  GtkRequisition requisition;



  GtkAllocation allocation;





  GdkWindow *window;



  GtkWidget *parent;
};

struct _GtkWidgetClass
{






  GtkObjectClass parent_class;



  guint activate_signal;

  guint set_scroll_adjustments_signal;




  void (*dispatch_child_properties_changed) (GtkWidget *widget,
                                             guint n_pspecs,
                                             GParamSpec **pspecs);


  void (* show) (GtkWidget *widget);
  void (* show_all) (GtkWidget *widget);
  void (* hide) (GtkWidget *widget);
  void (* hide_all) (GtkWidget *widget);
  void (* map) (GtkWidget *widget);
  void (* unmap) (GtkWidget *widget);
  void (* realize) (GtkWidget *widget);
  void (* unrealize) (GtkWidget *widget);
  void (* size_request) (GtkWidget *widget,
                                GtkRequisition *requisition);
  void (* size_allocate) (GtkWidget *widget,
                                GtkAllocation *allocation);
  void (* state_changed) (GtkWidget *widget,
                                GtkStateType previous_state);
  void (* parent_set) (GtkWidget *widget,
                                GtkWidget *previous_parent);
  void (* hierarchy_changed) (GtkWidget *widget,
                                GtkWidget *previous_toplevel);
  void (* style_set) (GtkWidget *widget,
                                GtkStyle *previous_style);
  void (* direction_changed) (GtkWidget *widget,
                                GtkTextDirection previous_direction);
  void (* grab_notify) (GtkWidget *widget,
                                gboolean was_grabbed);
  void (* child_notify) (GtkWidget *widget,
                                GParamSpec *pspec);


  gboolean (* mnemonic_activate) (GtkWidget *widget,
                                  gboolean group_cycling);


  void (* grab_focus) (GtkWidget *widget);
  gboolean (* focus) (GtkWidget *widget,
                                GtkDirectionType direction);


  gboolean (* event) (GtkWidget *widget,
                                         GdkEvent *event);
  gboolean (* button_press_event) (GtkWidget *widget,
                                         GdkEventButton *event);
  gboolean (* button_release_event) (GtkWidget *widget,
                                         GdkEventButton *event);
  gboolean (* scroll_event) (GtkWidget *widget,
                                         GdkEventScroll *event);
  gboolean (* motion_notify_event) (GtkWidget *widget,
                                         GdkEventMotion *event);
  gboolean (* delete_event) (GtkWidget *widget,
                                         GdkEventAny *event);
  gboolean (* destroy_event) (GtkWidget *widget,
                                         GdkEventAny *event);
  gboolean (* expose_event) (GtkWidget *widget,
                                         GdkEventExpose *event);
  gboolean (* key_press_event) (GtkWidget *widget,
                                         GdkEventKey *event);
  gboolean (* key_release_event) (GtkWidget *widget,
                                         GdkEventKey *event);
  gboolean (* enter_notify_event) (GtkWidget *widget,
                                         GdkEventCrossing *event);
  gboolean (* leave_notify_event) (GtkWidget *widget,
                                         GdkEventCrossing *event);
  gboolean (* configure_event) (GtkWidget *widget,
                                         GdkEventConfigure *event);
  gboolean (* focus_in_event) (GtkWidget *widget,
                                         GdkEventFocus *event);
  gboolean (* focus_out_event) (GtkWidget *widget,
                                         GdkEventFocus *event);
  gboolean (* map_event) (GtkWidget *widget,
                                         GdkEventAny *event);
  gboolean (* unmap_event) (GtkWidget *widget,
                                         GdkEventAny *event);
  gboolean (* property_notify_event) (GtkWidget *widget,
                                         GdkEventProperty *event);
  gboolean (* selection_clear_event) (GtkWidget *widget,
                                         GdkEventSelection *event);
  gboolean (* selection_request_event) (GtkWidget *widget,
                                         GdkEventSelection *event);
  gboolean (* selection_notify_event) (GtkWidget *widget,
                                         GdkEventSelection *event);
  gboolean (* proximity_in_event) (GtkWidget *widget,
                                         GdkEventProximity *event);
  gboolean (* proximity_out_event) (GtkWidget *widget,
                                         GdkEventProximity *event);
  gboolean (* visibility_notify_event) (GtkWidget *widget,
                                         GdkEventVisibility *event);
  gboolean (* client_event) (GtkWidget *widget,
                                         GdkEventClient *event);
  gboolean (* no_expose_event) (GtkWidget *widget,
                                         GdkEventAny *event);
  gboolean (* window_state_event) (GtkWidget *widget,
                                         GdkEventWindowState *event);


  void (* selection_get) (GtkWidget *widget,
                                    GtkSelectionData *selection_data,
                                    guint info,
                                    guint time_);
  void (* selection_received) (GtkWidget *widget,
                                    GtkSelectionData *selection_data,
                                    guint time_);


  void (* drag_begin) (GtkWidget *widget,
                                    GdkDragContext *context);
  void (* drag_end) (GtkWidget *widget,
                                    GdkDragContext *context);
  void (* drag_data_get) (GtkWidget *widget,
                                    GdkDragContext *context,
                                    GtkSelectionData *selection_data,
                                    guint info,
                                    guint time_);
  void (* drag_data_delete) (GtkWidget *widget,
                                    GdkDragContext *context);


  void (* drag_leave) (GtkWidget *widget,
                                    GdkDragContext *context,
                                    guint time_);
  gboolean (* drag_motion) (GtkWidget *widget,
                                    GdkDragContext *context,
                                    gint x,
                                    gint y,
                                    guint time_);
  gboolean (* drag_drop) (GtkWidget *widget,
                                    GdkDragContext *context,
                                    gint x,
                                    gint y,
                                    guint time_);
  void (* drag_data_received) (GtkWidget *widget,
                                    GdkDragContext *context,
                                    gint x,
                                    gint y,
                                    GtkSelectionData *selection_data,
                                    guint info,
                                    guint time_);


  gboolean (* popup_menu) (GtkWidget *widget);






  gboolean (* show_help) (GtkWidget *widget,
                                    GtkWidgetHelpType help_type);



  AtkObject* (* get_accessible) (GtkWidget *widget);

  void (* screen_changed) (GtkWidget *widget,
                           GdkScreen *previous_screen);

  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
  void (*_gtk_reserved5) (void);
  void (*_gtk_reserved6) (void);
  void (*_gtk_reserved7) (void);
};

struct _GtkWidgetAuxInfo
{
  gint x;
  gint y;
  gint width;
  gint height;
  guint x_set : 1;
  guint y_set : 1;
};

struct _GtkWidgetShapeInfo
{
  gint16 offset_x;
  gint16 offset_y;
  GdkBitmap *shape_mask;
};

GType gtk_widget_get_type (void) ;
GtkWidget* gtk_widget_new (GType type,
                                           const gchar *first_property_name,
                                           ...);
GtkWidget* gtk_widget_ref (GtkWidget *widget);
void gtk_widget_unref (GtkWidget *widget);
void gtk_widget_destroy (GtkWidget *widget);
void gtk_widget_destroyed (GtkWidget *widget,
                                           GtkWidget **widget_pointer);

void gtk_widget_set (GtkWidget *widget,
                                           const gchar *first_property_name,
                                           ...);

void gtk_widget_unparent (GtkWidget *widget);
void gtk_widget_show (GtkWidget *widget);
void gtk_widget_show_now (GtkWidget *widget);
void gtk_widget_hide (GtkWidget *widget);
void gtk_widget_show_all (GtkWidget *widget);
void gtk_widget_hide_all (GtkWidget *widget);
void gtk_widget_map (GtkWidget *widget);
void gtk_widget_unmap (GtkWidget *widget);
void gtk_widget_realize (GtkWidget *widget);
void gtk_widget_unrealize (GtkWidget *widget);


void gtk_widget_queue_draw (GtkWidget *widget);
void gtk_widget_queue_draw_area (GtkWidget *widget,
                                           gint x,
                                           gint y,
                                           gint width,
                                           gint height);

void gtk_widget_queue_clear (GtkWidget *widget);
void gtk_widget_queue_clear_area (GtkWidget *widget,
                                           gint x,
                                           gint y,
                                           gint width,
                                           gint height);



void gtk_widget_queue_resize (GtkWidget *widget);

void gtk_widget_draw (GtkWidget *widget,
                                           GdkRectangle *area);

void gtk_widget_size_request (GtkWidget *widget,
                                           GtkRequisition *requisition);
void gtk_widget_size_allocate (GtkWidget *widget,
                                           GtkAllocation *allocation);
void gtk_widget_get_child_requisition (GtkWidget *widget,
                                             GtkRequisition *requisition);
void gtk_widget_add_accelerator (GtkWidget *widget,
                                           const gchar *accel_signal,
                                           GtkAccelGroup *accel_group,
                                           guint accel_key,
                                           GdkModifierType accel_mods,
                                           GtkAccelFlags accel_flags);
gboolean gtk_widget_remove_accelerator (GtkWidget *widget,
                                           GtkAccelGroup *accel_group,
                                           guint accel_key,
                                           GdkModifierType accel_mods);
void gtk_widget_set_accel_path (GtkWidget *widget,
                                           const gchar *accel_path,
                                           GtkAccelGroup *accel_group);
const gchar* _gtk_widget_get_accel_path (GtkWidget *widget,
                                           gboolean *locked);
GList* gtk_widget_list_accel_closures (GtkWidget *widget);
gboolean gtk_widget_mnemonic_activate (GtkWidget *widget,
                                           gboolean group_cycling);
gboolean gtk_widget_event (GtkWidget *widget,
                                           GdkEvent *event);
gint gtk_widget_send_expose (GtkWidget *widget,
                                           GdkEvent *event);

gboolean gtk_widget_activate (GtkWidget *widget);
gboolean gtk_widget_set_scroll_adjustments (GtkWidget *widget,
                                              GtkAdjustment *hadjustment,
                                              GtkAdjustment *vadjustment);

void gtk_widget_reparent (GtkWidget *widget,
                                           GtkWidget *new_parent);
gboolean gtk_widget_intersect (GtkWidget *widget,
                                           GdkRectangle *area,
                                           GdkRectangle *intersection);
GdkRegion *gtk_widget_region_intersect (GtkWidget *widget,
                                           GdkRegion *region);

void gtk_widget_freeze_child_notify (GtkWidget *widget);
void gtk_widget_child_notify (GtkWidget *widget,
                                           const gchar *child_property);
void gtk_widget_thaw_child_notify (GtkWidget *widget);

gboolean gtk_widget_is_focus (GtkWidget *widget);
void gtk_widget_grab_focus (GtkWidget *widget);
void gtk_widget_grab_default (GtkWidget *widget);

void gtk_widget_set_name (GtkWidget *widget,
                                                         const gchar *name);
const gchar* gtk_widget_get_name (GtkWidget *widget);
void gtk_widget_set_state (GtkWidget *widget,
                                                         GtkStateType state);
void gtk_widget_set_sensitive (GtkWidget *widget,
                                                         gboolean sensitive);
void gtk_widget_set_app_paintable (GtkWidget *widget,
                                                         gboolean app_paintable);
void gtk_widget_set_double_buffered (GtkWidget *widget,
                                                         gboolean double_buffered);
void gtk_widget_set_redraw_on_allocate (GtkWidget *widget,
                                                         gboolean redraw_on_allocate);
void gtk_widget_set_parent (GtkWidget *widget,
                                                         GtkWidget *parent);
void gtk_widget_set_parent_window (GtkWidget *widget,
                                                         GdkWindow *parent_window);
void gtk_widget_set_child_visible (GtkWidget *widget,
                                                         gboolean is_visible);
gboolean gtk_widget_get_child_visible (GtkWidget *widget);

GtkWidget *gtk_widget_get_parent (GtkWidget *widget);
GdkWindow *gtk_widget_get_parent_window (GtkWidget *widget);

gboolean gtk_widget_child_focus (GtkWidget *widget,
                                           GtkDirectionType direction);

void gtk_widget_set_size_request (GtkWidget *widget,
                                           gint width,
                                           gint height);
void gtk_widget_get_size_request (GtkWidget *widget,
                                           gint *width,
                                           gint *height);

void gtk_widget_set_uposition (GtkWidget *widget,
                                           gint x,
                                           gint y);
void gtk_widget_set_usize (GtkWidget *widget,
                                           gint width,
                                           gint height);


void gtk_widget_set_events (GtkWidget *widget,
                                           gint events);
void gtk_widget_add_events (GtkWidget *widget,
                                           gint events);
void gtk_widget_set_extension_events (GtkWidget *widget,
                                            GdkExtensionMode mode);

GdkExtensionMode gtk_widget_get_extension_events (GtkWidget *widget);
GtkWidget* gtk_widget_get_toplevel (GtkWidget *widget);
GtkWidget* gtk_widget_get_ancestor (GtkWidget *widget,
                                         GType widget_type);
GdkColormap* gtk_widget_get_colormap (GtkWidget *widget);
GdkVisual* gtk_widget_get_visual (GtkWidget *widget);

GdkScreen * gtk_widget_get_screen (GtkWidget *widget);
gboolean gtk_widget_has_screen (GtkWidget *widget);
GdkDisplay * gtk_widget_get_display (GtkWidget *widget);
GdkWindow * gtk_widget_get_root_window (GtkWidget *widget);
GtkSettings* gtk_widget_get_settings (GtkWidget *widget);
GtkClipboard *gtk_widget_get_clipboard (GtkWidget *widget,
                                          GdkAtom selection);
# 602 "/usr/include/gtk-2.0/gtk/gtkwidget.h" 3 4
AtkObject* gtk_widget_get_accessible (GtkWidget *widget);







void gtk_widget_set_colormap (GtkWidget *widget,
                                         GdkColormap *colormap);

gint gtk_widget_get_events (GtkWidget *widget);
void gtk_widget_get_pointer (GtkWidget *widget,
                                         gint *x,
                                         gint *y);

gboolean gtk_widget_is_ancestor (GtkWidget *widget,
                                         GtkWidget *ancestor);

gboolean gtk_widget_translate_coordinates (GtkWidget *src_widget,
                                               GtkWidget *dest_widget,
                                               gint src_x,
                                               gint src_y,
                                               gint *dest_x,
                                               gint *dest_y);



gboolean gtk_widget_hide_on_delete (GtkWidget *widget);



void gtk_widget_set_style (GtkWidget *widget,
                                         GtkStyle *style);
void gtk_widget_ensure_style (GtkWidget *widget);
GtkStyle* gtk_widget_get_style (GtkWidget *widget);

void gtk_widget_modify_style (GtkWidget *widget,
                                           GtkRcStyle *style);
GtkRcStyle *gtk_widget_get_modifier_style (GtkWidget *widget);
void gtk_widget_modify_fg (GtkWidget *widget,
                                           GtkStateType state,
                                           GdkColor *color);
void gtk_widget_modify_bg (GtkWidget *widget,
                                           GtkStateType state,
                                           GdkColor *color);
void gtk_widget_modify_text (GtkWidget *widget,
                                           GtkStateType state,
                                           GdkColor *color);
void gtk_widget_modify_base (GtkWidget *widget,
                                           GtkStateType state,
                                           GdkColor *color);
void gtk_widget_modify_font (GtkWidget *widget,
                                           PangoFontDescription *font_desc);






PangoContext *gtk_widget_create_pango_context (GtkWidget *widget);
PangoContext *gtk_widget_get_pango_context (GtkWidget *widget);
PangoLayout *gtk_widget_create_pango_layout (GtkWidget *widget,
                                               const gchar *text);

GdkPixbuf *gtk_widget_render_icon (GtkWidget *widget,
                                               const gchar *stock_id,
                                               GtkIconSize size,
                                               const gchar *detail);




void gtk_widget_set_composite_name (GtkWidget *widget,
                                         const gchar *name);
gchar* gtk_widget_get_composite_name (GtkWidget *widget);


void gtk_widget_reset_rc_styles (GtkWidget *widget);





void gtk_widget_push_colormap (GdkColormap *cmap);
void gtk_widget_push_composite_child (void);
void gtk_widget_pop_composite_child (void);
void gtk_widget_pop_colormap (void);



void gtk_widget_class_install_style_property (GtkWidgetClass *klass,
                                                     GParamSpec *pspec);
void gtk_widget_class_install_style_property_parser (GtkWidgetClass *klass,
                                                     GParamSpec *pspec,
                                                     GtkRcPropertyParser parser);
GParamSpec* gtk_widget_class_find_style_property (GtkWidgetClass *klass,
                                                     const gchar *property_name);
GParamSpec** gtk_widget_class_list_style_properties (GtkWidgetClass *klass,
                                                     guint *n_properties);
void gtk_widget_style_get_property (GtkWidget *widget,
                                    const gchar *property_name,
                                    GValue *value);
void gtk_widget_style_get_valist (GtkWidget *widget,
                                    const gchar *first_property_name,
                                    va_list var_args);
void gtk_widget_style_get (GtkWidget *widget,
                                    const gchar *first_property_name,
                                    ...);




void gtk_widget_set_default_colormap (GdkColormap *colormap);
GtkStyle* gtk_widget_get_default_style (void);

GdkColormap* gtk_widget_get_default_colormap (void);
GdkVisual* gtk_widget_get_default_visual (void);





void gtk_widget_set_direction (GtkWidget *widget,
                                                   GtkTextDirection dir);
GtkTextDirection gtk_widget_get_direction (GtkWidget *widget);

void gtk_widget_set_default_direction (GtkTextDirection dir);
GtkTextDirection gtk_widget_get_default_direction (void);



void gtk_widget_shape_combine_mask (GtkWidget *widget,
                                            GdkBitmap *shape_mask,
                                            gint offset_x,
                                            gint offset_y);


void gtk_widget_reset_shapes (GtkWidget *widget);




void gtk_widget_path (GtkWidget *widget,
                                            guint *path_length,
                                            gchar **path,
                                            gchar **path_reversed);
void gtk_widget_class_path (GtkWidget *widget,
                                            guint *path_length,
                                            gchar **path,
                                            gchar **path_reversed);

GType gtk_requisition_get_type (void);
GtkRequisition *gtk_requisition_copy (const GtkRequisition *requisition);
void gtk_requisition_free (GtkRequisition *requisition);






GtkWidgetAuxInfo *_gtk_widget_get_aux_info (GtkWidget *widget,
                                                           gboolean create);
void _gtk_widget_propagate_hierarchy_changed (GtkWidget *widget,
                                                           GtkWidget *previous_toplevel);
void _gtk_widget_propagate_screen_changed (GtkWidget *widget,
                                                           GdkScreen *previous_screen);

GdkColormap* _gtk_widget_peek_colormap (void);
# 33 "/usr/include/gtk-2.0/gtk/gtkmisc.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkmisc.h" 3 4
typedef struct _GtkMisc GtkMisc;
typedef struct _GtkMiscClass GtkMiscClass;

struct _GtkMisc
{
  GtkWidget widget;

  gfloat xalign;
  gfloat yalign;

  guint16 xpad;
  guint16 ypad;
};

struct _GtkMiscClass
{
  GtkWidgetClass parent_class;
};


GType gtk_misc_get_type (void) ;
void gtk_misc_set_alignment (GtkMisc *misc,
                                gfloat xalign,
                                gfloat yalign);
void gtk_misc_get_alignment (GtkMisc *misc,
                                gfloat *xalign,
                                gfloat *yalign);
void gtk_misc_set_padding (GtkMisc *misc,
                                gint xpad,
                                gint ypad);
void gtk_misc_get_padding (GtkMisc *misc,
                                gint *xpad,
                                gint *ypad);
# 32 "/usr/include/gtk-2.0/gtk/gtklabel.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkwindow.h" 1 3 4
# 33 "/usr/include/gtk-2.0/gtk/gtkwindow.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkbin.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkbin.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcontainer.h" 1 3 4
# 52 "/usr/include/gtk-2.0/gtk/gtkcontainer.h" 3 4
typedef struct _GtkContainer GtkContainer;
typedef struct _GtkContainerClass GtkContainerClass;

struct _GtkContainer
{
  GtkWidget widget;

  GtkWidget *focus_child;

  guint border_width : 16;
  guint need_resize : 1;
  guint resize_mode : 2;
  guint reallocate_redraws : 1;
  guint has_focus_chain : 1;
};

struct _GtkContainerClass
{
  GtkWidgetClass parent_class;

  void (*add) (GtkContainer *container,
                                 GtkWidget *widget);
  void (*remove) (GtkContainer *container,
                                 GtkWidget *widget);
  void (*check_resize) (GtkContainer *container);
  void (*forall) (GtkContainer *container,
                                 gboolean include_internals,
                                 GtkCallback callback,
                                 gpointer callback_data);
  void (*set_focus_child) (GtkContainer *container,
                                 GtkWidget *widget);
  GType (*child_type) (GtkContainer *container);
  gchar* (*composite_name) (GtkContainer *container,
                                 GtkWidget *child);
  void (*set_child_property) (GtkContainer *container,
                                 GtkWidget *child,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec);
  void (*get_child_property) (GtkContainer *container,
                                 GtkWidget *child,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};



GType gtk_container_get_type (void) ;
void gtk_container_set_border_width (GtkContainer *container,
                                          guint border_width);
guint gtk_container_get_border_width (GtkContainer *container);
void gtk_container_add (GtkContainer *container,
                                          GtkWidget *widget);
void gtk_container_remove (GtkContainer *container,
                                          GtkWidget *widget);

void gtk_container_set_resize_mode (GtkContainer *container,
                                          GtkResizeMode resize_mode);
GtkResizeMode gtk_container_get_resize_mode (GtkContainer *container);

void gtk_container_check_resize (GtkContainer *container);

void gtk_container_foreach (GtkContainer *container,
                                     GtkCallback callback,
                                     gpointer callback_data);

void gtk_container_foreach_full (GtkContainer *container,
                                     GtkCallback callback,
                                     GtkCallbackMarshal marshal,
                                     gpointer callback_data,
                                     GtkDestroyNotify notify);

GList* gtk_container_get_children (GtkContainer *container);





void gtk_container_propagate_expose (GtkContainer *container,
                                         GtkWidget *child,
                                         GdkEventExpose *event);

void gtk_container_set_focus_chain (GtkContainer *container,
                                         GList *focusable_widgets);
gboolean gtk_container_get_focus_chain (GtkContainer *container,
                                         GList **focusable_widgets);
void gtk_container_unset_focus_chain (GtkContainer *container);



void gtk_container_set_reallocate_redraws (GtkContainer *container,
                                             gboolean needs_redraws);
void gtk_container_set_focus_child (GtkContainer *container,
                                            GtkWidget *child);
void gtk_container_set_focus_vadjustment (GtkContainer *container,
                                            GtkAdjustment *adjustment);
GtkAdjustment *gtk_container_get_focus_vadjustment (GtkContainer *container);
void gtk_container_set_focus_hadjustment (GtkContainer *container,
                                            GtkAdjustment *adjustment);
GtkAdjustment *gtk_container_get_focus_hadjustment (GtkContainer *container);

void gtk_container_resize_children (GtkContainer *container);

GType gtk_container_child_type (GtkContainer *container);


void gtk_container_class_install_child_property (GtkContainerClass *cclass,
                                                         guint property_id,
                                                         GParamSpec *pspec);
GParamSpec* gtk_container_class_find_child_property (GObjectClass *cclass,
                                                         const gchar *property_name);
GParamSpec** gtk_container_class_list_child_properties (GObjectClass *cclass,
                                                         guint *n_properties);
void gtk_container_add_with_properties (GtkContainer *container,
                                                         GtkWidget *widget,
                                                         const gchar *first_prop_name,
                                                         ...);
void gtk_container_child_set (GtkContainer *container,
                                                         GtkWidget *child,
                                                         const gchar *first_prop_name,
                                                         ...);
void gtk_container_child_get (GtkContainer *container,
                                                         GtkWidget *child,
                                                         const gchar *first_prop_name,
                                                         ...);
void gtk_container_child_set_valist (GtkContainer *container,
                                                         GtkWidget *child,
                                                         const gchar *first_property_name,
                                                         va_list var_args);
void gtk_container_child_get_valist (GtkContainer *container,
                                                         GtkWidget *child,
                                                         const gchar *first_property_name,
                                                         va_list var_args);
void gtk_container_child_set_property (GtkContainer *container,
                                                         GtkWidget *child,
                                                         const gchar *property_name,
                                                         const GValue *value);
void gtk_container_child_get_property (GtkContainer *container,
                                                         GtkWidget *child,
                                                         const gchar *property_name,
                                                         GValue *value);





void gtk_container_forall (GtkContainer *container,
                                              GtkCallback callback,
                                              gpointer callback_data);


void _gtk_container_queue_resize (GtkContainer *container);
void _gtk_container_clear_resize_widgets (GtkContainer *container);
gchar* _gtk_container_child_composite_name (GtkContainer *container,
                                              GtkWidget *child);
void _gtk_container_dequeue_resize_handler (GtkContainer *container);
GList *_gtk_container_focus_sort (GtkContainer *container,
                                              GList *children,
                                              GtkDirectionType direction,
                                              GtkWidget *old_focus);
# 33 "/usr/include/gtk-2.0/gtk/gtkbin.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkbin.h" 3 4
typedef struct _GtkBin GtkBin;
typedef struct _GtkBinClass GtkBinClass;

struct _GtkBin
{
  GtkContainer container;

  GtkWidget *child;
};

struct _GtkBinClass
{
  GtkContainerClass parent_class;
};


GType gtk_bin_get_type (void) ;

GtkWidget *gtk_bin_get_child (GtkBin *bin);
# 34 "/usr/include/gtk-2.0/gtk/gtkwindow.h" 2 3 4
# 50 "/usr/include/gtk-2.0/gtk/gtkwindow.h" 3 4
typedef struct _GtkWindow GtkWindow;
typedef struct _GtkWindowClass GtkWindowClass;
typedef struct _GtkWindowGeometryInfo GtkWindowGeometryInfo;
typedef struct _GtkWindowGroup GtkWindowGroup;
typedef struct _GtkWindowGroupClass GtkWindowGroupClass;

struct _GtkWindow
{
  GtkBin bin;

  gchar *title;
  gchar *wmclass_name;
  gchar *wmclass_class;
  gchar *wm_role;

  GtkWidget *focus_widget;
  GtkWidget *default_widget;
  GtkWindow *transient_parent;
  GtkWindowGeometryInfo *geometry_info;
  GdkWindow *frame;
  GtkWindowGroup *group;

  guint16 configure_request_count;
  guint allow_shrink : 1;
  guint allow_grow : 1;
  guint configure_notify_received : 1;






  guint need_default_position : 1;
  guint need_default_size : 1;
  guint position : 3;
  guint type : 4;
  guint has_user_ref_count : 1;
  guint has_focus : 1;

  guint modal : 1;
  guint destroy_with_parent : 1;

  guint has_frame : 1;


  guint iconify_initially : 1;
  guint stick_initially : 1;
  guint maximize_initially : 1;
  guint decorated : 1;

  guint type_hint : 3;
  guint gravity : 5;

  guint is_active : 1;
  guint has_toplevel_focus : 1;

  guint frame_left;
  guint frame_top;
  guint frame_right;
  guint frame_bottom;

  guint keys_changed_handler;

  GdkModifierType mnemonic_modifier;
  GdkScreen *screen;
};

struct _GtkWindowClass
{
  GtkBinClass parent_class;

  void (* set_focus) (GtkWindow *window,
                            GtkWidget *focus);
  gboolean (* frame_event) (GtkWindow *window,
                            GdkEvent *event);



  void (* activate_focus) (GtkWindow *window);
  void (* activate_default) (GtkWindow *window);
  void (* move_focus) (GtkWindow *window,
                                        GtkDirectionType direction);

  void (*keys_changed) (GtkWindow *window);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};
# 149 "/usr/include/gtk-2.0/gtk/gtkwindow.h" 3 4
struct _GtkWindowGroup
{
  GObject parent_instance;

  GSList *grabs;
};

struct _GtkWindowGroupClass
{
  GObjectClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_window_get_type (void) ;
GtkWidget* gtk_window_new (GtkWindowType type);
void gtk_window_set_title (GtkWindow *window,
                                                const gchar *title);
const gchar *gtk_window_get_title (GtkWindow *window);
void gtk_window_set_wmclass (GtkWindow *window,
                                                const gchar *wmclass_name,
                                                const gchar *wmclass_class);
void gtk_window_set_role (GtkWindow *window,
                                                const gchar *role);
const gchar *gtk_window_get_role (GtkWindow *window);
void gtk_window_add_accel_group (GtkWindow *window,
                                                GtkAccelGroup *accel_group);
void gtk_window_remove_accel_group (GtkWindow *window,
                                                GtkAccelGroup *accel_group);
void gtk_window_set_position (GtkWindow *window,
                                                GtkWindowPosition position);
gboolean gtk_window_activate_focus (GtkWindow *window);
void gtk_window_set_focus (GtkWindow *window,
                                                GtkWidget *focus);
GtkWidget *gtk_window_get_focus (GtkWindow *window);
void gtk_window_set_default (GtkWindow *window,
                                                GtkWidget *default_widget);
gboolean gtk_window_activate_default (GtkWindow *window);

void gtk_window_set_transient_for (GtkWindow *window,
                                                GtkWindow *parent);
GtkWindow *gtk_window_get_transient_for (GtkWindow *window);
void gtk_window_set_type_hint (GtkWindow *window,
                                                GdkWindowTypeHint hint);
GdkWindowTypeHint gtk_window_get_type_hint (GtkWindow *window);
void gtk_window_set_skip_taskbar_hint (GtkWindow *window,
                                                gboolean setting);
gboolean gtk_window_get_skip_taskbar_hint (GtkWindow *window);
void gtk_window_set_skip_pager_hint (GtkWindow *window,
                                                gboolean setting);
gboolean gtk_window_get_skip_pager_hint (GtkWindow *window);
void gtk_window_set_destroy_with_parent (GtkWindow *window,
                                                gboolean setting);
gboolean gtk_window_get_destroy_with_parent (GtkWindow *window);

void gtk_window_set_resizable (GtkWindow *window,
                                                gboolean resizable);
gboolean gtk_window_get_resizable (GtkWindow *window);

void gtk_window_set_gravity (GtkWindow *window,
                                                GdkGravity gravity);
GdkGravity gtk_window_get_gravity (GtkWindow *window);


void gtk_window_set_geometry_hints (GtkWindow *window,
                                                GtkWidget *geometry_widget,
                                                GdkGeometry *geometry,
                                                GdkWindowHints geom_mask);

void gtk_window_set_screen (GtkWindow *window,
                                                GdkScreen *screen);
GdkScreen* gtk_window_get_screen (GtkWindow *window);


void gtk_window_set_has_frame (GtkWindow *window,
                                                gboolean setting);
gboolean gtk_window_get_has_frame (GtkWindow *window);
void gtk_window_set_frame_dimensions (GtkWindow *window,
                                                gint left,
                                                gint top,
                                                gint right,
                                                gint bottom);
void gtk_window_get_frame_dimensions (GtkWindow *window,
                                                gint *left,
                                                gint *top,
                                                gint *right,
                                                gint *bottom);
void gtk_window_set_decorated (GtkWindow *window,
                                                gboolean setting);
gboolean gtk_window_get_decorated (GtkWindow *window);

void gtk_window_set_icon_list (GtkWindow *window,
                                                    GList *list);
GList* gtk_window_get_icon_list (GtkWindow *window);
void gtk_window_set_icon (GtkWindow *window,
                                                    GdkPixbuf *icon);
gboolean gtk_window_set_icon_from_file (GtkWindow *window,
                                                    const gchar *filename,
                                                    GError **err);
GdkPixbuf* gtk_window_get_icon (GtkWindow *window);
void gtk_window_set_default_icon_list (GList *list);
GList* gtk_window_get_default_icon_list (void);
gboolean gtk_window_set_default_icon_from_file (const gchar *filename,
                                                    GError **err);

void gtk_window_set_auto_startup_notification (gboolean setting);


void gtk_window_set_modal (GtkWindow *window,
                                      gboolean modal);
gboolean gtk_window_get_modal (GtkWindow *window);
GList* gtk_window_list_toplevels (void);

void gtk_window_add_mnemonic (GtkWindow *window,
                                           guint keyval,
                                           GtkWidget *target);
void gtk_window_remove_mnemonic (GtkWindow *window,
                                           guint keyval,
                                           GtkWidget *target);
gboolean gtk_window_mnemonic_activate (GtkWindow *window,
                                           guint keyval,
                                           GdkModifierType modifier);
void gtk_window_set_mnemonic_modifier (GtkWindow *window,
                                           GdkModifierType modifier);
GdkModifierType gtk_window_get_mnemonic_modifier (GtkWindow *window);

void gtk_window_present (GtkWindow *window);
void gtk_window_iconify (GtkWindow *window);
void gtk_window_deiconify (GtkWindow *window);
void gtk_window_stick (GtkWindow *window);
void gtk_window_unstick (GtkWindow *window);
void gtk_window_maximize (GtkWindow *window);
void gtk_window_unmaximize (GtkWindow *window);
void gtk_window_fullscreen (GtkWindow *window);
void gtk_window_unfullscreen (GtkWindow *window);

void gtk_window_begin_resize_drag (GtkWindow *window,
                                   GdkWindowEdge edge,
                                   gint button,
                                   gint root_x,
                                   gint root_y,
                                   guint32 timestamp);
void gtk_window_begin_move_drag (GtkWindow *window,
                                   gint button,
                                   gint root_x,
                                   gint root_y,
                                   guint32 timestamp);


void gtk_window_set_policy (GtkWindow *window,
                                                gint allow_shrink,
                                                gint allow_grow,
                                                gint auto_shrink);






void gtk_window_set_default_size (GtkWindow *window,
                                      gint width,
                                      gint height);
void gtk_window_get_default_size (GtkWindow *window,
                                      gint *width,
                                      gint *height);
void gtk_window_resize (GtkWindow *window,
                                      gint width,
                                      gint height);
void gtk_window_get_size (GtkWindow *window,
                                      gint *width,
                                      gint *height);
void gtk_window_move (GtkWindow *window,
                                      gint x,
                                      gint y);
void gtk_window_get_position (GtkWindow *window,
                                      gint *root_x,
                                      gint *root_y);
gboolean gtk_window_parse_geometry (GtkWindow *window,
                                      const gchar *geometry);


void gtk_window_reshow_with_initial_size (GtkWindow *window);



GType gtk_window_group_get_type (void) ;

GtkWindowGroup * gtk_window_group_new (void);
void gtk_window_group_add_window (GtkWindowGroup *window_group,
                                                 GtkWindow *window);
void gtk_window_group_remove_window (GtkWindowGroup *window_group,
                                                 GtkWindow *window);


void _gtk_window_internal_set_focus (GtkWindow *window,
                                                GtkWidget *focus);
void gtk_window_remove_embedded_xid (GtkWindow *window,
                                                guint xid);
void gtk_window_add_embedded_xid (GtkWindow *window,
                                                guint xid);
void _gtk_window_reposition (GtkWindow *window,
                                                gint x,
                                                gint y);
void _gtk_window_constrain_size (GtkWindow *window,
                                                gint width,
                                                gint height,
                                                gint *new_width,
                                                gint *new_height);
GtkWindowGroup *_gtk_window_get_group (GtkWindow *window);
gboolean _gtk_window_activate_key (GtkWindow *window,
                                                GdkEventKey *event);

void _gtk_window_set_has_toplevel_focus (GtkWindow *window,
                                                    gboolean has_toplevel_focus);
void _gtk_window_unset_focus_and_default (GtkWindow *window,
                                                     GtkWidget *widget);

void _gtk_window_set_is_active (GtkWindow *window,
                                                    gboolean is_active);

typedef void (*GtkWindowKeysForeachFunc) (GtkWindow *window,
                                          guint keyval,
                                          GdkModifierType modifiers,
                                          gboolean is_mnemonic,
                                          gpointer data);

void _gtk_window_keys_foreach (GtkWindow *window,
                               GtkWindowKeysForeachFunc func,
                               gpointer func_data);


gboolean _gtk_window_query_nonaccels (GtkWindow *window,
                                                 guint accel_key,
                                                 GdkModifierType accel_mods);
# 33 "/usr/include/gtk-2.0/gtk/gtklabel.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkmenu.h" 1 3 4
# 33 "/usr/include/gtk-2.0/gtk/gtkmenu.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkmenushell.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkmenushell.h" 3 4
typedef struct _GtkMenuShell GtkMenuShell;
typedef struct _GtkMenuShellClass GtkMenuShellClass;

struct _GtkMenuShell
{
  GtkContainer container;

  GList *children;
  GtkWidget *active_menu_item;
  GtkWidget *parent_menu_shell;

  guint button;
  guint32 activate_time;

  guint active : 1;
  guint have_grab : 1;
  guint have_xgrab : 1;
  guint ignore_leave : 1;
  guint menu_flag : 1;
  guint ignore_enter : 1;
};

struct _GtkMenuShellClass
{
  GtkContainerClass parent_class;

  guint submenu_placement : 1;

  void (*deactivate) (GtkMenuShell *menu_shell);
  void (*selection_done) (GtkMenuShell *menu_shell);

  void (*move_current) (GtkMenuShell *menu_shell,
                            GtkMenuDirectionType direction);
  void (*activate_current) (GtkMenuShell *menu_shell,
                            gboolean force_hide);
  void (*cancel) (GtkMenuShell *menu_shell);
  void (*select_item) (GtkMenuShell *menu_shell,
                            GtkWidget *menu_item);
  void (*insert) (GtkMenuShell *menu_shell,
                            GtkWidget *child,
                            gint position);
  gint (*get_popup_delay) (GtkMenuShell *menu_shell);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
};


GType gtk_menu_shell_get_type (void) ;
void gtk_menu_shell_append (GtkMenuShell *menu_shell,
                                        GtkWidget *child);
void gtk_menu_shell_prepend (GtkMenuShell *menu_shell,
                                        GtkWidget *child);
void gtk_menu_shell_insert (GtkMenuShell *menu_shell,
                                        GtkWidget *child,
                                        gint position);
void gtk_menu_shell_deactivate (GtkMenuShell *menu_shell);
void gtk_menu_shell_select_item (GtkMenuShell *menu_shell,
                                        GtkWidget *menu_item);
void gtk_menu_shell_deselect (GtkMenuShell *menu_shell);
void gtk_menu_shell_activate_item (GtkMenuShell *menu_shell,
                                        GtkWidget *menu_item,
                                        gboolean force_deactivate);
void gtk_menu_shell_select_first (GtkMenuShell *menu_shell,
                                        gboolean search_sensitive);
void _gtk_menu_shell_select_last (GtkMenuShell *menu_shell,
                                        gboolean search_sensitive);
void _gtk_menu_shell_activate (GtkMenuShell *menu_shell);
gint _gtk_menu_shell_get_popup_delay (GtkMenuShell *menu_shell);
# 34 "/usr/include/gtk-2.0/gtk/gtkmenu.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkmenu.h" 3 4
typedef struct _GtkMenu GtkMenu;
typedef struct _GtkMenuClass GtkMenuClass;

typedef void (*GtkMenuPositionFunc) (GtkMenu *menu,
                                     gint *x,
                                     gint *y,
                                     gboolean *push_in,
                                     gpointer user_data);
typedef void (*GtkMenuDetachFunc) (GtkWidget *attach_widget,
                                     GtkMenu *menu);

struct _GtkMenu
{
  GtkMenuShell menu_shell;

  GtkWidget *parent_menu_item;
  GtkWidget *old_active_menu_item;

  GtkAccelGroup *accel_group;
  gchar *accel_path;
  GtkMenuPositionFunc position_func;
  gpointer position_func_data;

  guint toggle_size;




  GtkWidget *toplevel;

  GtkWidget *tearoff_window;
  GtkWidget *tearoff_hbox;
  GtkWidget *tearoff_scrollbar;
  GtkAdjustment *tearoff_adjustment;

  GdkWindow *view_window;
  GdkWindow *bin_window;

  gint scroll_offset;
  gint saved_scroll_offset;
  gint scroll_step;
  guint timeout_id;




  GdkRegion *navigation_region;
  guint navigation_timeout;

  guint needs_destruction_ref_count : 1;
  guint torn_off : 1;



  guint tearoff_active : 1;

  guint scroll_fast : 1;

  guint upper_arrow_visible : 1;
  guint lower_arrow_visible : 1;
  guint upper_arrow_prelight : 1;
  guint lower_arrow_prelight : 1;
};

struct _GtkMenuClass
{
  GtkMenuShellClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_menu_get_type (void) ;
GtkWidget* gtk_menu_new (void);


void gtk_menu_popup (GtkMenu *menu,
                                           GtkWidget *parent_menu_shell,
                                           GtkWidget *parent_menu_item,
                                           GtkMenuPositionFunc func,
                                           gpointer data,
                                           guint button,
                                           guint32 activate_time);




void gtk_menu_reposition (GtkMenu *menu);

void gtk_menu_popdown (GtkMenu *menu);




GtkWidget* gtk_menu_get_active (GtkMenu *menu);
void gtk_menu_set_active (GtkMenu *menu,
                                           guint index_);




void gtk_menu_set_accel_group (GtkMenu *menu,
                                           GtkAccelGroup *accel_group);
GtkAccelGroup* gtk_menu_get_accel_group (GtkMenu *menu);
void gtk_menu_set_accel_path (GtkMenu *menu,
                                           const gchar *accel_path);





void gtk_menu_attach_to_widget (GtkMenu *menu,
                                           GtkWidget *attach_widget,
                                           GtkMenuDetachFunc detacher);
void gtk_menu_detach (GtkMenu *menu);





GtkWidget* gtk_menu_get_attach_widget (GtkMenu *menu);

void gtk_menu_set_tearoff_state (GtkMenu *menu,
                                           gboolean torn_off);
gboolean gtk_menu_get_tearoff_state (GtkMenu *menu);




void gtk_menu_set_title (GtkMenu *menu,
                                           const gchar *title);
const gchar *gtk_menu_get_title (GtkMenu *menu);

void gtk_menu_reorder_child (GtkMenu *menu,
                                           GtkWidget *child,
                                           gint position);

void gtk_menu_set_screen (GtkMenu *menu,
                                           GdkScreen *screen);
# 34 "/usr/include/gtk-2.0/gtk/gtklabel.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtklabel.h" 3 4
typedef struct _GtkLabel GtkLabel;
typedef struct _GtkLabelClass GtkLabelClass;

typedef struct _GtkLabelSelectionInfo GtkLabelSelectionInfo;

struct _GtkLabel
{
  GtkMisc misc;


  gchar *label;
  guint jtype : 2;
  guint wrap : 1;
  guint use_underline : 1;
  guint use_markup : 1;

  guint mnemonic_keyval;

  gchar *text;
  PangoAttrList *attrs;
  PangoAttrList *effective_attrs;

  PangoLayout *layout;

  GtkWidget *mnemonic_widget;
  GtkWindow *mnemonic_window;

  GtkLabelSelectionInfo *select_info;
};

struct _GtkLabelClass
{
  GtkMiscClass parent_class;

  void (* move_cursor) (GtkLabel *label,
                            GtkMovementStep step,
                            gint count,
                            gboolean extend_selection);
  void (* copy_clipboard) (GtkLabel *label);


  void (* populate_popup) (GtkLabel *label,
                             GtkMenu *menu);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_label_get_type (void) ;
GtkWidget* gtk_label_new (const char *str);
GtkWidget* gtk_label_new_with_mnemonic (const char *str);
void gtk_label_set_text (GtkLabel *label,
                                                   const char *str);
const gchar* gtk_label_get_text (GtkLabel *label);
void gtk_label_set_attributes (GtkLabel *label,
                                                   PangoAttrList *attrs);
PangoAttrList *gtk_label_get_attributes (GtkLabel *label);
void gtk_label_set_label (GtkLabel *label,
                                                   const gchar *str);
const gchar *gtk_label_get_label (GtkLabel *label);
void gtk_label_set_markup (GtkLabel *label,
                                                   const gchar *str);
void gtk_label_set_use_markup (GtkLabel *label,
                                                   gboolean setting);
gboolean gtk_label_get_use_markup (GtkLabel *label);
void gtk_label_set_use_underline (GtkLabel *label,
                                                   gboolean setting);
gboolean gtk_label_get_use_underline (GtkLabel *label);

void gtk_label_set_markup_with_mnemonic (GtkLabel *label,
                                                   const gchar *str);
guint gtk_label_get_mnemonic_keyval (GtkLabel *label);
void gtk_label_set_mnemonic_widget (GtkLabel *label,
                                                   GtkWidget *widget);
GtkWidget *gtk_label_get_mnemonic_widget (GtkLabel *label);
void gtk_label_set_text_with_mnemonic (GtkLabel *label,
                                                   const gchar *str);
void gtk_label_set_justify (GtkLabel *label,
                                                   GtkJustification jtype);
GtkJustification gtk_label_get_justify (GtkLabel *label);
void gtk_label_set_pattern (GtkLabel *label,
                                                   const gchar *pattern);
void gtk_label_set_line_wrap (GtkLabel *label,
                                                   gboolean wrap);
gboolean gtk_label_get_line_wrap (GtkLabel *label);
void gtk_label_set_selectable (GtkLabel *label,
                                                   gboolean setting);
gboolean gtk_label_get_selectable (GtkLabel *label);
void gtk_label_select_region (GtkLabel *label,
                                                   gint start_offset,
                                                   gint end_offset);
gboolean gtk_label_get_selection_bounds (GtkLabel *label,
                                                   gint *start,
                                                   gint *end);

PangoLayout *gtk_label_get_layout (GtkLabel *label);
void gtk_label_get_layout_offsets (GtkLabel *label,
                                           gint *x,
                                           gint *y);





void gtk_label_get (GtkLabel *label,
                                    char **str);





guint gtk_label_parse_uline (GtkLabel *label,
                                        const gchar *string);
# 35 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h" 2 3 4
# 50 "/usr/include/gtk-2.0/gtk/gtkaccellabel.h" 3 4
typedef struct _GtkAccelLabel GtkAccelLabel;
typedef struct _GtkAccelLabelClass GtkAccelLabelClass;

struct _GtkAccelLabel
{
  GtkLabel label;

  guint gtk_reserved;
  guint accel_padding;
  GtkWidget *accel_widget;
  GClosure *accel_closure;
  GtkAccelGroup *accel_group;
  gchar *accel_string;
  guint16 accel_string_width;
};

struct _GtkAccelLabelClass
{
  GtkLabelClass parent_class;

  gchar *signal_quote1;
  gchar *signal_quote2;
  gchar *mod_name_shift;
  gchar *mod_name_control;
  gchar *mod_name_alt;
  gchar *mod_separator;
  gchar *accel_seperator;
  guint latin1_to_char : 1;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};





GType gtk_accel_label_get_type (void) ;
GtkWidget* gtk_accel_label_new (const gchar *string);
GtkWidget* gtk_accel_label_get_accel_widget (GtkAccelLabel *accel_label);
guint gtk_accel_label_get_accel_width (GtkAccelLabel *accel_label);
void gtk_accel_label_set_accel_widget (GtkAccelLabel *accel_label,
                                              GtkWidget *accel_widget);
void gtk_accel_label_set_accel_closure (GtkAccelLabel *accel_label,
                                              GClosure *accel_closure);
gboolean gtk_accel_label_refetch (GtkAccelLabel *accel_label);
# 34 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkaccelmap.h" 1 3 4
# 25 "/usr/include/gtk-2.0/gtk/gtkaccelmap.h" 3 4




typedef void (*GtkAccelMapForeach) (gpointer data,
                                                 const gchar *accel_path,
                                                 guint accel_key,
                                                 GdkModifierType accel_mods,
                                                 gboolean changed);



void gtk_accel_map_add_entry (const gchar *accel_path,
                                         guint accel_key,
                                         GdkModifierType accel_mods);
gboolean gtk_accel_map_lookup_entry (const gchar *accel_path,
                                         GtkAccelKey *key);
gboolean gtk_accel_map_change_entry (const gchar *accel_path,
                                         guint accel_key,
                                         GdkModifierType accel_mods,
                                         gboolean replace);
void gtk_accel_map_load (const gchar *file_name);
void gtk_accel_map_save (const gchar *file_name);
void gtk_accel_map_foreach (gpointer data,
                                         GtkAccelMapForeach foreach_func);
void gtk_accel_map_load_fd (gint fd);
void gtk_accel_map_load_scanner (GScanner *scanner);
void gtk_accel_map_save_fd (gint fd);



void gtk_accel_map_add_filter (const gchar *filter_pattern);
void gtk_accel_map_foreach_unfiltered (gpointer data,
                                          GtkAccelMapForeach foreach_func);



void _gtk_accel_map_init (void);

void _gtk_accel_map_add_group (const gchar *accel_path,
                                                  GtkAccelGroup *accel_group);
void _gtk_accel_map_remove_group (const gchar *accel_path,
                                                  GtkAccelGroup *accel_group);
gboolean _gtk_accel_path_is_valid (const gchar *accel_path);



# 35 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkaccessible.h" 1 3 4
# 23 "/usr/include/gtk-2.0/gtk/gtkaccessible.h" 3 4
# 1 "/usr/include/atk-1.0/atk/atk.h" 1 3 4
# 24 "/usr/include/atk-1.0/atk/atk.h" 3 4
# 1 "/usr/include/atk-1.0/atk/atkaction.h" 1 3 4
# 45 "/usr/include/atk-1.0/atk/atkaction.h" 3 4
typedef struct _AtkAction AtkAction;

typedef struct _AtkActionIface AtkActionIface;

struct _AtkActionIface
{
  GTypeInterface parent;

  gboolean (*do_action) (AtkAction *action,
                                                gint i);
  gint (*get_n_actions) (AtkAction *action);
  const gchar* (*get_description) (AtkAction *action,
                                                gint i);
  const gchar* (*get_name) (AtkAction *action,
                                                gint i);
  const gchar* (*get_keybinding) (AtkAction *action,
                                                gint i);
  gboolean (*set_description) (AtkAction *action,
                                                gint i,
                                                const gchar *desc);
  const gchar* (*get_localized_name)(AtkAction *action,
                                                gint i);
  AtkFunction pad2;
};

GType atk_action_get_type (void);
# 83 "/usr/include/atk-1.0/atk/atkaction.h" 3 4
gboolean atk_action_do_action (AtkAction *action,
                                            gint i);
gint atk_action_get_n_actions (AtkAction *action);
const gchar* atk_action_get_description (AtkAction *action,
                                                   gint i);
const gchar* atk_action_get_name (AtkAction *action,
                                                   gint i);
const gchar* atk_action_get_keybinding (AtkAction *action,
                                                   gint i);
gboolean atk_action_set_description (AtkAction *action,
                                                   gint i,
                                                   const gchar *desc);



const gchar* atk_action_get_localized_name (AtkAction *action,
                                                     gint i);
# 25 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkcomponent.h" 1 3 4
# 24 "/usr/include/atk-1.0/atk/atkcomponent.h" 3 4
# 1 "/usr/include/atk-1.0/atk/atkutil.h" 1 3 4
# 39 "/usr/include/atk-1.0/atk/atkutil.h" 3 4
typedef struct _AtkUtil AtkUtil;
typedef struct _AtkUtilClass AtkUtilClass;
typedef struct _AtkKeyEventStruct AtkKeyEventStruct;






typedef void (*AtkEventListener) (AtkObject*);
typedef void (*AtkEventListenerInit) (void);
typedef gint (*AtkKeySnoopFunc) (AtkKeyEventStruct *event,
                                   gpointer func_data);

struct _AtkKeyEventStruct {
  gint type;
  guint state;
  guint keyval;
  gint length;
  gchar *string;
  guint16 keycode;
  guint32 timestamp;
};
# 71 "/usr/include/atk-1.0/atk/atkutil.h" 3 4
typedef enum
{
  ATK_KEY_EVENT_PRESS,
  ATK_KEY_EVENT_RELEASE,
  ATK_KEY_EVENT_LAST_DEFINED
} AtkKeyEventType;

struct _AtkUtil
{
  GObject parent;
};

struct _AtkUtilClass
{
   GObjectClass parent;
   guint (* add_global_event_listener) (GSignalEmissionHook listener,
                                                  const gchar *event_type);
   void (* remove_global_event_listener) (guint listener_id);
   guint (* add_key_event_listener) (AtkKeySnoopFunc listener,
                                                  gpointer data);
   void (* remove_key_event_listener) (guint listener_id);
   AtkObject* (* get_root) (void);
   const gchar* (* get_toolkit_name) (void);
   const gchar* (* get_toolkit_version) (void);
};
GType atk_util_get_type (void);
# 107 "/usr/include/atk-1.0/atk/atkutil.h" 3 4
typedef enum {
  ATK_XY_SCREEN,
  ATK_XY_WINDOW
}AtkCoordType;





guint atk_add_focus_tracker (AtkEventListener focus_tracker);





void atk_remove_focus_tracker (guint tracker_id);







void atk_focus_tracker_init (AtkEventListenerInit add_function);





void atk_focus_tracker_notify (AtkObject *object);





guint atk_add_global_event_listener (GSignalEmissionHook listener,
                                       const gchar *event_type);




void atk_remove_global_event_listener (guint listener_id);





guint atk_add_key_event_listener (AtkKeySnoopFunc listener, gpointer data);




void atk_remove_key_event_listener (guint listener_id);




AtkObject* atk_get_root(void);




const gchar *atk_get_toolkit_name (void);




const gchar *atk_get_toolkit_version (void);
# 25 "/usr/include/atk-1.0/atk/atkcomponent.h" 2 3 4
# 44 "/usr/include/atk-1.0/atk/atkcomponent.h" 3 4
typedef struct _AtkComponent AtkComponent;

typedef struct _AtkComponentIface AtkComponentIface;

typedef void (*AtkFocusHandler) (AtkObject*, gboolean);


struct _AtkComponentIface
{
  GTypeInterface parent;

  guint (* add_focus_handler) (AtkComponent *component,
                                         AtkFocusHandler handler);

  gboolean (* contains) (AtkComponent *component,
                                         gint x,
                                         gint y,
                                         AtkCoordType coord_type);

  AtkObject* (* ref_accessible_at_point) (AtkComponent *component,
                                         gint x,
                                         gint y,
                                         AtkCoordType coord_type);
  void (* get_extents) (AtkComponent *component,
                                         gint *x,
                                         gint *y,
                                         gint *width,
                                         gint *height,
                                         AtkCoordType coord_type);
  void (* get_position) (AtkComponent *component,
                                                 gint *x,
                                                 gint *y,
                                                 AtkCoordType coord_type);
  void (* get_size) (AtkComponent *component,
                                                         gint *width,
                                                         gint *height);
  gboolean (* grab_focus) (AtkComponent *component);
  void (* remove_focus_handler) (AtkComponent *component,
                                                          guint handler_id);
  gboolean (* set_extents) (AtkComponent *component,
                                                 gint x,
                                                 gint y,
                                                 gint width,
                                                 gint height,
                                                 AtkCoordType coord_type);
  gboolean (* set_position) (AtkComponent *component,
                                                 gint x,
                                                 gint y,
                                                 AtkCoordType coord_type);
  gboolean (* set_size) (AtkComponent *component,
                                                 gint width,
                                                 gint height);

  AtkLayer (* get_layer) (AtkComponent *component);
  gint (* get_mdi_zorder) (AtkComponent *component);

  AtkFunction pad1;
  AtkFunction pad2;
};

GType atk_component_get_type (void);



guint atk_component_add_focus_handler (AtkComponent *component,
                                                           AtkFocusHandler handler);
gboolean atk_component_contains (AtkComponent *component,
                                                            gint x,
                                                            gint y,
                                                            AtkCoordType coord_type);
AtkObject* atk_component_ref_accessible_at_point(AtkComponent *component,
                                                            gint x,
                                                            gint y,
                                                            AtkCoordType coord_type);
void atk_component_get_extents (AtkComponent *component,
                                                            gint *x,
                                                            gint *y,
                                                            gint *width,
                                                            gint *height,
                                                            AtkCoordType coord_type);
void atk_component_get_position (AtkComponent *component,
                                                            gint *x,
                                                            gint *y,
                                                            AtkCoordType coord_type);
void atk_component_get_size (AtkComponent *component,
                                                            gint *width,
                                                            gint *height);
AtkLayer atk_component_get_layer (AtkComponent *component);
gint atk_component_get_mdi_zorder (AtkComponent *component);
gboolean atk_component_grab_focus (AtkComponent *component);
void atk_component_remove_focus_handler (AtkComponent *component,
                                                            guint handler_id);
gboolean atk_component_set_extents (AtkComponent *component,
                                                            gint x,
                                                            gint y,
                                                            gint width,
                                                            gint height,
                                                            AtkCoordType coord_type);
gboolean atk_component_set_position (AtkComponent *component,
                                                            gint x,
                                                            gint y,
                                                            AtkCoordType coord_type);
gboolean atk_component_set_size (AtkComponent *component,
                                                            gint width,
                                                            gint height);
# 26 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkdocument.h" 1 3 4
# 43 "/usr/include/atk-1.0/atk/atkdocument.h" 3 4
typedef struct _AtkDocument AtkDocument;

typedef struct _AtkDocumentIface AtkDocumentIface;

struct _AtkDocumentIface
{
  GTypeInterface parent;
  const gchar* ( *get_document_type) (AtkDocument *document);
  gpointer ( *get_document) (AtkDocument *document);

  AtkFunction pad1;
  AtkFunction pad2;
  AtkFunction pad3;
  AtkFunction pad4;
  AtkFunction pad5;
  AtkFunction pad6;
  AtkFunction pad7;
  AtkFunction pad8;
};

GType atk_document_get_type (void);

const gchar* atk_document_get_document_type (AtkDocument *document);
gpointer atk_document_get_document (AtkDocument *document);
# 27 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkeditabletext.h" 1 3 4
# 24 "/usr/include/atk-1.0/atk/atkeditabletext.h" 3 4
# 1 "/usr/include/atk-1.0/atk/atktext.h" 1 3 4
# 39 "/usr/include/atk-1.0/atk/atktext.h" 3 4
typedef GSList AtkAttributeSet;
# 51 "/usr/include/atk-1.0/atk/atktext.h" 3 4
typedef struct _AtkAttribute AtkAttribute;

struct _AtkAttribute {
  gchar* name;
  gchar* value;
};
# 92 "/usr/include/atk-1.0/atk/atktext.h" 3 4
typedef enum
{
  ATK_TEXT_ATTR_INVALID = 0,
  ATK_TEXT_ATTR_LEFT_MARGIN,
  ATK_TEXT_ATTR_RIGHT_MARGIN,
  ATK_TEXT_ATTR_INDENT,
  ATK_TEXT_ATTR_INVISIBLE,
  ATK_TEXT_ATTR_EDITABLE,
  ATK_TEXT_ATTR_PIXELS_ABOVE_LINES,
  ATK_TEXT_ATTR_PIXELS_BELOW_LINES,
  ATK_TEXT_ATTR_PIXELS_INSIDE_WRAP,
  ATK_TEXT_ATTR_BG_FULL_HEIGHT,
  ATK_TEXT_ATTR_RISE,
  ATK_TEXT_ATTR_UNDERLINE,
  ATK_TEXT_ATTR_STRIKETHROUGH,
  ATK_TEXT_ATTR_SIZE,
  ATK_TEXT_ATTR_SCALE,
  ATK_TEXT_ATTR_WEIGHT,
  ATK_TEXT_ATTR_LANGUAGE,
  ATK_TEXT_ATTR_FAMILY_NAME,
  ATK_TEXT_ATTR_BG_COLOR,
  ATK_TEXT_ATTR_FG_COLOR,
  ATK_TEXT_ATTR_BG_STIPPLE,
  ATK_TEXT_ATTR_FG_STIPPLE,
  ATK_TEXT_ATTR_WRAP_MODE,
  ATK_TEXT_ATTR_DIRECTION,
  ATK_TEXT_ATTR_JUSTIFICATION,
  ATK_TEXT_ATTR_STRETCH,
  ATK_TEXT_ATTR_VARIANT,
  ATK_TEXT_ATTR_STYLE,
  ATK_TEXT_ATTR_LAST_DEFINED
} AtkTextAttribute;

AtkTextAttribute atk_text_attribute_register (const gchar *name);
# 135 "/usr/include/atk-1.0/atk/atktext.h" 3 4
typedef struct _AtkText AtkText;

typedef struct _AtkTextIface AtkTextIface;
# 151 "/usr/include/atk-1.0/atk/atktext.h" 3 4
typedef enum {
  ATK_TEXT_BOUNDARY_CHAR,
  ATK_TEXT_BOUNDARY_WORD_START,
  ATK_TEXT_BOUNDARY_WORD_END,
  ATK_TEXT_BOUNDARY_SENTENCE_START,
  ATK_TEXT_BOUNDARY_SENTENCE_END,
  ATK_TEXT_BOUNDARY_LINE_START,
  ATK_TEXT_BOUNDARY_LINE_END
} AtkTextBoundary;

struct _AtkTextIface
{
  GTypeInterface parent;

  gchar* (* get_text) (AtkText *text,
                                                   gint start_offset,
                                                   gint end_offset);
  gchar* (* get_text_after_offset) (AtkText *text,
                                                   gint offset,
                                                   AtkTextBoundary boundary_type,
                                                   gint *start_offset,
                                                   gint *end_offset);
  gchar* (* get_text_at_offset) (AtkText *text,
                                                   gint offset,
                                                   AtkTextBoundary boundary_type,
                                                   gint *start_offset,
                                                   gint *end_offset);
  gunichar (* get_character_at_offset) (AtkText *text,
                                                   gint offset);
  gchar* (* get_text_before_offset) (AtkText *text,
                                                   gint offset,
                                                   AtkTextBoundary boundary_type,
                                                   gint *start_offset,
                                                   gint *end_offset);
  gint (* get_caret_offset) (AtkText *text);
  AtkAttributeSet* (* get_run_attributes) (AtkText *text,
                                                   gint offset,
                                                   gint *start_offset,
                                                   gint *end_offset);
  AtkAttributeSet* (* get_default_attributes) (AtkText *text);
  void (* get_character_extents) (AtkText *text,
                                                   gint offset,
                                                   gint *x,
                                                   gint *y,
                                                   gint *width,
                                                   gint *height,
                                                   AtkCoordType coords);
  gint (* get_character_count) (AtkText *text);
  gint (* get_offset_at_point) (AtkText *text,
                                                   gint x,
                                                   gint y,
                                                   AtkCoordType coords);
  gint (* get_n_selections) (AtkText *text);
  gchar* (* get_selection) (AtkText *text,
                                                   gint selection_num,
                                                   gint *start_offset,
                                                   gint *end_offset);
  gboolean (* add_selection) (AtkText *text,
                                                   gint start_offset,
                                                   gint end_offset);
  gboolean (* remove_selection) (AtkText *text,
                                                   gint selection_num);
  gboolean (* set_selection) (AtkText *text,
                                                   gint selection_num,
                                                   gint start_offset,
                                                   gint end_offset);
  gboolean (* set_caret_offset) (AtkText *text,
                                                   gint offset);




  void (* text_changed) (AtkText *text,
                                                   gint position,
                                                   gint length);
  void (* text_caret_moved) (AtkText *text,
                                                   gint location);
  void (* text_selection_changed) (AtkText *text);

  void (* text_attributes_changed) (AtkText *text);

  AtkFunction pad2;
  AtkFunction pad3;
  AtkFunction pad4;
};

GType atk_text_get_type (void);
# 247 "/usr/include/atk-1.0/atk/atktext.h" 3 4
gchar* atk_text_get_text (AtkText *text,
                                                           gint start_offset,
                                                           gint end_offset);
gunichar atk_text_get_character_at_offset (AtkText *text,
                                                           gint offset);
gchar* atk_text_get_text_after_offset (AtkText *text,
                                                           gint offset,
                                                           AtkTextBoundary boundary_type,
                                                           gint *start_offset,
                                                           gint *end_offset);
gchar* atk_text_get_text_at_offset (AtkText *text,
                                                           gint offset,
                                                           AtkTextBoundary boundary_type,
                                                           gint *start_offset,
                                                           gint *end_offset);
gchar* atk_text_get_text_before_offset (AtkText *text,
                                                           gint offset,
                                                           AtkTextBoundary boundary_type,
                                                           gint *start_offset,
                                                           gint *end_offset);
gint atk_text_get_caret_offset (AtkText *text);
void atk_text_get_character_extents (AtkText *text,
                                                           gint offset,
                                                           gint *x,
                                                           gint *y,
                                                           gint *width,
                                                           gint *height,
                                                           AtkCoordType coords);
AtkAttributeSet* atk_text_get_run_attributes (AtkText *text,
                                                           gint offset,
                                                           gint *start_offset,
                                                           gint *end_offset);
AtkAttributeSet* atk_text_get_default_attributes (AtkText *text);
gint atk_text_get_character_count (AtkText *text);
gint atk_text_get_offset_at_point (AtkText *text,
                                                           gint x,
                                                           gint y,
                                                           AtkCoordType coords);
gint atk_text_get_n_selections (AtkText *text);
gchar* atk_text_get_selection (AtkText *text,
                                                           gint selection_num,
                                                           gint *start_offset,
                                                           gint *end_offset);
gboolean atk_text_add_selection (AtkText *text,
                                                           gint start_offset,
                                                           gint end_offset);
gboolean atk_text_remove_selection (AtkText *text,
                                                           gint selection_num);
gboolean atk_text_set_selection (AtkText *text,
                                                           gint selection_num,
                                                           gint start_offset,
                                                           gint end_offset);
gboolean atk_text_set_caret_offset (AtkText *text,
                                                           gint offset);
void atk_attribute_set_free (AtkAttributeSet *attrib_set);
const gchar* atk_text_attribute_get_name (AtkTextAttribute attr);
AtkTextAttribute atk_text_attribute_for_name (const gchar *name);
const gchar* atk_text_attribute_get_value (AtkTextAttribute attr,
                                                           gint index_);
# 25 "/usr/include/atk-1.0/atk/atkeditabletext.h" 2 3 4
# 42 "/usr/include/atk-1.0/atk/atkeditabletext.h" 3 4
typedef struct _AtkEditableText AtkEditableText;

typedef struct _AtkEditableTextIface AtkEditableTextIface;

struct _AtkEditableTextIface
{
  GTypeInterface parent_interface;

  gboolean (* set_run_attributes) (AtkEditableText *text,
                                   AtkAttributeSet *attrib_set,
                                   gint start_offset,
                                   gint end_offset);
  void (* set_text_contents) (AtkEditableText *text,
                                   const gchar *string);
  void (* insert_text) (AtkEditableText *text,
                                   const gchar *string,
                                   gint length,
                                   gint *position);
  void (* copy_text) (AtkEditableText *text,
                                   gint start_pos,
                                   gint end_pos);
  void (* cut_text) (AtkEditableText *text,
                                   gint start_pos,
                                   gint end_pos);
  void (* delete_text) (AtkEditableText *text,
                                   gint start_pos,
                                   gint end_pos);
  void (* paste_text) (AtkEditableText *text,
                                   gint position);

  AtkFunction pad1;
  AtkFunction pad2;
};
GType atk_editable_text_get_type (void);


gboolean atk_editable_text_set_run_attributes (AtkEditableText *text,
                                               AtkAttributeSet *attrib_set,
                                               gint start_offset,
                                               gint end_offset);
void atk_editable_text_set_text_contents (AtkEditableText *text,
                                             const gchar *string);
void atk_editable_text_insert_text (AtkEditableText *text,
                                             const gchar *string,
                                             gint length,
                                             gint *position);
void atk_editable_text_copy_text (AtkEditableText *text,
                                             gint start_pos,
                                             gint end_pos);
void atk_editable_text_cut_text (AtkEditableText *text,
                                             gint start_pos,
                                             gint end_pos);
void atk_editable_text_delete_text (AtkEditableText *text,
                                             gint start_pos,
                                             gint end_pos);
void atk_editable_text_paste_text (AtkEditableText *text,
                                             gint position);
# 28 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h" 1 3 4
# 23 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h" 3 4
# 1 "/usr/include/atk-1.0/atk/atk.h" 1 3 4
# 24 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h" 2 3 4
# 41 "/usr/include/atk-1.0/atk/atkgobjectaccessible.h" 3 4
typedef struct _AtkGObjectAccessible AtkGObjectAccessible;
typedef struct _AtkGObjectAccessibleClass AtkGObjectAccessibleClass;

struct _AtkGObjectAccessible
{
  AtkObject parent;
};

GType atk_gobject_accessible_get_type (void);

struct _AtkGObjectAccessibleClass
{
  AtkObjectClass parent_class;

  AtkFunction pad1;
  AtkFunction pad2;
};

AtkObject *atk_gobject_accessible_for_object (GObject *obj);
GObject *atk_gobject_accessible_get_object (AtkGObjectAccessible *obj);
# 29 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkhyperlink.h" 1 3 4
# 41 "/usr/include/atk-1.0/atk/atkhyperlink.h" 3 4
typedef enum
{
  ATK_HYPERLINK_IS_INLINE = 1 << 0
} AtkHyperlinkStateFlags;
# 53 "/usr/include/atk-1.0/atk/atkhyperlink.h" 3 4
typedef struct _AtkHyperlink AtkHyperlink;
typedef struct _AtkHyperlinkClass AtkHyperlinkClass;

struct _AtkHyperlink
{
  GObject parent;
};

struct _AtkHyperlinkClass
{
  GObjectClass parent;





  gchar* (* get_uri) (AtkHyperlink *link_,
                                            gint i);




  AtkObject* (* get_object) (AtkHyperlink *link_,
                                            gint i);



  gint (* get_end_index) (AtkHyperlink *link_);




  gint (* get_start_index) (AtkHyperlink *link_);






  gboolean (* is_valid) (AtkHyperlink *link_);




  gint (* get_n_anchors) (AtkHyperlink *link_);







  guint (* link_state) (AtkHyperlink *link_);

  AtkFunction pad1;
  AtkFunction pad2;
  AtkFunction pad3;
};

GType atk_hyperlink_get_type (void);

gchar* atk_hyperlink_get_uri (AtkHyperlink *link_,
                                                     gint i);

AtkObject* atk_hyperlink_get_object (AtkHyperlink *link_,
                                                     gint i);

gint atk_hyperlink_get_end_index (AtkHyperlink *link_);

gint atk_hyperlink_get_start_index (AtkHyperlink *link_);

gboolean atk_hyperlink_is_valid (AtkHyperlink *link_);

gboolean atk_hyperlink_is_inline (AtkHyperlink *link_);

gint atk_hyperlink_get_n_anchors (AtkHyperlink *link_);
# 30 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkhypertext.h" 1 3 4
# 42 "/usr/include/atk-1.0/atk/atkhypertext.h" 3 4
typedef struct _AtkHypertext AtkHypertext;

typedef struct _AtkHypertextIface AtkHypertextIface;

struct _AtkHypertextIface
{
  GTypeInterface parent;

  AtkHyperlink*(* get_link) (AtkHypertext *hypertext,
                                             gint link_index);
  gint (* get_n_links) (AtkHypertext *hypertext);
  gint (* get_link_index) (AtkHypertext *hypertext,
                                             gint char_index);
  AtkFunction pad1;
  AtkFunction pad2;
  AtkFunction pad3;
  AtkFunction pad4;
};
GType atk_hypertext_get_type (void);

AtkHyperlink* atk_hypertext_get_link (AtkHypertext *hypertext,
                                            gint link_index);
gint atk_hypertext_get_n_links (AtkHypertext *hypertext);
gint atk_hypertext_get_link_index (AtkHypertext *hypertext,
                                            gint char_index);
# 31 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkimage.h" 1 3 4
# 43 "/usr/include/atk-1.0/atk/atkimage.h" 3 4
typedef struct _AtkImage AtkImage;

typedef struct _AtkImageIface AtkImageIface;

struct _AtkImageIface
{
  GTypeInterface parent;
  void ( *get_image_position) (AtkImage *image,
                                                   gint *x,
                                                   gint *y,
                                                   AtkCoordType coord_type);
  const gchar* ( *get_image_description) (AtkImage *image);
  void ( *get_image_size) (AtkImage *image,
                                                   gint *width,
                                                   gint *height);
  gboolean ( *set_image_description) (AtkImage *image,
                                                   const gchar *description);

  AtkFunction pad1;
  AtkFunction pad2;
};

GType atk_image_get_type (void);

const gchar* atk_image_get_image_description (AtkImage *image);

void atk_image_get_image_size (AtkImage *image,
                                          gint *width,
                                          gint *height);

gboolean atk_image_set_image_description (AtkImage *image,
                                          const gchar *description);
void atk_image_get_image_position (AtkImage *image,
                                          gint *x,
                                          gint *y,
                                          AtkCoordType coord_type);
# 32 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atknoopobject.h" 1 3 4
# 23 "/usr/include/atk-1.0/atk/atknoopobject.h" 3 4

# 32 "/usr/include/atk-1.0/atk/atknoopobject.h" 3 4
typedef struct _AtkNoOpObject AtkNoOpObject;
typedef struct _AtkNoOpObjectClass AtkNoOpObjectClass;

struct _AtkNoOpObject
{
  AtkObject parent;
};

GType atk_no_op_object_get_type (void);

struct _AtkNoOpObjectClass
{
  AtkObjectClass parent_class;
};

AtkObject *atk_no_op_object_new (GObject *obj);


# 33 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h" 1 3 4
# 23 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h" 3 4
# 1 "/usr/include/atk-1.0/atk/atkobjectfactory.h" 1 3 4
# 37 "/usr/include/atk-1.0/atk/atkobjectfactory.h" 3 4
typedef struct _AtkObjectFactory AtkObjectFactory;
typedef struct _AtkObjectFactoryClass AtkObjectFactoryClass;

struct _AtkObjectFactory
{
  GObject parent;
};

struct _AtkObjectFactoryClass
{
  GObjectClass parent_class;

  AtkObject* (* create_accessible) (GObject *obj);
  void (* invalidate) (AtkObjectFactory *factory);
  GType (* get_accessible_type) (void);

  AtkFunction pad1;
  AtkFunction pad2;
};

GType atk_object_factory_get_type(void);

AtkObject* atk_object_factory_create_accessible (AtkObjectFactory *factory, GObject *obj);
void atk_object_factory_invalidate (AtkObjectFactory *factory);
GType atk_object_factory_get_accessible_type (AtkObjectFactory *factory);
# 24 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h" 2 3 4
# 36 "/usr/include/atk-1.0/atk/atknoopobjectfactory.h" 3 4
typedef struct _AtkNoOpObjectFactory AtkNoOpObjectFactory;
typedef struct _AtkNoOpObjectFactoryClass AtkNoOpObjectFactoryClass;

struct _AtkNoOpObjectFactory
{
  AtkObjectFactory parent;
};

struct _AtkNoOpObjectFactoryClass
{
  AtkObjectFactoryClass parent_class;
};

GType atk_no_op_object_factory_get_type(void);

AtkObjectFactory *atk_no_op_object_factory_new(void);
# 34 "/usr/include/atk-1.0/atk/atk.h" 2 3 4

# 1 "/usr/include/atk-1.0/atk/atkregistry.h" 1 3 4
# 37 "/usr/include/atk-1.0/atk/atkregistry.h" 3 4
struct _AtkRegistry
{
  GObject parent;
  GHashTable *factory_type_registry;
  GHashTable *factory_singleton_cache;
};

struct _AtkRegistryClass
{
  GObjectClass parent_class;
};

typedef struct _AtkRegistry AtkRegistry;
typedef struct _AtkRegistryClass AtkRegistryClass;


GType atk_registry_get_type (void);
void atk_registry_set_factory_type (AtkRegistry *registry,
                                                 GType type,
                                                 GType factory_type);
GType atk_registry_get_factory_type (AtkRegistry *registry,
                                                 GType type);
AtkObjectFactory* atk_registry_get_factory (AtkRegistry *registry,
                                                 GType type);

AtkRegistry* atk_get_default_registry (void);
# 36 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkrelation.h" 1 3 4
# 43 "/usr/include/atk-1.0/atk/atkrelation.h" 3 4
typedef struct _AtkRelation AtkRelation;
typedef struct _AtkRelationClass AtkRelationClass;

struct _AtkRelation
{
  GObject parent;

  GPtrArray *target;
  AtkRelationType relationship;
};

struct _AtkRelationClass
{
  GObjectClass parent;
};

GType atk_relation_get_type (void);

AtkRelationType atk_relation_type_register (const gchar *name);
const gchar* atk_relation_type_get_name (AtkRelationType type);
AtkRelationType atk_relation_type_for_name (const gchar *name);





AtkRelation* atk_relation_new (AtkObject **targets,
                                                       gint n_targets,
                                                       AtkRelationType relationship);



AtkRelationType atk_relation_get_relation_type (AtkRelation *relation);



GPtrArray* atk_relation_get_target (AtkRelation *relation);
# 37 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkrelationset.h" 1 3 4
# 38 "/usr/include/atk-1.0/atk/atkrelationset.h" 3 4
typedef struct _AtkRelationSetClass AtkRelationSetClass;


struct _AtkRelationSet
{
  GObject parent;

  GPtrArray *relations;
};

struct _AtkRelationSetClass
{
  GObjectClass parent;

  AtkFunction pad1;
  AtkFunction pad2;
};

GType atk_relation_set_get_type (void);

AtkRelationSet* atk_relation_set_new (void);
gboolean atk_relation_set_contains (AtkRelationSet *set,
                                                       AtkRelationType relationship);
void atk_relation_set_remove (AtkRelationSet *set,
                                                       AtkRelation *relation);
void atk_relation_set_add (AtkRelationSet *set,
                                                       AtkRelation *relation);
gint atk_relation_set_get_n_relations (AtkRelationSet *set);
AtkRelation* atk_relation_set_get_relation (AtkRelationSet *set,
                                                       gint i);
AtkRelation* atk_relation_set_get_relation_by_type (AtkRelationSet *set,
                                                       AtkRelationType relationship);
# 38 "/usr/include/atk-1.0/atk/atk.h" 2 3 4

# 1 "/usr/include/atk-1.0/atk/atkselection.h" 1 3 4
# 43 "/usr/include/atk-1.0/atk/atkselection.h" 3 4
typedef struct _AtkSelection AtkSelection;

typedef struct _AtkSelectionIface AtkSelectionIface;

struct _AtkSelectionIface
{
  GTypeInterface parent;

  gboolean (* add_selection) (AtkSelection *selection,
                                         gint i);
  gboolean (* clear_selection) (AtkSelection *selection);
  AtkObject* (* ref_selection) (AtkSelection *selection,
                                         gint i);
  gint (* get_selection_count) (AtkSelection *selection);
  gboolean (* is_child_selected) (AtkSelection *selection,
                                         gint i);
  gboolean (* remove_selection) (AtkSelection *selection,
                                         gint i);
  gboolean (* select_all_selection) (AtkSelection *selection);



  void (*selection_changed) (AtkSelection *selection);

  AtkFunction pad1;
  AtkFunction pad2;
};

GType atk_selection_get_type (void);

gboolean atk_selection_add_selection (AtkSelection *selection,
                                                 gint i);

gboolean atk_selection_clear_selection (AtkSelection *selection);

AtkObject* atk_selection_ref_selection (AtkSelection *selection,
                                                 gint i);

gint atk_selection_get_selection_count (AtkSelection *selection);

gboolean atk_selection_is_child_selected (AtkSelection *selection,
                                                 gint i);

gboolean atk_selection_remove_selection (AtkSelection *selection,
                                                 gint i);

gboolean atk_selection_select_all_selection (AtkSelection *selection);
# 40 "/usr/include/atk-1.0/atk/atk.h" 2 3 4

# 1 "/usr/include/atk-1.0/atk/atkstateset.h" 1 3 4
# 38 "/usr/include/atk-1.0/atk/atkstateset.h" 3 4
typedef struct _AtkStateSetClass AtkStateSetClass;


struct _AtkStateSet
{
  GObject parent;

};

struct _AtkStateSetClass
{
  GObjectClass parent;
};

GType atk_state_set_get_type (void);

AtkStateSet* atk_state_set_new (void);
gboolean atk_state_set_is_empty (AtkStateSet *set);
gboolean atk_state_set_add_state (AtkStateSet *set,
                                                 AtkStateType type);
void atk_state_set_add_states (AtkStateSet *set,
                                                 AtkStateType *types,
                                                 gint n_types);
void atk_state_set_clear_states (AtkStateSet *set);
gboolean atk_state_set_contains_state (AtkStateSet *set,
                                                 AtkStateType type);
gboolean atk_state_set_contains_states (AtkStateSet *set,
                                                 AtkStateType *types,
                                                 gint n_types);
gboolean atk_state_set_remove_state (AtkStateSet *set,
                                                 AtkStateType type);
AtkStateSet* atk_state_set_and_sets (AtkStateSet *set,
                                                 AtkStateSet *compare_set);
AtkStateSet* atk_state_set_or_sets (AtkStateSet *set,
                                                 AtkStateSet *compare_set);
AtkStateSet* atk_state_set_xor_sets (AtkStateSet *set,
                                                 AtkStateSet *compare_set);
# 42 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atkstreamablecontent.h" 1 3 4
# 36 "/usr/include/atk-1.0/atk/atkstreamablecontent.h" 3 4
typedef struct _AtkStreamableContent AtkStreamableContent;

typedef struct _AtkStreamableContentIface AtkStreamableContentIface;

struct _AtkStreamableContentIface
{
  GTypeInterface parent;




  gint (* get_n_mime_types) (AtkStreamableContent *streamable);
# 58 "/usr/include/atk-1.0/atk/atkstreamablecontent.h" 3 4
  const gchar* (* get_mime_type) (AtkStreamableContent *streamable,
                                                   gint i);






  GIOChannel* (* get_stream) (AtkStreamableContent *streamable,
                                                   const gchar *mime_type);

  AtkFunction pad1;
  AtkFunction pad2;
  AtkFunction pad3;
  AtkFunction pad4;
};
GType atk_streamable_content_get_type (void);

gint atk_streamable_content_get_n_mime_types (AtkStreamableContent *streamable);

const gchar* atk_streamable_content_get_mime_type (AtkStreamableContent *streamable,
                                                                gint i);
GIOChannel* atk_streamable_content_get_stream (AtkStreamableContent *streamable,
                                                                 const gchar *mime_type);
# 43 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 1 "/usr/include/atk-1.0/atk/atktable.h" 1 3 4
# 42 "/usr/include/atk-1.0/atk/atktable.h" 3 4
typedef struct _AtkTable AtkTable;

typedef struct _AtkTableIface AtkTableIface;

struct _AtkTableIface
{
  GTypeInterface parent;

  AtkObject* (* ref_at) (AtkTable *table,
                                                  gint row,
                                                  gint column);
  gint (* get_index_at) (AtkTable *table,
                                                  gint row,
                                                  gint column);
  gint (* get_column_at_index) (AtkTable *table,
                                                  gint index_);
  gint (* get_row_at_index) (AtkTable *table,
                                                  gint index_);
  gint (* get_n_columns) (AtkTable *table);
  gint (* get_n_rows) (AtkTable *table);
  gint (* get_column_extent_at) (AtkTable *table,
                                                  gint row,
                                                  gint column);
  gint (* get_row_extent_at) (AtkTable *table,
                                                  gint row,
                                                  gint column);
  AtkObject*
                    (* get_caption) (AtkTable *table);
  const gchar*
                    (* get_column_description) (AtkTable *table,
                                                  gint column);
  AtkObject* (* get_column_header) (AtkTable *table,
                                                  gint column);
  const gchar*
                    (* get_row_description) (AtkTable *table,
                                                  gint row);
  AtkObject* (* get_row_header) (AtkTable *table,
                                                  gint row);
  AtkObject* (* get_summary) (AtkTable *table);
  void (* set_caption) (AtkTable *table,
                                                  AtkObject *caption);
  void (* set_column_description) (AtkTable *table,
                                                  gint column,
                                                  const gchar *description);
  void (* set_column_header) (AtkTable *table,
                                                  gint column,
                                                  AtkObject *header);
  void (* set_row_description) (AtkTable *table,
                                                  gint row,
                                                  const gchar *description);
  void (* set_row_header) (AtkTable *table,
                                                  gint row,
                                                  AtkObject *header);
  void (* set_summary) (AtkTable *table,
                                                  AtkObject *accessible);
  gint (* get_selected_columns) (AtkTable *table,
                                                  gint **selected);
  gint (* get_selected_rows) (AtkTable *table,
                                                  gint **selected);
  gboolean (* is_column_selected) (AtkTable *table,
                                                  gint column);
  gboolean (* is_row_selected) (AtkTable *table,
                                                  gint row);
  gboolean (* is_selected) (AtkTable *table,
                                                  gint row,
                                                  gint column);
  gboolean (* add_row_selection) (AtkTable *table,
                                                  gint row);
  gboolean (* remove_row_selection) (AtkTable *table,
                                                  gint row);
  gboolean (* add_column_selection) (AtkTable *table,
                                                  gint column);
  gboolean (* remove_column_selection) (AtkTable *table,
                                                  gint column);




  void (* row_inserted) (AtkTable *table,
                                                  gint row,
                                                  gint num_inserted);
  void (* column_inserted) (AtkTable *table,
                                                  gint column,
                                                  gint num_inserted);
  void (* row_deleted) (AtkTable *table,
                                                  gint row,
                                                  gint num_deleted);
  void (* column_deleted) (AtkTable *table,
                                                  gint column,
                                                  gint num_deleted);
  void (* row_reordered) (AtkTable *table);
  void (* column_reordered) (AtkTable *table);
  void (* model_changed) (AtkTable *table);

  AtkFunction pad1;
  AtkFunction pad2;
  AtkFunction pad3;
  AtkFunction pad4;
};

GType atk_table_get_type (void);

AtkObject* atk_table_ref_at (AtkTable *table,
                                                  gint row,
                                                  gint column);
gint atk_table_get_index_at (AtkTable *table,
                                                  gint row,
                                                  gint column);
gint atk_table_get_column_at_index (AtkTable *table,
                                                  gint index_);
gint atk_table_get_row_at_index (AtkTable *table,
                                                  gint index_);
gint atk_table_get_n_columns (AtkTable *table);
gint atk_table_get_n_rows (AtkTable *table);
gint atk_table_get_column_extent_at (AtkTable *table,
                                                  gint row,
                                                  gint column);
gint atk_table_get_row_extent_at (AtkTable *table,
                                                  gint row,
                                                  gint column);
AtkObject*
                  atk_table_get_caption (AtkTable *table);
const gchar*
                  atk_table_get_column_description (AtkTable *table,
                                                  gint column);
AtkObject* atk_table_get_column_header (AtkTable *table,
                                                  gint column);
const gchar*
                  atk_table_get_row_description (AtkTable *table,
                                                  gint row);
AtkObject* atk_table_get_row_header (AtkTable *table,
                                                  gint row);
AtkObject* atk_table_get_summary (AtkTable *table);
void atk_table_set_caption (AtkTable *table,
                                                  AtkObject *caption);
void atk_table_set_column_description
                                                 (AtkTable *table,
                                                  gint column,
                                                  const gchar *description);
void atk_table_set_column_header (AtkTable *table,
                                                  gint column,
                                                  AtkObject *header);
void atk_table_set_row_description (AtkTable *table,
                                                  gint row,
                                                  const gchar *description);
void atk_table_set_row_header (AtkTable *table,
                                                  gint row,
                                                  AtkObject *header);
void atk_table_set_summary (AtkTable *table,
                                                  AtkObject *accessible);
gint atk_table_get_selected_columns (AtkTable *table,
                                                  gint **selected);
gint atk_table_get_selected_rows (AtkTable *table,
                                                  gint **selected);
gboolean atk_table_is_column_selected (AtkTable *table,
                                                  gint column);
gboolean atk_table_is_row_selected (AtkTable *table,
                                                  gint row);
gboolean atk_table_is_selected (AtkTable *table,
                                                  gint row,
                                                  gint column);
gboolean atk_table_add_row_selection (AtkTable *table,
                                                  gint row);
gboolean atk_table_remove_row_selection (AtkTable *table,
                                                  gint row);
gboolean atk_table_add_column_selection (AtkTable *table,
                                                  gint column);
gboolean atk_table_remove_column_selection
                                                 (AtkTable *table,
                                                  gint column);
# 44 "/usr/include/atk-1.0/atk/atk.h" 2 3 4


# 1 "/usr/include/atk-1.0/atk/atkvalue.h" 1 3 4
# 44 "/usr/include/atk-1.0/atk/atkvalue.h" 3 4
typedef struct _AtkValue AtkValue;

typedef struct _AtkValueIface AtkValueIface;

struct _AtkValueIface
{
  GTypeInterface parent;

  void (* get_current_value) (AtkValue *obj,
                                  GValue *value);
  void (* get_maximum_value) (AtkValue *obj,
                                  GValue *value);
  void (* get_minimum_value) (AtkValue *obj,
                                  GValue *value);
  gboolean (* set_current_value) (AtkValue *obj,
                                  const GValue *value);

  AtkFunction pad1;
  AtkFunction pad2;
};

GType atk_value_get_type (void);

void atk_value_get_current_value (AtkValue *obj,
                                       GValue *value);


void atk_value_get_maximum_value (AtkValue *obj,
                                       GValue *value);

void atk_value_get_minimum_value (AtkValue *obj,
                                       GValue *value);

gboolean atk_value_set_current_value (AtkValue *obj,
                                       const GValue *value);
# 47 "/usr/include/atk-1.0/atk/atk.h" 2 3 4
# 24 "/usr/include/gtk-2.0/gtk/gtkaccessible.h" 2 3 4
# 37 "/usr/include/gtk-2.0/gtk/gtkaccessible.h" 3 4
typedef struct _GtkAccessible GtkAccessible;
typedef struct _GtkAccessibleClass GtkAccessibleClass;





struct _GtkAccessible
{
  AtkObject parent;





  GtkWidget *widget;
};

struct _GtkAccessibleClass
{
  AtkObjectClass parent_class;

  void (*connect_widget_destroyed) (GtkAccessible *accessible);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_accessible_get_type (void);

void gtk_accessible_connect_widget_destroyed (GtkAccessible *accessible);
# 36 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkalignment.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkalignment.h" 3 4
typedef struct _GtkAlignment GtkAlignment;
typedef struct _GtkAlignmentClass GtkAlignmentClass;

struct _GtkAlignment
{
  GtkBin bin;

  gfloat xalign;
  gfloat yalign;
  gfloat xscale;
  gfloat yscale;
};

struct _GtkAlignmentClass
{
  GtkBinClass parent_class;
};


GType gtk_alignment_get_type (void) ;
GtkWidget* gtk_alignment_new (gfloat xalign,
                                     gfloat yalign,
                                     gfloat xscale,
                                     gfloat yscale);
void gtk_alignment_set (GtkAlignment *alignment,
                                     gfloat xalign,
                                     gfloat yalign,
                                     gfloat xscale,
                                     gfloat yscale);
# 38 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h" 1 3 4
# 33 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkframe.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkframe.h" 3 4
typedef struct _GtkFrame GtkFrame;
typedef struct _GtkFrameClass GtkFrameClass;

struct _GtkFrame
{
  GtkBin bin;

  GtkWidget *label_widget;
  gint16 shadow_type;
  gfloat label_xalign;
  gfloat label_yalign;

  GtkAllocation child_allocation;
};

struct _GtkFrameClass
{
  GtkBinClass parent_class;

  void (*compute_child_allocation) (GtkFrame *frame, GtkAllocation *allocation);
};


GType gtk_frame_get_type (void) ;
GtkWidget* gtk_frame_new (const gchar *label);

void gtk_frame_set_label (GtkFrame *frame,
                                           const gchar *label);
const gchar *gtk_frame_get_label (GtkFrame *frame);

void gtk_frame_set_label_widget (GtkFrame *frame,
                                       GtkWidget *label_widget);
GtkWidget *gtk_frame_get_label_widget (GtkFrame *frame);
void gtk_frame_set_label_align (GtkFrame *frame,
                                       gfloat xalign,
                                       gfloat yalign);
void gtk_frame_get_label_align (GtkFrame *frame,
                                       gfloat *xalign,
                                       gfloat *yalign);
void gtk_frame_set_shadow_type (GtkFrame *frame,
                                       GtkShadowType type);
GtkShadowType gtk_frame_get_shadow_type (GtkFrame *frame);
# 34 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkaspectframe.h" 3 4
typedef struct _GtkAspectFrame GtkAspectFrame;
typedef struct _GtkAspectFrameClass GtkAspectFrameClass;

struct _GtkAspectFrame
{
  GtkFrame frame;

  gfloat xalign;
  gfloat yalign;
  gfloat ratio;
  gboolean obey_child;

  GtkAllocation center_allocation;
};

struct _GtkAspectFrameClass
{
  GtkFrameClass parent_class;
};


GType gtk_aspect_frame_get_type (void) ;
GtkWidget* gtk_aspect_frame_new (const gchar *label,
                                        gfloat xalign,
                                        gfloat yalign,
                                        gfloat ratio,
                                        gboolean obey_child);
void gtk_aspect_frame_set (GtkAspectFrame *aspect_frame,
                                        gfloat xalign,
                                        gfloat yalign,
                                        gfloat ratio,
                                        gboolean obey_child);
# 39 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkarrow.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkarrow.h" 3 4
typedef struct _GtkArrow GtkArrow;
typedef struct _GtkArrowClass GtkArrowClass;

struct _GtkArrow
{
  GtkMisc misc;

  gint16 arrow_type;
  gint16 shadow_type;
};

struct _GtkArrowClass
{
  GtkMiscClass parent_class;
};


GType gtk_arrow_get_type (void) ;
GtkWidget* gtk_arrow_new (GtkArrowType arrow_type,
                                 GtkShadowType shadow_type);
void gtk_arrow_set (GtkArrow *arrow,
                                 GtkArrowType arrow_type,
                                 GtkShadowType shadow_type);
# 40 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkbindings.h" 1 3 4
# 47 "/usr/include/gtk-2.0/gtk/gtkbindings.h" 3 4
typedef struct _GtkBindingSet GtkBindingSet;
typedef struct _GtkBindingEntry GtkBindingEntry;
typedef struct _GtkBindingSignal GtkBindingSignal;
typedef struct _GtkBindingArg GtkBindingArg;

struct _GtkBindingSet
{
  gchar *set_name;
  gint priority;
  GSList *widget_path_pspecs;
  GSList *widget_class_pspecs;
  GSList *class_branch_pspecs;
  GtkBindingEntry *entries;
  GtkBindingEntry *current;
  guint parsed : 1;
};

struct _GtkBindingEntry
{


  guint keyval;
  GdkModifierType modifiers;

  GtkBindingSet *binding_set;
  guint destroyed : 1;
  guint in_emission : 1;
  GtkBindingEntry *set_next;
  GtkBindingEntry *hash_next;
  GtkBindingSignal *signals;
};

struct _GtkBindingSignal
{
  GtkBindingSignal *next;
  gchar *signal_name;
  guint n_args;
  GtkBindingArg *args;
};

struct _GtkBindingArg
{
  GType arg_type;
  union {
    glong long_data;
    gdouble double_data;
    gchar *string_data;
  } d;
};




GtkBindingSet* gtk_binding_set_new (const gchar *set_name);
GtkBindingSet* gtk_binding_set_by_class(gpointer object_class);
GtkBindingSet* gtk_binding_set_find (const gchar *set_name);
gboolean gtk_bindings_activate (GtkObject *object,
                                         guint keyval,
                                         GdkModifierType modifiers);
gboolean gtk_binding_set_activate (GtkBindingSet *binding_set,
                                         guint keyval,
                                         GdkModifierType modifiers,
                                         GtkObject *object);

void gtk_binding_entry_clear (GtkBindingSet *binding_set,
                                         guint keyval,
                                         GdkModifierType modifiers);
void gtk_binding_entry_add_signal (GtkBindingSet *binding_set,
                                         guint keyval,
                                         GdkModifierType modifiers,
                                         const gchar *signal_name,
                                         guint n_args,
                                         ...);
void gtk_binding_set_add_path (GtkBindingSet *binding_set,
                                         GtkPathType path_type,
                                         const gchar *path_pattern,
                                         GtkPathPriorityType priority);




void gtk_binding_entry_remove (GtkBindingSet *binding_set,
                                         guint keyval,
                                         GdkModifierType modifiers);
void gtk_binding_entry_add_signall (GtkBindingSet *binding_set,
                                         guint keyval,
                                         GdkModifierType modifiers,
                                         const gchar *signal_name,
                                         GSList *binding_args);
guint gtk_binding_parse_binding (GScanner *scanner);


gboolean _gtk_bindings_activate_event (GtkObject *object,
                                       GdkEventKey *event);
void _gtk_binding_reset_parsed (void);




guint _gtk_binding_signal_new (const gchar *signal_name,
                               GType itype,
                               GSignalFlags signal_flags,
                               GCallback handler,
                               GSignalAccumulator accumulator,
                               gpointer accu_data,
                               GSignalCMarshaller c_marshaller,
                               GType return_type,
                               guint n_params,
                               ...);
# 42 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkbox.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkbox.h" 3 4
typedef struct _GtkBox GtkBox;
typedef struct _GtkBoxClass GtkBoxClass;
typedef struct _GtkBoxChild GtkBoxChild;

struct _GtkBox
{
  GtkContainer container;


  GList *children;
  gint16 spacing;
  guint homogeneous : 1;
};

struct _GtkBoxClass
{
  GtkContainerClass parent_class;
};

struct _GtkBoxChild
{
  GtkWidget *widget;
  guint16 padding;
  guint expand : 1;
  guint fill : 1;
  guint pack : 1;
  guint is_secondary : 1;
};


GType gtk_box_get_type (void) ;
void gtk_box_pack_start (GtkBox *box,
                                        GtkWidget *child,
                                        gboolean expand,
                                        gboolean fill,
                                        guint padding);
void gtk_box_pack_end (GtkBox *box,
                                        GtkWidget *child,
                                        gboolean expand,
                                        gboolean fill,
                                        guint padding);
void gtk_box_pack_start_defaults (GtkBox *box,
                                        GtkWidget *widget);
void gtk_box_pack_end_defaults (GtkBox *box,
                                        GtkWidget *widget);
void gtk_box_set_homogeneous (GtkBox *box,
                                        gboolean homogeneous);
gboolean gtk_box_get_homogeneous (GtkBox *box);
void gtk_box_set_spacing (GtkBox *box,
                                        gint spacing);
gint gtk_box_get_spacing (GtkBox *box);
void gtk_box_reorder_child (GtkBox *box,
                                        GtkWidget *child,
                                        gint position);
void gtk_box_query_child_packing (GtkBox *box,
                                        GtkWidget *child,
                                        gboolean *expand,
                                        gboolean *fill,
                                        guint *padding,
                                        GtkPackType *pack_type);
void gtk_box_set_child_packing (GtkBox *box,
                                        GtkWidget *child,
                                        gboolean expand,
                                        gboolean fill,
                                        guint padding,
                                        GtkPackType pack_type);
# 43 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkbbox.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkbbox.h" 3 4
typedef struct _GtkButtonBox GtkButtonBox;
typedef struct _GtkButtonBoxClass GtkButtonBoxClass;

struct _GtkButtonBox
{
  GtkBox box;
  gint child_min_width;
  gint child_min_height;
  gint child_ipad_x;
  gint child_ipad_y;
  GtkButtonBoxStyle layout_style;
};

struct _GtkButtonBoxClass
{
  GtkBoxClass parent_class;
};


GType gtk_button_box_get_type (void) ;

GtkButtonBoxStyle gtk_button_box_get_layout (GtkButtonBox *widget);
void gtk_button_box_set_layout (GtkButtonBox *widget,
                                                      GtkButtonBoxStyle layout_style);
void gtk_button_box_set_child_secondary (GtkButtonBox *widget,
                                                      GtkWidget *child,
                                                      gboolean is_secondary);





void gtk_button_box_set_child_size (GtkButtonBox *widget,
                                        gint min_width,
                                        gint min_height);
void gtk_button_box_set_child_ipadding (GtkButtonBox *widget,
                                        gint ipad_x,
                                        gint ipad_y);
void gtk_button_box_get_child_size (GtkButtonBox *widget,
                                        gint *min_width,
                                        gint *min_height);
void gtk_button_box_get_child_ipadding (GtkButtonBox *widget,
                                        gint *ipad_x,
                                        gint *ipad_y);



void _gtk_button_box_child_requisition (GtkWidget *widget,
                                        int *nvis_children,
                                        int *nvis_secondaries,
                                        int *width,
                                        int *height);
# 44 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkbutton.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkbutton.h" 3 4
typedef struct _GtkButton GtkButton;
typedef struct _GtkButtonClass GtkButtonClass;

struct _GtkButton
{
  GtkBin bin;

  GdkWindow *event_window;

  gchar *label_text;

  guint activate_timeout;

  guint constructed : 1;
  guint in_button : 1;
  guint button_down : 1;
  guint relief : 2;
  guint use_underline : 1;
  guint use_stock : 1;
  guint depressed : 1;
  guint depress_on_activate : 1;
};

struct _GtkButtonClass
{
  GtkBinClass parent_class;

  void (* pressed) (GtkButton *button);
  void (* released) (GtkButton *button);
  void (* clicked) (GtkButton *button);
  void (* enter) (GtkButton *button);
  void (* leave) (GtkButton *button);
  void (* activate) (GtkButton *button);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_button_get_type (void) ;
GtkWidget* gtk_button_new (void);
GtkWidget* gtk_button_new_with_label (const gchar *label);
GtkWidget* gtk_button_new_from_stock (const gchar *stock_id);
GtkWidget* gtk_button_new_with_mnemonic (const gchar *label);
void gtk_button_pressed (GtkButton *button);
void gtk_button_released (GtkButton *button);
void gtk_button_clicked (GtkButton *button);
void gtk_button_enter (GtkButton *button);
void gtk_button_leave (GtkButton *button);
void gtk_button_set_relief (GtkButton *button,
                                             GtkReliefStyle newstyle);
GtkReliefStyle gtk_button_get_relief (GtkButton *button);

void gtk_button_set_label (GtkButton *button,
                                                    const gchar *label);
const gchar *gtk_button_get_label (GtkButton *button);
void gtk_button_set_use_underline (GtkButton *button,
                                                    gboolean use_underline);
gboolean gtk_button_get_use_underline (GtkButton *button);
void gtk_button_set_use_stock (GtkButton *button,
                                                    gboolean use_stock);
gboolean gtk_button_get_use_stock (GtkButton *button);

void _gtk_button_set_depressed (GtkButton *button,
                                gboolean depressed);
void _gtk_button_paint (GtkButton *button,
                                GdkRectangle *area,
                                GtkStateType state_type,
                                GtkShadowType shadow_type,
                                const gchar *main_detail,
                                const gchar *default_detail);
# 45 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcalendar.h" 1 3 4
# 36 "/usr/include/gtk-2.0/gtk/gtkcalendar.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtksignal.h" 1 3 4
# 33 "/usr/include/gtk-2.0/gtk/gtksignal.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkmarshal.h" 1 3 4










extern void gtk_marshal_BOOLEAN__VOID (GClosure *closure,
                                       GValue *return_value,
                                       guint n_param_values,
                                       const GValue *param_values,
                                       gpointer invocation_hint,
                                       gpointer marshal_data);



extern void gtk_marshal_BOOLEAN__POINTER (GClosure *closure,
                                          GValue *return_value,
                                          guint n_param_values,
                                          const GValue *param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data);



extern void gtk_marshal_BOOLEAN__POINTER_POINTER_INT_INT (GClosure *closure,
                                                          GValue *return_value,
                                                          guint n_param_values,
                                                          const GValue *param_values,
                                                          gpointer invocation_hint,
                                                          gpointer marshal_data);



extern void gtk_marshal_BOOLEAN__POINTER_INT_INT (GClosure *closure,
                                                  GValue *return_value,
                                                  guint n_param_values,
                                                  const GValue *param_values,
                                                  gpointer invocation_hint,
                                                  gpointer marshal_data);



extern void gtk_marshal_BOOLEAN__POINTER_INT_INT_UINT (GClosure *closure,
                                                       GValue *return_value,
                                                       guint n_param_values,
                                                       const GValue *param_values,
                                                       gpointer invocation_hint,
                                                       gpointer marshal_data);



extern void gtk_marshal_BOOLEAN__POINTER_STRING_STRING_POINTER (GClosure *closure,
                                                                GValue *return_value,
                                                                guint n_param_values,
                                                                const GValue *param_values,
                                                                gpointer invocation_hint,
                                                                gpointer marshal_data);



extern void gtk_marshal_ENUM__ENUM (GClosure *closure,
                                    GValue *return_value,
                                    guint n_param_values,
                                    const GValue *param_values,
                                    gpointer invocation_hint,
                                    gpointer marshal_data);


extern void gtk_marshal_INT__POINTER (GClosure *closure,
                                      GValue *return_value,
                                      guint n_param_values,
                                      const GValue *param_values,
                                      gpointer invocation_hint,
                                      gpointer marshal_data);


extern void gtk_marshal_INT__POINTER_CHAR_CHAR (GClosure *closure,
                                                GValue *return_value,
                                                guint n_param_values,
                                                const GValue *param_values,
                                                gpointer invocation_hint,
                                                gpointer marshal_data);
# 101 "/usr/include/gtk-2.0/gtk/gtkmarshal.h" 3 4
extern void gtk_marshal_VOID__ENUM_FLOAT (GClosure *closure,
                                          GValue *return_value,
                                          guint n_param_values,
                                          const GValue *param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data);



extern void gtk_marshal_VOID__ENUM_FLOAT_BOOLEAN (GClosure *closure,
                                                  GValue *return_value,
                                                  guint n_param_values,
                                                  const GValue *param_values,
                                                  gpointer invocation_hint,
                                                  gpointer marshal_data);







extern void gtk_marshal_VOID__INT_INT (GClosure *closure,
                                       GValue *return_value,
                                       guint n_param_values,
                                       const GValue *param_values,
                                       gpointer invocation_hint,
                                       gpointer marshal_data);



extern void gtk_marshal_VOID__INT_INT_POINTER (GClosure *closure,
                                               GValue *return_value,
                                               guint n_param_values,
                                               const GValue *param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data);
# 153 "/usr/include/gtk-2.0/gtk/gtkmarshal.h" 3 4
extern void gtk_marshal_VOID__POINTER_INT (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);



extern void gtk_marshal_VOID__POINTER_POINTER (GClosure *closure,
                                               GValue *return_value,
                                               guint n_param_values,
                                               const GValue *param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data);



extern void gtk_marshal_VOID__POINTER_POINTER_POINTER (GClosure *closure,
                                                       GValue *return_value,
                                                       guint n_param_values,
                                                       const GValue *param_values,
                                                       gpointer invocation_hint,
                                                       gpointer marshal_data);



extern void gtk_marshal_VOID__POINTER_STRING_STRING (GClosure *closure,
                                                     GValue *return_value,
                                                     guint n_param_values,
                                                     const GValue *param_values,
                                                     gpointer invocation_hint,
                                                     gpointer marshal_data);



extern void gtk_marshal_VOID__POINTER_UINT (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);



extern void gtk_marshal_VOID__POINTER_UINT_ENUM (GClosure *closure,
                                                 GValue *return_value,
                                                 guint n_param_values,
                                                 const GValue *param_values,
                                                 gpointer invocation_hint,
                                                 gpointer marshal_data);



extern void gtk_marshal_VOID__POINTER_POINTER_UINT_UINT (GClosure *closure,
                                                         GValue *return_value,
                                                         guint n_param_values,
                                                         const GValue *param_values,
                                                         gpointer invocation_hint,
                                                         gpointer marshal_data);



extern void gtk_marshal_VOID__POINTER_INT_INT_POINTER_UINT_UINT (GClosure *closure,
                                                                 GValue *return_value,
                                                                 guint n_param_values,
                                                                 const GValue *param_values,
                                                                 gpointer invocation_hint,
                                                                 gpointer marshal_data);



extern void gtk_marshal_VOID__POINTER_UINT_UINT (GClosure *closure,
                                                 GValue *return_value,
                                                 guint n_param_values,
                                                 const GValue *param_values,
                                                 gpointer invocation_hint,
                                                 gpointer marshal_data);
# 240 "/usr/include/gtk-2.0/gtk/gtkmarshal.h" 3 4
extern void gtk_marshal_VOID__STRING_INT_POINTER (GClosure *closure,
                                                  GValue *return_value,
                                                  guint n_param_values,
                                                  const GValue *param_values,
                                                  gpointer invocation_hint,
                                                  gpointer marshal_data);







extern void gtk_marshal_VOID__UINT_POINTER_UINT_ENUM_ENUM_POINTER (GClosure *closure,
                                                                   GValue *return_value,
                                                                   guint n_param_values,
                                                                   const GValue *param_values,
                                                                   gpointer invocation_hint,
                                                                   gpointer marshal_data);



extern void gtk_marshal_VOID__UINT_POINTER_UINT_UINT_ENUM (GClosure *closure,
                                                           GValue *return_value,
                                                           guint n_param_values,
                                                           const GValue *param_values,
                                                           gpointer invocation_hint,
                                                           gpointer marshal_data);



extern void gtk_marshal_VOID__UINT_STRING (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);



# 34 "/usr/include/gtk-2.0/gtk/gtksignal.h" 2 3 4


# 94 "/usr/include/gtk-2.0/gtk/gtksignal.h" 3 4
guint gtk_signal_newv (const gchar *name,
                                                 GtkSignalRunType signal_flags,
                                                 GtkType object_type,
                                                 guint function_offset,
                                                 GtkSignalMarshaller marshaller,
                                                 GtkType return_val,
                                                 guint n_args,
                                                 GtkType *args);
guint gtk_signal_new (const gchar *name,
                                                 GtkSignalRunType signal_flags,
                                                 GtkType object_type,
                                                 guint function_offset,
                                                 GtkSignalMarshaller marshaller,
                                                 GtkType return_val,
                                                 guint n_args,
                                                 ...);
void gtk_signal_emit_stop_by_name (GtkObject *object,
                                                 const gchar *name);
void gtk_signal_connect_object_while_alive (GtkObject *object,
                                                 const gchar *name,
                                                 GtkSignalFunc func,
                                                 GtkObject *alive_object);
void gtk_signal_connect_while_alive (GtkObject *object,
                                                 const gchar *name,
                                                 GtkSignalFunc func,
                                                 gpointer func_data,
                                                 GtkObject *alive_object);
gulong gtk_signal_connect_full (GtkObject *object,
                                                 const gchar *name,
                                                 GtkSignalFunc func,
                                                 GtkCallbackMarshal unsupported,
                                                 gpointer data,
                                                 GtkDestroyNotify destroy_func,
                                                 gint object_signal,
                                                 gint after);
void gtk_signal_emitv (GtkObject *object,
                                                 guint signal_id,
                                                 GtkArg *args);
void gtk_signal_emit (GtkObject *object,
                                                 guint signal_id,
                                                 ...);
void gtk_signal_emit_by_name (GtkObject *object,
                                                 const gchar *name,
                                                 ...);
void gtk_signal_emitv_by_name (GtkObject *object,
                                                 const gchar *name,
                                                 GtkArg *args);
void gtk_signal_compat_matched (GtkObject *object,
                                                 GtkSignalFunc func,
                                                 gpointer data,
                                                 GSignalMatchType match,
                                                 guint action);




# 37 "/usr/include/gtk-2.0/gtk/gtkcalendar.h" 2 3 4
# 52 "/usr/include/gtk-2.0/gtk/gtkcalendar.h" 3 4
typedef struct _GtkCalendar GtkCalendar;
typedef struct _GtkCalendarClass GtkCalendarClass;

typedef enum
{
  GTK_CALENDAR_SHOW_HEADING = 1 << 0,
  GTK_CALENDAR_SHOW_DAY_NAMES = 1 << 1,
  GTK_CALENDAR_NO_MONTH_CHANGE = 1 << 2,
  GTK_CALENDAR_SHOW_WEEK_NUMBERS = 1 << 3,
  GTK_CALENDAR_WEEK_START_MONDAY = 1 << 4
} GtkCalendarDisplayOptions;

struct _GtkCalendar
{
  GtkWidget widget;

  GtkStyle *header_style;
  GtkStyle *label_style;

  gint month;
  gint year;
  gint selected_day;

  gint day_month[6][7];
  gint day[6][7];

  gint num_marked_dates;
  gint marked_date[31];
  GtkCalendarDisplayOptions display_flags;
  GdkColor marked_date_color[31];

  GdkGC *gc;
  GdkGC *xor_gc;

  gint focus_row;
  gint focus_col;

  gint highlight_row;
  gint highlight_col;

  gpointer private_data;
  gchar grow_space [32];


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

struct _GtkCalendarClass
{
  GtkWidgetClass parent_class;


  void (* month_changed) (GtkCalendar *calendar);
  void (* day_selected) (GtkCalendar *calendar);
  void (* day_selected_double_click) (GtkCalendar *calendar);
  void (* prev_month) (GtkCalendar *calendar);
  void (* next_month) (GtkCalendar *calendar);
  void (* prev_year) (GtkCalendar *calendar);
  void (* next_year) (GtkCalendar *calendar);

};


GType gtk_calendar_get_type (void) ;
GtkWidget* gtk_calendar_new (void);

gboolean gtk_calendar_select_month (GtkCalendar *calendar,
                                         guint month,
                                         guint year);
void gtk_calendar_select_day (GtkCalendar *calendar,
                                         guint day);

gboolean gtk_calendar_mark_day (GtkCalendar *calendar,
                                         guint day);
gboolean gtk_calendar_unmark_day (GtkCalendar *calendar,
                                         guint day);
void gtk_calendar_clear_marks (GtkCalendar *calendar);


void gtk_calendar_display_options (GtkCalendar *calendar,
                                         GtkCalendarDisplayOptions flags);

void gtk_calendar_get_date (GtkCalendar *calendar,
                                         guint *year,
                                         guint *month,
                                         guint *day);
void gtk_calendar_freeze (GtkCalendar *calendar);
void gtk_calendar_thaw (GtkCalendar *calendar);
# 46 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h" 1 3 4
# 25 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcelleditable.h" 1 3 4
# 25 "/usr/include/gtk-2.0/gtk/gtkcelleditable.h" 3 4








typedef struct _GtkCellEditable GtkCellEditable;
typedef struct _GtkCellEditableIface GtkCellEditableIface;

struct _GtkCellEditableIface
{
  GTypeInterface g_iface;


  void (* editing_done) (GtkCellEditable *cell_editable);
  void (* remove_widget) (GtkCellEditable *cell_editable);


  void (* start_editing) (GtkCellEditable *cell_editable,
                          GdkEvent *event);
};


GType gtk_cell_editable_get_type (void) ;

void gtk_cell_editable_start_editing (GtkCellEditable *cell_editable,
                                       GdkEvent *event);
void gtk_cell_editable_editing_done (GtkCellEditable *cell_editable);
void gtk_cell_editable_remove_widget (GtkCellEditable *cell_editable);



# 26 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h" 2 3 4



typedef enum
{
  GTK_CELL_RENDERER_SELECTED = 1 << 0,
  GTK_CELL_RENDERER_PRELIT = 1 << 1,
  GTK_CELL_RENDERER_INSENSITIVE = 1 << 2,

  GTK_CELL_RENDERER_SORTED = 1 << 3,
  GTK_CELL_RENDERER_FOCUSED = 1 << 4
} GtkCellRendererState;

typedef enum
{
  GTK_CELL_RENDERER_MODE_INERT,
  GTK_CELL_RENDERER_MODE_ACTIVATABLE,
  GTK_CELL_RENDERER_MODE_EDITABLE
} GtkCellRendererMode;
# 53 "/usr/include/gtk-2.0/gtk/gtkcellrenderer.h" 3 4
typedef struct _GtkCellRenderer GtkCellRenderer;
typedef struct _GtkCellRendererClass GtkCellRendererClass;

struct _GtkCellRenderer
{
  GtkObject parent;

  gfloat xalign;
  gfloat yalign;

  gint width;
  gint height;

  guint16 xpad;
  guint16 ypad;

  guint mode : 2;
  guint visible : 1;
  guint is_expander : 1;
  guint is_expanded : 1;
  guint cell_background_set : 1;
};

struct _GtkCellRendererClass
{
  GtkObjectClass parent_class;


  void (* get_size) (GtkCellRenderer *cell,
                                      GtkWidget *widget,
                                      GdkRectangle *cell_area,
                                      gint *x_offset,
                                      gint *y_offset,
                                      gint *width,
                                      gint *height);
  void (* render) (GtkCellRenderer *cell,
                                      GdkWindow *window,
                                      GtkWidget *widget,
                                      GdkRectangle *background_area,
                                      GdkRectangle *cell_area,
                                      GdkRectangle *expose_area,
                                      GtkCellRendererState flags);
  gboolean (* activate) (GtkCellRenderer *cell,
                                      GdkEvent *event,
                                      GtkWidget *widget,
                                      const gchar *path,
                                      GdkRectangle *background_area,
                                      GdkRectangle *cell_area,
                                      GtkCellRendererState flags);
  GtkCellEditable *(* start_editing) (GtkCellRenderer *cell,
                                      GdkEvent *event,
                                      GtkWidget *widget,
                                      const gchar *path,
                                      GdkRectangle *background_area,
                                      GdkRectangle *cell_area,
                                      GtkCellRendererState flags);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_cell_renderer_get_type (void) ;

void gtk_cell_renderer_get_size (GtkCellRenderer *cell,
                                                   GtkWidget *widget,
                                                   GdkRectangle *cell_area,
                                                   gint *x_offset,
                                                   gint *y_offset,
                                                   gint *width,
                                                   gint *height);
void gtk_cell_renderer_render (GtkCellRenderer *cell,
                                                   GdkWindow *window,
                                                   GtkWidget *widget,
                                                   GdkRectangle *background_area,
                                                   GdkRectangle *cell_area,
                                                   GdkRectangle *expose_area,
                                                   GtkCellRendererState flags);
gboolean gtk_cell_renderer_activate (GtkCellRenderer *cell,
                                                   GdkEvent *event,
                                                   GtkWidget *widget,
                                                   const gchar *path,
                                                   GdkRectangle *background_area,
                                                   GdkRectangle *cell_area,
                                                   GtkCellRendererState flags);
GtkCellEditable *gtk_cell_renderer_start_editing (GtkCellRenderer *cell,
                                                   GdkEvent *event,
                                                   GtkWidget *widget,
                                                   const gchar *path,
                                                   GdkRectangle *background_area,
                                                   GdkRectangle *cell_area,
                                                   GtkCellRendererState flags);
void gtk_cell_renderer_set_fixed_size (GtkCellRenderer *cell,
                                                   gint width,
                                                   gint height);
void gtk_cell_renderer_get_fixed_size (GtkCellRenderer *cell,
                                                   gint *width,
                                                   gint *height);




# 47 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h" 1 3 4
# 38 "/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h" 3 4
typedef struct _GtkCellRendererText GtkCellRendererText;
typedef struct _GtkCellRendererTextClass GtkCellRendererTextClass;

struct _GtkCellRendererText
{
  GtkCellRenderer parent;


  gchar *text;
  PangoFontDescription *font;
  gdouble font_scale;
  PangoColor foreground;
  PangoColor background;

  PangoAttrList *extra_attrs;

  PangoUnderline underline_style;

  gint rise;
  gint fixed_height_rows;

  guint strikethrough : 1;

  guint editable : 1;

  guint scale_set : 1;

  guint foreground_set : 1;
  guint background_set : 1;

  guint underline_set : 1;

  guint rise_set : 1;

  guint strikethrough_set : 1;

  guint editable_set : 1;
  guint calc_fixed_height : 1;
};

struct _GtkCellRendererTextClass
{
  GtkCellRendererClass parent_class;

  void (* edited) (GtkCellRendererText *cell_renderer_text,
                   const gchar *path,
                   const gchar *new_text);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_cell_renderer_text_get_type (void);
GtkCellRenderer *gtk_cell_renderer_text_new (void);

void gtk_cell_renderer_text_set_fixed_height_from_font (GtkCellRendererText *renderer,
                                                                    gint number_of_rows);
# 48 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h" 1 3 4
# 37 "/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h" 3 4
typedef struct _GtkCellRendererToggle GtkCellRendererToggle;
typedef struct _GtkCellRendererToggleClass GtkCellRendererToggleClass;

struct _GtkCellRendererToggle
{
  GtkCellRenderer parent;


  guint active : 1;
  guint activatable : 1;
  guint radio : 1;
};

struct _GtkCellRendererToggleClass
{
  GtkCellRendererClass parent_class;

  void (* toggled) (GtkCellRendererToggle *cell_renderer_toggle,
                    const gchar *path);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_cell_renderer_toggle_get_type (void);
GtkCellRenderer *gtk_cell_renderer_toggle_new (void);

gboolean gtk_cell_renderer_toggle_get_radio (GtkCellRendererToggle *toggle);
void gtk_cell_renderer_toggle_set_radio (GtkCellRendererToggle *toggle,
                                                     gboolean radio);

gboolean gtk_cell_renderer_toggle_get_active (GtkCellRendererToggle *toggle);
void gtk_cell_renderer_toggle_set_active (GtkCellRendererToggle *toggle,
                                                     gboolean setting);
# 49 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h" 1 3 4
# 37 "/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h" 3 4
typedef struct _GtkCellRendererPixbuf GtkCellRendererPixbuf;
typedef struct _GtkCellRendererPixbufClass GtkCellRendererPixbufClass;

struct _GtkCellRendererPixbuf
{
  GtkCellRenderer parent;


  GdkPixbuf *pixbuf;
  GdkPixbuf *pixbuf_expander_open;
  GdkPixbuf *pixbuf_expander_closed;
};

struct _GtkCellRendererPixbufClass
{
  GtkCellRendererClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_cell_renderer_pixbuf_get_type (void);
GtkCellRenderer *gtk_cell_renderer_pixbuf_new (void);
# 50 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktogglebutton.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtktogglebutton.h" 3 4
typedef struct _GtkToggleButton GtkToggleButton;
typedef struct _GtkToggleButtonClass GtkToggleButtonClass;

struct _GtkToggleButton
{
  GtkButton button;

  guint active : 1;
  guint draw_indicator : 1;
  guint inconsistent : 1;
};

struct _GtkToggleButtonClass
{
  GtkButtonClass parent_class;

  void (* toggled) (GtkToggleButton *toggle_button);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_toggle_button_get_type (void) ;

GtkWidget* gtk_toggle_button_new (void);
GtkWidget* gtk_toggle_button_new_with_label (const gchar *label);
GtkWidget* gtk_toggle_button_new_with_mnemonic (const gchar *label);
void gtk_toggle_button_set_mode (GtkToggleButton *toggle_button,
                                                gboolean draw_indicator);
gboolean gtk_toggle_button_get_mode (GtkToggleButton *toggle_button);
void gtk_toggle_button_set_active (GtkToggleButton *toggle_button,
                                                gboolean is_active);
gboolean gtk_toggle_button_get_active (GtkToggleButton *toggle_button);
void gtk_toggle_button_toggled (GtkToggleButton *toggle_button);
void gtk_toggle_button_set_inconsistent (GtkToggleButton *toggle_button,
                                                gboolean setting);
gboolean gtk_toggle_button_get_inconsistent (GtkToggleButton *toggle_button);
# 33 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkcheckbutton.h" 3 4
typedef struct _GtkCheckButton GtkCheckButton;
typedef struct _GtkCheckButtonClass GtkCheckButtonClass;

struct _GtkCheckButton
{
  GtkToggleButton toggle_button;
};

struct _GtkCheckButtonClass
{
  GtkToggleButtonClass parent_class;

  void (* draw_indicator) (GtkCheckButton *check_button,
                           GdkRectangle *area);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_check_button_get_type (void) ;
GtkWidget* gtk_check_button_new (void);
GtkWidget* gtk_check_button_new_with_label (const gchar *label);
GtkWidget* gtk_check_button_new_with_mnemonic (const gchar *label);

void _gtk_check_button_get_props (GtkCheckButton *check_button,
                                  gint *indicator_size,
                                  gint *indicator_spacing);
# 51 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkitem.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkitem.h" 3 4
typedef struct _GtkItem GtkItem;
typedef struct _GtkItemClass GtkItemClass;

struct _GtkItem
{
  GtkBin bin;
};

struct _GtkItemClass
{
  GtkBinClass parent_class;

  void (* select) (GtkItem *item);
  void (* deselect) (GtkItem *item);
  void (* toggle) (GtkItem *item);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_item_get_type (void) ;
void gtk_item_select (GtkItem *item);
void gtk_item_deselect (GtkItem *item);
void gtk_item_toggle (GtkItem *item);
# 33 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkmenuitem.h" 3 4
typedef struct _GtkMenuItem GtkMenuItem;
typedef struct _GtkMenuItemClass GtkMenuItemClass;

struct _GtkMenuItem
{
  GtkItem item;

  GtkWidget *submenu;
  GdkWindow *event_window;

  guint16 toggle_size;
  guint16 accelerator_width;
  gchar *accel_path;

  guint show_submenu_indicator : 1;
  guint submenu_placement : 1;
  guint submenu_direction : 1;
  guint right_justify: 1;
  guint timer_from_keypress : 1;
  guint timer;
};

struct _GtkMenuItemClass
{
  GtkItemClass parent_class;







  guint hide_on_activate : 1;

  void (* activate) (GtkMenuItem *menu_item);
  void (* activate_item) (GtkMenuItem *menu_item);
  void (* toggle_size_request) (GtkMenuItem *menu_item,
                                 gint *requisition);
  void (* toggle_size_allocate) (GtkMenuItem *menu_item,
                                 gint allocation);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_menu_item_get_type (void) ;
GtkWidget* gtk_menu_item_new (void);
GtkWidget* gtk_menu_item_new_with_label (const gchar *label);
GtkWidget* gtk_menu_item_new_with_mnemonic (const gchar *label);
void gtk_menu_item_set_submenu (GtkMenuItem *menu_item,
                                               GtkWidget *submenu);
GtkWidget* gtk_menu_item_get_submenu (GtkMenuItem *menu_item);
void gtk_menu_item_remove_submenu (GtkMenuItem *menu_item);
void gtk_menu_item_select (GtkMenuItem *menu_item);
void gtk_menu_item_deselect (GtkMenuItem *menu_item);
void gtk_menu_item_activate (GtkMenuItem *menu_item);
void gtk_menu_item_toggle_size_request (GtkMenuItem *menu_item,
                                               gint *requisition);
void gtk_menu_item_toggle_size_allocate (GtkMenuItem *menu_item,
                                               gint allocation);
void gtk_menu_item_set_right_justified (GtkMenuItem *menu_item,
                                               gboolean right_justified);
gboolean gtk_menu_item_get_right_justified (GtkMenuItem *menu_item);
void gtk_menu_item_set_accel_path (GtkMenuItem *menu_item,
                                               const gchar *accel_path);


void _gtk_menu_item_refresh_accel_path (GtkMenuItem *menu_item,
                                               const gchar *prefix,
                                               GtkAccelGroup *accel_group,
                                               gboolean group_changed);
gboolean _gtk_menu_item_is_selectable (GtkWidget *menu_item);
# 33 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h" 3 4
typedef struct _GtkCheckMenuItem GtkCheckMenuItem;
typedef struct _GtkCheckMenuItemClass GtkCheckMenuItemClass;

struct _GtkCheckMenuItem
{
  GtkMenuItem menu_item;

  guint active : 1;
  guint always_show_toggle : 1;
  guint inconsistent : 1;
};

struct _GtkCheckMenuItemClass
{
  GtkMenuItemClass parent_class;

  void (* toggled) (GtkCheckMenuItem *check_menu_item);
  void (* draw_indicator) (GtkCheckMenuItem *check_menu_item,
                           GdkRectangle *area);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_check_menu_item_get_type (void) ;
GtkWidget* gtk_check_menu_item_new (void);
GtkWidget* gtk_check_menu_item_new_with_label (const gchar *label);
GtkWidget* gtk_check_menu_item_new_with_mnemonic (const gchar *label);
void gtk_check_menu_item_set_active (GtkCheckMenuItem *check_menu_item,
                                                  gboolean is_active);
gboolean gtk_check_menu_item_get_active (GtkCheckMenuItem *check_menu_item);
void gtk_check_menu_item_toggled (GtkCheckMenuItem *check_menu_item);
void gtk_check_menu_item_set_inconsistent (GtkCheckMenuItem *check_menu_item,
                                                  gboolean setting);
gboolean gtk_check_menu_item_get_inconsistent (GtkCheckMenuItem *check_menu_item);



void gtk_check_menu_item_set_show_toggle (GtkCheckMenuItem *menu_item,
                                                gboolean always);
# 52 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkclipboard.h" 1 3 4
# 29 "/usr/include/gtk-2.0/gtk/gtkclipboard.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkselection.h" 1 3 4
# 39 "/usr/include/gtk-2.0/gtk/gtkselection.h" 3 4
typedef struct _GtkTargetList GtkTargetList;
typedef struct _GtkTargetEntry GtkTargetEntry;
# 55 "/usr/include/gtk-2.0/gtk/gtkselection.h" 3 4
struct _GtkSelectionData
{
  GdkAtom selection;
  GdkAtom target;
  GdkAtom type;
  gint format;
  guchar *data;
  gint length;
  GdkDisplay *display;
};

struct _GtkTargetEntry {
  gchar *target;
  guint flags;
  guint info;
};





typedef struct _GtkTargetPair GtkTargetPair;


struct _GtkTargetList {
  GList *list;
  guint ref_count;
};

struct _GtkTargetPair {
  GdkAtom target;
  guint flags;
  guint info;
};

GtkTargetList *gtk_target_list_new (const GtkTargetEntry *targets,
                                          guint ntargets);
void gtk_target_list_ref (GtkTargetList *list);
void gtk_target_list_unref (GtkTargetList *list);
void gtk_target_list_add (GtkTargetList *list,
                                          GdkAtom target,
                                          guint flags,
                                          guint info);
void gtk_target_list_add_table (GtkTargetList *list,
                                          const GtkTargetEntry *targets,
                                          guint ntargets);
void gtk_target_list_remove (GtkTargetList *list,
                                          GdkAtom target);
gboolean gtk_target_list_find (GtkTargetList *list,
                                          GdkAtom target,
                                          guint *info);



gboolean gtk_selection_owner_set (GtkWidget *widget,
                                              GdkAtom selection,
                                              guint32 time_);
gboolean gtk_selection_owner_set_for_display (GdkDisplay *display,
                                              GtkWidget *widget,
                                              GdkAtom selection,
                                              guint32 time_);

void gtk_selection_add_target (GtkWidget *widget,
                                      GdkAtom selection,
                                      GdkAtom target,
                                      guint info);
void gtk_selection_add_targets (GtkWidget *widget,
                                      GdkAtom selection,
                                      const GtkTargetEntry *targets,
                                      guint ntargets);
void gtk_selection_clear_targets (GtkWidget *widget,
                                      GdkAtom selection);
gboolean gtk_selection_convert (GtkWidget *widget,
                                      GdkAtom selection,
                                      GdkAtom target,
                                      guint32 time_);
void gtk_selection_data_set (GtkSelectionData *selection_data,
                                      GdkAtom type,
                                      gint format,
                                      const guchar *data,
                                      gint length);
gboolean gtk_selection_data_set_text (GtkSelectionData *selection_data,
                                      const gchar *str,
                                      gint len);
guchar * gtk_selection_data_get_text (GtkSelectionData *selection_data);

gboolean gtk_selection_data_get_targets (GtkSelectionData *selection_data,
                                                  GdkAtom **targets,
                                                  gint *n_atoms);
gboolean gtk_selection_data_targets_include_text (GtkSelectionData *selection_data);



void gtk_selection_remove_all (GtkWidget *widget);



gboolean gtk_selection_clear (GtkWidget *widget,
                                           GdkEventSelection *event);
gboolean _gtk_selection_request (GtkWidget *widget,
                                           GdkEventSelection *event);
gboolean _gtk_selection_incr_event (GdkWindow *window,
                                           GdkEventProperty *event);
gboolean _gtk_selection_notify (GtkWidget *widget,
                                           GdkEventSelection *event);
gboolean _gtk_selection_property_notify (GtkWidget *widget,
                                           GdkEventProperty *event);

GType gtk_selection_data_get_type (void);
GtkSelectionData *gtk_selection_data_copy (GtkSelectionData *data);
void gtk_selection_data_free (GtkSelectionData *data);
# 30 "/usr/include/gtk-2.0/gtk/gtkclipboard.h" 2 3 4





typedef void (* GtkClipboardReceivedFunc) (GtkClipboard *clipboard,
                                                  GtkSelectionData *selection_data,
                                                  gpointer data);
typedef void (* GtkClipboardTextReceivedFunc) (GtkClipboard *clipboard,
                                                  const gchar *text,
                                                  gpointer data);





typedef void (* GtkClipboardGetFunc) (GtkClipboard *clipboard,
                                               GtkSelectionData *selection_data,
                                               guint info,
                                               gpointer user_data_or_owner);
typedef void (* GtkClipboardClearFunc) (GtkClipboard *clipboard,
                                               gpointer user_data_or_owner);

GType gtk_clipboard_get_type (void);

GtkClipboard *gtk_clipboard_get_for_display (GdkDisplay *display,
                                             GdkAtom selection);

GtkClipboard *gtk_clipboard_get (GdkAtom selection);


GdkDisplay *gtk_clipboard_get_display (GtkClipboard *clipboard);


gboolean gtk_clipboard_set_with_data (GtkClipboard *clipboard,
                                       const GtkTargetEntry *targets,
                                       guint n_targets,
                                       GtkClipboardGetFunc get_func,
                                       GtkClipboardClearFunc clear_func,
                                       gpointer user_data);
gboolean gtk_clipboard_set_with_owner (GtkClipboard *clipboard,
                                       const GtkTargetEntry *targets,
                                       guint n_targets,
                                       GtkClipboardGetFunc get_func,
                                       GtkClipboardClearFunc clear_func,
                                       GObject *owner);
GObject *gtk_clipboard_get_owner (GtkClipboard *clipboard);
void gtk_clipboard_clear (GtkClipboard *clipboard);
void gtk_clipboard_set_text (GtkClipboard *clipboard,
                                       const gchar *text,
                                       gint len);

void gtk_clipboard_request_contents (GtkClipboard *clipboard,
                                     GdkAtom target,
                                     GtkClipboardReceivedFunc callback,
                                     gpointer user_data);
void gtk_clipboard_request_text (GtkClipboard *clipboard,
                                     GtkClipboardTextReceivedFunc callback,
                                     gpointer user_data);

GtkSelectionData *gtk_clipboard_wait_for_contents (GtkClipboard *clipboard,
                                                   GdkAtom target);
gchar * gtk_clipboard_wait_for_text (GtkClipboard *clipboard);

gboolean gtk_clipboard_wait_is_text_available (GtkClipboard *clipboard);
# 53 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkclist.h" 1 3 4
# 38 "/usr/include/gtk-2.0/gtk/gtkclist.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkrange.h" 1 3 4
# 49 "/usr/include/gtk-2.0/gtk/gtkrange.h" 3 4
typedef struct _GtkRangeLayout GtkRangeLayout;
typedef struct _GtkRangeStepTimer GtkRangeStepTimer;

typedef struct _GtkRange GtkRange;
typedef struct _GtkRangeClass GtkRangeClass;

struct _GtkRange
{
  GtkWidget widget;

  GtkAdjustment *adjustment;
  GtkUpdateType update_policy;
  guint inverted : 1;



  guint flippable : 1;





  guint has_stepper_a : 1;
  guint has_stepper_b : 1;
  guint has_stepper_c : 1;
  guint has_stepper_d : 1;

  guint need_recalc : 1;

  guint slider_size_fixed : 1;

  gint min_slider_size;

  GtkOrientation orientation;


  GdkRectangle range_rect;

  gint slider_start, slider_end;


  gint round_digits;


  guint trough_click_forward : 1;
  guint update_pending : 1;
  GtkRangeLayout *layout;
  GtkRangeStepTimer *timer;
  gint slide_initial_slider_position;
  gint slide_initial_coordinate;
  guint update_timeout_id;
  GdkWindow *event_window;
};

struct _GtkRangeClass
{
  GtkWidgetClass parent_class;


  gchar *slider_detail;
  gchar *stepper_detail;

  void (* value_changed) (GtkRange *range);
  void (* adjust_bounds) (GtkRange *range,
                             gdouble new_value);


  void (* move_slider) (GtkRange *range,
                             GtkScrollType scroll);


  void (* get_range_border) (GtkRange *range,
                             GtkBorder *border_);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_range_get_type (void) ;

void gtk_range_set_update_policy (GtkRange *range,
                                            GtkUpdateType policy);
GtkUpdateType gtk_range_get_update_policy (GtkRange *range);
void gtk_range_set_adjustment (GtkRange *range,
                                            GtkAdjustment *adjustment);
GtkAdjustment* gtk_range_get_adjustment (GtkRange *range);
void gtk_range_set_inverted (GtkRange *range,
                                            gboolean setting);
gboolean gtk_range_get_inverted (GtkRange *range);
void gtk_range_set_increments (GtkRange *range,
                                            gdouble step,
                                            gdouble page);
void gtk_range_set_range (GtkRange *range,
                                            gdouble min,
                                            gdouble max);
void gtk_range_set_value (GtkRange *range,
                                            gdouble value);
gdouble gtk_range_get_value (GtkRange *range);
# 33 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkscrollbar.h" 3 4
typedef struct _GtkScrollbar GtkScrollbar;
typedef struct _GtkScrollbarClass GtkScrollbarClass;

struct _GtkScrollbar
{
  GtkRange range;
};

struct _GtkScrollbarClass
{
  GtkRangeClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_scrollbar_get_type (void) ;
# 33 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkhscrollbar.h" 3 4
typedef struct _GtkHScrollbar GtkHScrollbar;
typedef struct _GtkHScrollbarClass GtkHScrollbarClass;

struct _GtkHScrollbar
{
  GtkScrollbar scrollbar;
};

struct _GtkHScrollbarClass
{
  GtkScrollbarClass parent_class;
};


GType gtk_hscrollbar_get_type (void) ;
GtkWidget* gtk_hscrollbar_new (GtkAdjustment *adjustment);
# 39 "/usr/include/gtk-2.0/gtk/gtkclist.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkvscrollbar.h" 1 3 4
# 43 "/usr/include/gtk-2.0/gtk/gtkvscrollbar.h" 3 4
typedef struct _GtkVScrollbar GtkVScrollbar;
typedef struct _GtkVScrollbarClass GtkVScrollbarClass;

struct _GtkVScrollbar
{
  GtkScrollbar scrollbar;
};

struct _GtkVScrollbarClass
{
  GtkScrollbarClass parent_class;
};







GType gtk_vscrollbar_get_type (void) ;
GtkWidget* gtk_vscrollbar_new (GtkAdjustment *adjustment);
# 40 "/usr/include/gtk-2.0/gtk/gtkclist.h" 2 3 4







enum {
  GTK_CLIST_IN_DRAG = 1 << 0,
  GTK_CLIST_ROW_HEIGHT_SET = 1 << 1,
  GTK_CLIST_SHOW_TITLES = 1 << 2,

  GTK_CLIST_ADD_MODE = 1 << 4,
  GTK_CLIST_AUTO_SORT = 1 << 5,
  GTK_CLIST_AUTO_RESIZE_BLOCKED = 1 << 6,
  GTK_CLIST_REORDERABLE = 1 << 7,
  GTK_CLIST_USE_DRAG_ICONS = 1 << 8,
  GTK_CLIST_DRAW_DRAG_LINE = 1 << 9,
  GTK_CLIST_DRAW_DRAG_RECT = 1 << 10
};


typedef enum
{
  GTK_CELL_EMPTY,
  GTK_CELL_TEXT,
  GTK_CELL_PIXMAP,
  GTK_CELL_PIXTEXT,
  GTK_CELL_WIDGET
} GtkCellType;

typedef enum
{
  GTK_CLIST_DRAG_NONE,
  GTK_CLIST_DRAG_BEFORE,
  GTK_CLIST_DRAG_INTO,
  GTK_CLIST_DRAG_AFTER
} GtkCListDragPos;

typedef enum
{
  GTK_BUTTON_IGNORED = 0,
  GTK_BUTTON_SELECTS = 1 << 0,
  GTK_BUTTON_DRAGS = 1 << 1,
  GTK_BUTTON_EXPANDS = 1 << 2
} GtkButtonAction;
# 118 "/usr/include/gtk-2.0/gtk/gtkclist.h" 3 4
typedef struct _GtkCList GtkCList;
typedef struct _GtkCListClass GtkCListClass;
typedef struct _GtkCListColumn GtkCListColumn;
typedef struct _GtkCListRow GtkCListRow;

typedef struct _GtkCell GtkCell;
typedef struct _GtkCellText GtkCellText;
typedef struct _GtkCellPixmap GtkCellPixmap;
typedef struct _GtkCellPixText GtkCellPixText;
typedef struct _GtkCellWidget GtkCellWidget;

typedef gint (*GtkCListCompareFunc) (GtkCList *clist,
                                     gconstpointer ptr1,
                                     gconstpointer ptr2);

typedef struct _GtkCListCellInfo GtkCListCellInfo;
typedef struct _GtkCListDestInfo GtkCListDestInfo;

struct _GtkCListCellInfo
{
  gint row;
  gint column;
};

struct _GtkCListDestInfo
{
  GtkCListCellInfo cell;
  GtkCListDragPos insert_pos;
};

struct _GtkCList
{
  GtkContainer container;

  guint16 flags;


  GMemChunk *row_mem_chunk;
  GMemChunk *cell_mem_chunk;

  guint freeze_count;



  GdkRectangle internal_allocation;


  gint rows;
  gint row_height;
  GList *row_list;
  GList *row_list_end;


  gint columns;
  GdkRectangle column_title_area;
  GdkWindow *title_window;


  GtkCListColumn *column;



  GdkWindow *clist_window;
  gint clist_window_width;
  gint clist_window_height;


  gint hoffset;
  gint voffset;


  GtkShadowType shadow_type;


  GtkSelectionMode selection_mode;


  GList *selection;
  GList *selection_end;

  GList *undo_selection;
  GList *undo_unselection;
  gint undo_anchor;


  guint8 button_actions[5];

  guint8 drag_button;


  GtkCListCellInfo click_cell;


  GtkAdjustment *hadjustment;
  GtkAdjustment *vadjustment;


  GdkGC *xor_gc;


  GdkGC *fg_gc;
  GdkGC *bg_gc;


  GdkCursor *cursor_drag;


  gint x_drag;


  gint focus_row;

  gint focus_header_column;


  gint anchor;
  GtkStateType anchor_state;
  gint drag_pos;
  gint htimer;
  gint vtimer;

  GtkSortType sort_type;
  GtkCListCompareFunc compare;
  gint sort_column;

  gint drag_highlight_row;
  GtkCListDragPos drag_highlight_pos;
};

struct _GtkCListClass
{
  GtkContainerClass parent_class;

  void (*set_scroll_adjustments) (GtkCList *clist,
                                   GtkAdjustment *hadjustment,
                                   GtkAdjustment *vadjustment);
  void (*refresh) (GtkCList *clist);
  void (*select_row) (GtkCList *clist,
                                 gint row,
                                 gint column,
                                 GdkEvent *event);
  void (*unselect_row) (GtkCList *clist,
                                 gint row,
                                 gint column,
                                 GdkEvent *event);
  void (*row_move) (GtkCList *clist,
                                 gint source_row,
                                 gint dest_row);
  void (*click_column) (GtkCList *clist,
                                 gint column);
  void (*resize_column) (GtkCList *clist,
                                 gint column,
                                 gint width);
  void (*toggle_focus_row) (GtkCList *clist);
  void (*select_all) (GtkCList *clist);
  void (*unselect_all) (GtkCList *clist);
  void (*undo_selection) (GtkCList *clist);
  void (*start_selection) (GtkCList *clist);
  void (*end_selection) (GtkCList *clist);
  void (*extend_selection) (GtkCList *clist,
                                 GtkScrollType scroll_type,
                                 gfloat position,
                                 gboolean auto_start_selection);
  void (*scroll_horizontal) (GtkCList *clist,
                                 GtkScrollType scroll_type,
                                 gfloat position);
  void (*scroll_vertical) (GtkCList *clist,
                                 GtkScrollType scroll_type,
                                 gfloat position);
  void (*toggle_add_mode) (GtkCList *clist);
  void (*abort_column_resize) (GtkCList *clist);
  void (*resync_selection) (GtkCList *clist,
                                 GdkEvent *event);
  GList* (*selection_find) (GtkCList *clist,
                                 gint row_number,
                                 GList *row_list_element);
  void (*draw_row) (GtkCList *clist,
                                 GdkRectangle *area,
                                 gint row,
                                 GtkCListRow *clist_row);
  void (*draw_drag_highlight) (GtkCList *clist,
                                 GtkCListRow *target_row,
                                 gint target_row_number,
                                 GtkCListDragPos drag_pos);
  void (*clear) (GtkCList *clist);
  void (*fake_unselect_all) (GtkCList *clist,
                                 gint row);
  void (*sort_list) (GtkCList *clist);
  gint (*insert_row) (GtkCList *clist,
                                 gint row,
                                 gchar *text[]);
  void (*remove_row) (GtkCList *clist,
                                 gint row);
  void (*set_cell_contents) (GtkCList *clist,
                                 GtkCListRow *clist_row,
                                 gint column,
                                 GtkCellType type,
                                 const gchar *text,
                                 guint8 spacing,
                                 GdkPixmap *pixmap,
                                 GdkBitmap *mask);
  void (*cell_size_request) (GtkCList *clist,
                                 GtkCListRow *clist_row,
                                 gint column,
                                 GtkRequisition *requisition);

};

struct _GtkCListColumn
{
  gchar *title;
  GdkRectangle area;

  GtkWidget *button;
  GdkWindow *window;

  gint width;
  gint min_width;
  gint max_width;
  GtkJustification justification;

  guint visible : 1;
  guint width_set : 1;
  guint resizeable : 1;
  guint auto_resize : 1;
  guint button_passive : 1;
};

struct _GtkCListRow
{
  GtkCell *cell;
  GtkStateType state;

  GdkColor foreground;
  GdkColor background;

  GtkStyle *style;

  gpointer data;
  GtkDestroyNotify destroy;

  guint fg_set : 1;
  guint bg_set : 1;
  guint selectable : 1;
};


struct _GtkCellText
{
  GtkCellType type;

  gint16 vertical;
  gint16 horizontal;

  GtkStyle *style;

  gchar *text;
};

struct _GtkCellPixmap
{
  GtkCellType type;

  gint16 vertical;
  gint16 horizontal;

  GtkStyle *style;

  GdkPixmap *pixmap;
  GdkBitmap *mask;
};

struct _GtkCellPixText
{
  GtkCellType type;

  gint16 vertical;
  gint16 horizontal;

  GtkStyle *style;

  gchar *text;
  guint8 spacing;
  GdkPixmap *pixmap;
  GdkBitmap *mask;
};

struct _GtkCellWidget
{
  GtkCellType type;

  gint16 vertical;
  gint16 horizontal;

  GtkStyle *style;

  GtkWidget *widget;
};

struct _GtkCell
{
  GtkCellType type;

  gint16 vertical;
  gint16 horizontal;

  GtkStyle *style;

  union {
    gchar *text;

    struct {
      GdkPixmap *pixmap;
      GdkBitmap *mask;
    } pm;

    struct {
      gchar *text;
      guint8 spacing;
      GdkPixmap *pixmap;
      GdkBitmap *mask;
    } pt;

    GtkWidget *widget;
  } u;
};

GtkType gtk_clist_get_type (void) ;


GtkWidget* gtk_clist_new (gint columns);
GtkWidget* gtk_clist_new_with_titles (gint columns,
                                      gchar *titles[]);


void gtk_clist_set_hadjustment (GtkCList *clist,
                                GtkAdjustment *adjustment);
void gtk_clist_set_vadjustment (GtkCList *clist,
                                GtkAdjustment *adjustment);


GtkAdjustment* gtk_clist_get_hadjustment (GtkCList *clist);
GtkAdjustment* gtk_clist_get_vadjustment (GtkCList *clist);


void gtk_clist_set_shadow_type (GtkCList *clist,
                                GtkShadowType type);


void gtk_clist_set_selection_mode (GtkCList *clist,
                                   GtkSelectionMode mode);


void gtk_clist_set_reorderable (GtkCList *clist,
                                gboolean reorderable);
void gtk_clist_set_use_drag_icons (GtkCList *clist,
                                   gboolean use_icons);
void gtk_clist_set_button_actions (GtkCList *clist,
                                   guint button,
                                   guint8 button_actions);





void gtk_clist_freeze (GtkCList *clist);
void gtk_clist_thaw (GtkCList *clist);


void gtk_clist_column_titles_show (GtkCList *clist);
void gtk_clist_column_titles_hide (GtkCList *clist);





void gtk_clist_column_title_active (GtkCList *clist,
                                      gint column);
void gtk_clist_column_title_passive (GtkCList *clist,
                                      gint column);
void gtk_clist_column_titles_active (GtkCList *clist);
void gtk_clist_column_titles_passive (GtkCList *clist);


void gtk_clist_set_column_title (GtkCList *clist,
                                 gint column,
                                 const gchar *title);


gchar * gtk_clist_get_column_title (GtkCList *clist,
                                    gint column);


void gtk_clist_set_column_widget (GtkCList *clist,
                                  gint column,
                                  GtkWidget *widget);


GtkWidget * gtk_clist_get_column_widget (GtkCList *clist,
                                         gint column);


void gtk_clist_set_column_justification (GtkCList *clist,
                                         gint column,
                                         GtkJustification justification);


void gtk_clist_set_column_visibility (GtkCList *clist,
                                      gint column,
                                      gboolean visible);


void gtk_clist_set_column_resizeable (GtkCList *clist,
                                      gint column,
                                      gboolean resizeable);


void gtk_clist_set_column_auto_resize (GtkCList *clist,
                                       gint column,
                                       gboolean auto_resize);

gint gtk_clist_columns_autosize (GtkCList *clist);


gint gtk_clist_optimal_column_width (GtkCList *clist,
                                     gint column);





void gtk_clist_set_column_width (GtkCList *clist,
                                 gint column,
                                 gint width);


void gtk_clist_set_column_min_width (GtkCList *clist,
                                     gint column,
                                     gint min_width);
void gtk_clist_set_column_max_width (GtkCList *clist,
                                     gint column,
                                     gint max_width);




void gtk_clist_set_row_height (GtkCList *clist,
                               guint height);






void gtk_clist_moveto (GtkCList *clist,
                       gint row,
                       gint column,
                       gfloat row_align,
                       gfloat col_align);


GtkVisibility gtk_clist_row_is_visible (GtkCList *clist,
                                        gint row);


GtkCellType gtk_clist_get_cell_type (GtkCList *clist,
                                     gint row,
                                     gint column);


void gtk_clist_set_text (GtkCList *clist,
                         gint row,
                         gint column,
                         const gchar *text);




gint gtk_clist_get_text (GtkCList *clist,
                         gint row,
                         gint column,
                         gchar **text);


void gtk_clist_set_pixmap (GtkCList *clist,
                           gint row,
                           gint column,
                           GdkPixmap *pixmap,
                           GdkBitmap *mask);

gint gtk_clist_get_pixmap (GtkCList *clist,
                           gint row,
                           gint column,
                           GdkPixmap **pixmap,
                           GdkBitmap **mask);


void gtk_clist_set_pixtext (GtkCList *clist,
                            gint row,
                            gint column,
                            const gchar *text,
                            guint8 spacing,
                            GdkPixmap *pixmap,
                            GdkBitmap *mask);

gint gtk_clist_get_pixtext (GtkCList *clist,
                            gint row,
                            gint column,
                            gchar **text,
                            guint8 *spacing,
                            GdkPixmap **pixmap,
                            GdkBitmap **mask);




void gtk_clist_set_foreground (GtkCList *clist,
                               gint row,
                               GdkColor *color);




void gtk_clist_set_background (GtkCList *clist,
                               gint row,
                               GdkColor *color);


void gtk_clist_set_cell_style (GtkCList *clist,
                               gint row,
                               gint column,
                               GtkStyle *style);

GtkStyle *gtk_clist_get_cell_style (GtkCList *clist,
                                    gint row,
                                    gint column);

void gtk_clist_set_row_style (GtkCList *clist,
                              gint row,
                              GtkStyle *style);

GtkStyle *gtk_clist_get_row_style (GtkCList *clist,
                                   gint row);





void gtk_clist_set_shift (GtkCList *clist,
                          gint row,
                          gint column,
                          gint vertical,
                          gint horizontal);


void gtk_clist_set_selectable (GtkCList *clist,
                               gint row,
                               gboolean selectable);
gboolean gtk_clist_get_selectable (GtkCList *clist,
                                   gint row);




gint gtk_clist_prepend (GtkCList *clist,
                        gchar *text[]);
gint gtk_clist_append (GtkCList *clist,
                        gchar *text[]);




gint gtk_clist_insert (GtkCList *clist,
                       gint row,
                       gchar *text[]);


void gtk_clist_remove (GtkCList *clist,
                       gint row);


void gtk_clist_set_row_data (GtkCList *clist,
                             gint row,
                             gpointer data);


void gtk_clist_set_row_data_full (GtkCList *clist,
                                  gint row,
                                  gpointer data,
                                  GtkDestroyNotify destroy);


gpointer gtk_clist_get_row_data (GtkCList *clist,
                                 gint row);




gint gtk_clist_find_row_from_data (GtkCList *clist,
                                   gpointer data);


void gtk_clist_select_row (GtkCList *clist,
                           gint row,
                           gint column);


void gtk_clist_unselect_row (GtkCList *clist,
                             gint row,
                             gint column);


void gtk_clist_undo_selection (GtkCList *clist);




void gtk_clist_clear (GtkCList *clist);





gint gtk_clist_get_selection_info (GtkCList *clist,
                                   gint x,
                                   gint y,
                                   gint *row,
                                   gint *column);


void gtk_clist_select_all (GtkCList *clist);


void gtk_clist_unselect_all (GtkCList *clist);


void gtk_clist_swap_rows (GtkCList *clist,
                          gint row1,
                          gint row2);


void gtk_clist_row_move (GtkCList *clist,
                         gint source_row,
                         gint dest_row);


void gtk_clist_set_compare_func (GtkCList *clist,
                                 GtkCListCompareFunc cmp_func);


void gtk_clist_set_sort_column (GtkCList *clist,
                                gint column);


void gtk_clist_set_sort_type (GtkCList *clist,
                              GtkSortType sort_type);


void gtk_clist_sort (GtkCList *clist);


void gtk_clist_set_auto_sort (GtkCList *clist,
                              gboolean auto_sort);



PangoLayout *_gtk_clist_create_cell_layout (GtkCList *clist,
                                            GtkCListRow *clist_row,
                                            gint column);
# 54 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h" 1 3 4
# 30 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkdialog.h" 1 3 4
# 40 "/usr/include/gtk-2.0/gtk/gtkdialog.h" 3 4
typedef enum
{
  GTK_DIALOG_MODAL = 1 << 0,
  GTK_DIALOG_DESTROY_WITH_PARENT = 1 << 1,
  GTK_DIALOG_NO_SEPARATOR = 1 << 2
} GtkDialogFlags;
# 55 "/usr/include/gtk-2.0/gtk/gtkdialog.h" 3 4
typedef enum
{



  GTK_RESPONSE_NONE = -1,





  GTK_RESPONSE_REJECT = -2,
  GTK_RESPONSE_ACCEPT = -3,


  GTK_RESPONSE_DELETE_EVENT = -4,




  GTK_RESPONSE_OK = -5,
  GTK_RESPONSE_CANCEL = -6,
  GTK_RESPONSE_CLOSE = -7,
  GTK_RESPONSE_YES = -8,
  GTK_RESPONSE_NO = -9,
  GTK_RESPONSE_APPLY = -10,
  GTK_RESPONSE_HELP = -11
} GtkResponseType;
# 93 "/usr/include/gtk-2.0/gtk/gtkdialog.h" 3 4
typedef struct _GtkDialog GtkDialog;
typedef struct _GtkDialogClass GtkDialogClass;

struct _GtkDialog
{
  GtkWindow window;


  GtkWidget *vbox;
  GtkWidget *action_area;


  GtkWidget *separator;
};

struct _GtkDialogClass
{
  GtkWindowClass parent_class;

  void (* response) (GtkDialog *dialog, gint response_id);



  void (* close) (GtkDialog *dialog);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_dialog_get_type (void) ;
GtkWidget* gtk_dialog_new (void);

GtkWidget* gtk_dialog_new_with_buttons (const gchar *title,
                                        GtkWindow *parent,
                                        GtkDialogFlags flags,
                                        const gchar *first_button_text,
                                        ...);

void gtk_dialog_add_action_widget (GtkDialog *dialog,
                                         GtkWidget *child,
                                         gint response_id);
GtkWidget* gtk_dialog_add_button (GtkDialog *dialog,
                                         const gchar *button_text,
                                         gint response_id);
void gtk_dialog_add_buttons (GtkDialog *dialog,
                                         const gchar *first_button_text,
                                         ...);

void gtk_dialog_set_response_sensitive (GtkDialog *dialog,
                                        gint response_id,
                                        gboolean setting);
void gtk_dialog_set_default_response (GtkDialog *dialog,
                                        gint response_id);

void gtk_dialog_set_has_separator (GtkDialog *dialog,
                                       gboolean setting);
gboolean gtk_dialog_get_has_separator (GtkDialog *dialog);


void gtk_dialog_response (GtkDialog *dialog,
                                    gint response_id);


gint gtk_dialog_run (GtkDialog *dialog);
# 31 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkvbox.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkvbox.h" 3 4
typedef struct _GtkVBox GtkVBox;
typedef struct _GtkVBoxClass GtkVBoxClass;

struct _GtkVBox
{
  GtkBox box;
};

struct _GtkVBoxClass
{
  GtkBoxClass parent_class;
};


GType gtk_vbox_get_type (void) ;
GtkWidget* gtk_vbox_new (gboolean homogeneous,
                              gint spacing);
# 32 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h" 2 3 4
# 46 "/usr/include/gtk-2.0/gtk/gtkcolorsel.h" 3 4
typedef struct _GtkColorSelection GtkColorSelection;
typedef struct _GtkColorSelectionClass GtkColorSelectionClass;


typedef void (* GtkColorSelectionChangePaletteFunc) (const GdkColor *colors,
                                                     gint n_colors);
typedef void (* GtkColorSelectionChangePaletteWithScreenFunc) (GdkScreen *screen,
                                                               const GdkColor *colors,
                                                               gint n_colors);

struct _GtkColorSelection
{
  GtkVBox parent_instance;


  gpointer private_data;
};

struct _GtkColorSelectionClass
{
  GtkVBoxClass parent_class;

  void (*color_changed) (GtkColorSelection *color_selection);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};




GType gtk_color_selection_get_type (void) ;
GtkWidget *gtk_color_selection_new (void);
gboolean gtk_color_selection_get_has_opacity_control (GtkColorSelection *colorsel);
void gtk_color_selection_set_has_opacity_control (GtkColorSelection *colorsel,
                                                        gboolean has_opacity);
gboolean gtk_color_selection_get_has_palette (GtkColorSelection *colorsel);
void gtk_color_selection_set_has_palette (GtkColorSelection *colorsel,
                                                        gboolean has_palette);


void gtk_color_selection_set_current_color (GtkColorSelection *colorsel,
                                                  GdkColor *color);
void gtk_color_selection_set_current_alpha (GtkColorSelection *colorsel,
                                                  guint16 alpha);
void gtk_color_selection_get_current_color (GtkColorSelection *colorsel,
                                                  GdkColor *color);
guint16 gtk_color_selection_get_current_alpha (GtkColorSelection *colorsel);
void gtk_color_selection_set_previous_color (GtkColorSelection *colorsel,
                                                  GdkColor *color);
void gtk_color_selection_set_previous_alpha (GtkColorSelection *colorsel,
                                                  guint16 alpha);
void gtk_color_selection_get_previous_color (GtkColorSelection *colorsel,
                                                  GdkColor *color);
guint16 gtk_color_selection_get_previous_alpha (GtkColorSelection *colorsel);

gboolean gtk_color_selection_is_adjusting (GtkColorSelection *colorsel);

gboolean gtk_color_selection_palette_from_string (const gchar *str,
                                                  GdkColor **colors,
                                                  gint *n_colors);
gchar* gtk_color_selection_palette_to_string (const GdkColor *colors,
                                                  gint n_colors);


GtkColorSelectionChangePaletteFunc gtk_color_selection_set_change_palette_hook (GtkColorSelectionChangePaletteFunc func);


GtkColorSelectionChangePaletteWithScreenFunc gtk_color_selection_set_change_palette_with_screen_hook (GtkColorSelectionChangePaletteWithScreenFunc func);



void gtk_color_selection_set_color (GtkColorSelection *colorsel,
                                            gdouble *color);
void gtk_color_selection_get_color (GtkColorSelection *colorsel,
                                            gdouble *color);
void gtk_color_selection_set_update_policy (GtkColorSelection *colorsel,
                                            GtkUpdateType policy);
# 55 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h" 1 3 4
# 45 "/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h" 3 4
typedef struct _GtkColorSelectionDialog GtkColorSelectionDialog;
typedef struct _GtkColorSelectionDialogClass GtkColorSelectionDialogClass;


struct _GtkColorSelectionDialog
{
  GtkDialog parent_instance;

  GtkWidget *colorsel;
  GtkWidget *ok_button;
  GtkWidget *cancel_button;
  GtkWidget *help_button;
};

struct _GtkColorSelectionDialogClass
{
  GtkDialogClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};



GType gtk_color_selection_dialog_get_type (void) ;
GtkWidget* gtk_color_selection_dialog_new (const gchar *title);
# 56 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcombo.h" 1 3 4
# 30 "/usr/include/gtk-2.0/gtk/gtkcombo.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkhbox.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkhbox.h" 3 4
typedef struct _GtkHBox GtkHBox;
typedef struct _GtkHBoxClass GtkHBoxClass;

struct _GtkHBox
{
  GtkBox box;
};

struct _GtkHBoxClass
{
  GtkBoxClass parent_class;
};


GType gtk_hbox_get_type (void) ;
GtkWidget* gtk_hbox_new (gboolean homogeneous,
                              gint spacing);
# 31 "/usr/include/gtk-2.0/gtk/gtkcombo.h" 2 3 4
# 45 "/usr/include/gtk-2.0/gtk/gtkcombo.h" 3 4
typedef struct _GtkCombo GtkCombo;
typedef struct _GtkComboClass GtkComboClass;


struct _GtkCombo {
        GtkHBox hbox;


        GtkWidget *entry;


        GtkWidget *button;
        GtkWidget *popup;
        GtkWidget *popwin;


        GtkWidget *list;


        guint entry_change_id;
        guint list_change_id;

        guint value_in_list:1;
        guint ok_if_empty:1;
        guint case_sensitive:1;
        guint use_arrows:1;
        guint use_arrows_always:1;

        guint16 current_button;
        guint activate_id;
};

struct _GtkComboClass {
        GtkHBoxClass parent_class;


        void (*_gtk_reserved1) (void);
        void (*_gtk_reserved2) (void);
        void (*_gtk_reserved3) (void);
        void (*_gtk_reserved4) (void);
};

GType gtk_combo_get_type (void) ;

GtkWidget* gtk_combo_new (void);

void gtk_combo_set_value_in_list (GtkCombo* combo,
                                            gboolean val,
                                            gboolean ok_if_empty);

void gtk_combo_set_use_arrows (GtkCombo* combo,
                                            gboolean val);

void gtk_combo_set_use_arrows_always (GtkCombo* combo,
                                            gboolean val);

void gtk_combo_set_case_sensitive (GtkCombo* combo,
                                            gboolean val);


void gtk_combo_set_item_string (GtkCombo* combo,
                                            GtkItem* item,
                                            const gchar* item_value);

void gtk_combo_set_popdown_strings (GtkCombo* combo,
                                            GList *strings);

void gtk_combo_disable_activate (GtkCombo* combo);
# 57 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkctree.h" 1 3 4
# 36 "/usr/include/gtk-2.0/gtk/gtkctree.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkclist.h" 1 3 4
# 37 "/usr/include/gtk-2.0/gtk/gtkctree.h" 2 3 4
# 57 "/usr/include/gtk-2.0/gtk/gtkctree.h" 3 4
typedef enum
{
  GTK_CTREE_POS_BEFORE,
  GTK_CTREE_POS_AS_CHILD,
  GTK_CTREE_POS_AFTER
} GtkCTreePos;

typedef enum
{
  GTK_CTREE_LINES_NONE,
  GTK_CTREE_LINES_SOLID,
  GTK_CTREE_LINES_DOTTED,
  GTK_CTREE_LINES_TABBED
} GtkCTreeLineStyle;

typedef enum
{
  GTK_CTREE_EXPANDER_NONE,
  GTK_CTREE_EXPANDER_SQUARE,
  GTK_CTREE_EXPANDER_TRIANGLE,
  GTK_CTREE_EXPANDER_CIRCULAR
} GtkCTreeExpanderStyle;

typedef enum
{
  GTK_CTREE_EXPANSION_EXPAND,
  GTK_CTREE_EXPANSION_EXPAND_RECURSIVE,
  GTK_CTREE_EXPANSION_COLLAPSE,
  GTK_CTREE_EXPANSION_COLLAPSE_RECURSIVE,
  GTK_CTREE_EXPANSION_TOGGLE,
  GTK_CTREE_EXPANSION_TOGGLE_RECURSIVE
} GtkCTreeExpansionType;

typedef struct _GtkCTree GtkCTree;
typedef struct _GtkCTreeClass GtkCTreeClass;
typedef struct _GtkCTreeRow GtkCTreeRow;
typedef struct _GtkCTreeNode GtkCTreeNode;

typedef void (*GtkCTreeFunc) (GtkCTree *ctree,
                              GtkCTreeNode *node,
                              gpointer data);

typedef gboolean (*GtkCTreeGNodeFunc) (GtkCTree *ctree,
                                       guint depth,
                                       GNode *gnode,
                                       GtkCTreeNode *cnode,
                                       gpointer data);

typedef gboolean (*GtkCTreeCompareDragFunc) (GtkCTree *ctree,
                                             GtkCTreeNode *source_node,
                                             GtkCTreeNode *new_parent,
                                             GtkCTreeNode *new_sibling);

struct _GtkCTree
{
  GtkCList clist;

  GdkGC *lines_gc;

  gint tree_indent;
  gint tree_spacing;
  gint tree_column;

  guint line_style : 2;
  guint expander_style : 2;
  guint show_stub : 1;

  GtkCTreeCompareDragFunc drag_compare;
};

struct _GtkCTreeClass
{
  GtkCListClass parent_class;

  void (*tree_select_row) (GtkCTree *ctree,
                             GtkCTreeNode *row,
                             gint column);
  void (*tree_unselect_row) (GtkCTree *ctree,
                             GtkCTreeNode *row,
                             gint column);
  void (*tree_expand) (GtkCTree *ctree,
                             GtkCTreeNode *node);
  void (*tree_collapse) (GtkCTree *ctree,
                             GtkCTreeNode *node);
  void (*tree_move) (GtkCTree *ctree,
                             GtkCTreeNode *node,
                             GtkCTreeNode *new_parent,
                             GtkCTreeNode *new_sibling);
  void (*change_focus_row_expansion) (GtkCTree *ctree,
                                      GtkCTreeExpansionType action);
};

struct _GtkCTreeRow
{
  GtkCListRow row;

  GtkCTreeNode *parent;
  GtkCTreeNode *sibling;
  GtkCTreeNode *children;

  GdkPixmap *pixmap_closed;
  GdkBitmap *mask_closed;
  GdkPixmap *pixmap_opened;
  GdkBitmap *mask_opened;

  guint16 level;

  guint is_leaf : 1;
  guint expanded : 1;
};

struct _GtkCTreeNode {
  GList list;
};






GtkType gtk_ctree_get_type (void) ;
GtkWidget * gtk_ctree_new_with_titles (gint columns,
                                                  gint tree_column,
                                                  gchar *titles[]);
GtkWidget * gtk_ctree_new (gint columns,
                                                  gint tree_column);
GtkCTreeNode * gtk_ctree_insert_node (GtkCTree *ctree,
                                                  GtkCTreeNode *parent,
                                                  GtkCTreeNode *sibling,
                                                  gchar *text[],
                                                  guint8 spacing,
                                                  GdkPixmap *pixmap_closed,
                                                  GdkBitmap *mask_closed,
                                                  GdkPixmap *pixmap_opened,
                                                  GdkBitmap *mask_opened,
                                                  gboolean is_leaf,
                                                  gboolean expanded);
void gtk_ctree_remove_node (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
GtkCTreeNode * gtk_ctree_insert_gnode (GtkCTree *ctree,
                                                  GtkCTreeNode *parent,
                                                  GtkCTreeNode *sibling,
                                                  GNode *gnode,
                                                  GtkCTreeGNodeFunc func,
                                                  gpointer data);
GNode * gtk_ctree_export_to_gnode (GtkCTree *ctree,
                                                  GNode *parent,
                                                  GNode *sibling,
                                                  GtkCTreeNode *node,
                                                  GtkCTreeGNodeFunc func,
                                                  gpointer data);






void gtk_ctree_post_recursive (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  GtkCTreeFunc func,
                                                  gpointer data);
void gtk_ctree_post_recursive_to_depth (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint depth,
                                                  GtkCTreeFunc func,
                                                  gpointer data);
void gtk_ctree_pre_recursive (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  GtkCTreeFunc func,
                                                  gpointer data);
void gtk_ctree_pre_recursive_to_depth (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint depth,
                                                  GtkCTreeFunc func,
                                                  gpointer data);
gboolean gtk_ctree_is_viewable (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
GtkCTreeNode * gtk_ctree_last (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
GtkCTreeNode * gtk_ctree_find_node_ptr (GtkCTree *ctree,
                                                  GtkCTreeRow *ctree_row);
GtkCTreeNode * gtk_ctree_node_nth (GtkCTree *ctree,
                                                  guint row);
gboolean gtk_ctree_find (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  GtkCTreeNode *child);
gboolean gtk_ctree_is_ancestor (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  GtkCTreeNode *child);
GtkCTreeNode * gtk_ctree_find_by_row_data (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gpointer data);

GList * gtk_ctree_find_all_by_row_data (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gpointer data);
GtkCTreeNode * gtk_ctree_find_by_row_data_custom (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gpointer data,
                                                  GCompareFunc func);

GList * gtk_ctree_find_all_by_row_data_custom (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gpointer data,
                                                  GCompareFunc func);
gboolean gtk_ctree_is_hot_spot (GtkCTree *ctree,
                                                  gint x,
                                                  gint y);





void gtk_ctree_move (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  GtkCTreeNode *new_parent,
                                                  GtkCTreeNode *new_sibling);
void gtk_ctree_expand (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_expand_recursive (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_expand_to_depth (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint depth);
void gtk_ctree_collapse (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_collapse_recursive (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_collapse_to_depth (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint depth);
void gtk_ctree_toggle_expansion (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_toggle_expansion_recursive (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_select (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_select_recursive (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_unselect (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_unselect_recursive (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_real_select_recursive (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint state);





void gtk_ctree_node_set_text (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column,
                                                  const gchar *text);
void gtk_ctree_node_set_pixmap (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column,
                                                  GdkPixmap *pixmap,
                                                  GdkBitmap *mask);
void gtk_ctree_node_set_pixtext (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column,
                                                  const gchar *text,
                                                  guint8 spacing,
                                                  GdkPixmap *pixmap,
                                                  GdkBitmap *mask);
void gtk_ctree_set_node_info (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  const gchar *text,
                                                  guint8 spacing,
                                                  GdkPixmap *pixmap_closed,
                                                  GdkBitmap *mask_closed,
                                                  GdkPixmap *pixmap_opened,
                                                  GdkBitmap *mask_opened,
                                                  gboolean is_leaf,
                                                  gboolean expanded);
void gtk_ctree_node_set_shift (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column,
                                                  gint vertical,
                                                  gint horizontal);
void gtk_ctree_node_set_selectable (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gboolean selectable);
gboolean gtk_ctree_node_get_selectable (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
GtkCellType gtk_ctree_node_get_cell_type (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column);
gboolean gtk_ctree_node_get_text (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column,
                                                  gchar **text);
gboolean gtk_ctree_node_get_pixmap (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column,
                                                  GdkPixmap **pixmap,
                                                  GdkBitmap **mask);
gboolean gtk_ctree_node_get_pixtext (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column,
                                                  gchar **text,
                                                  guint8 *spacing,
                                                  GdkPixmap **pixmap,
                                                  GdkBitmap **mask);
gboolean gtk_ctree_get_node_info (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gchar **text,
                                                  guint8 *spacing,
                                                  GdkPixmap **pixmap_closed,
                                                  GdkBitmap **mask_closed,
                                                  GdkPixmap **pixmap_opened,
                                                  GdkBitmap **mask_opened,
                                                  gboolean *is_leaf,
                                                  gboolean *expanded);
void gtk_ctree_node_set_row_style (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  GtkStyle *style);
GtkStyle * gtk_ctree_node_get_row_style (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_node_set_cell_style (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column,
                                                  GtkStyle *style);
GtkStyle * gtk_ctree_node_get_cell_style (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column);
void gtk_ctree_node_set_foreground (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  GdkColor *color);
void gtk_ctree_node_set_background (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  GdkColor *color);
void gtk_ctree_node_set_row_data (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gpointer data);
void gtk_ctree_node_set_row_data_full (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gpointer data,
                                                  GtkDestroyNotify destroy);
gpointer gtk_ctree_node_get_row_data (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_node_moveto (GtkCTree *ctree,
                                                  GtkCTreeNode *node,
                                                  gint column,
                                                  gfloat row_align,
                                                  gfloat col_align);
GtkVisibility gtk_ctree_node_is_visible (GtkCTree *ctree,
                                                  GtkCTreeNode *node);





void gtk_ctree_set_indent (GtkCTree *ctree,
                                      gint indent);
void gtk_ctree_set_spacing (GtkCTree *ctree,
                                      gint spacing);
void gtk_ctree_set_show_stub (GtkCTree *ctree,
                                      gboolean show_stub);
void gtk_ctree_set_line_style (GtkCTree *ctree,
                                      GtkCTreeLineStyle line_style);
void gtk_ctree_set_expander_style (GtkCTree *ctree,
                                      GtkCTreeExpanderStyle expander_style);
void gtk_ctree_set_drag_compare_func (GtkCTree *ctree,
                                      GtkCTreeCompareDragFunc cmp_func);





void gtk_ctree_sort_node (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
void gtk_ctree_sort_recursive (GtkCTree *ctree,
                                                  GtkCTreeNode *node);
# 441 "/usr/include/gtk-2.0/gtk/gtkctree.h" 3 4
GType gtk_ctree_node_get_type (void) ;
# 59 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkcurve.h" 1 3 4
# 42 "/usr/include/gtk-2.0/gtk/gtkcurve.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkdrawingarea.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkdrawingarea.h" 3 4
typedef struct _GtkDrawingArea GtkDrawingArea;
typedef struct _GtkDrawingAreaClass GtkDrawingAreaClass;

struct _GtkDrawingArea
{
  GtkWidget widget;

  gpointer draw_data;
};

struct _GtkDrawingAreaClass
{
  GtkWidgetClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_drawing_area_get_type (void) ;
GtkWidget* gtk_drawing_area_new (void);


void gtk_drawing_area_size (GtkDrawingArea *darea,
                                        gint width,
                                        gint height);
# 43 "/usr/include/gtk-2.0/gtk/gtkcurve.h" 2 3 4
# 57 "/usr/include/gtk-2.0/gtk/gtkcurve.h" 3 4
typedef struct _GtkCurve GtkCurve;
typedef struct _GtkCurveClass GtkCurveClass;


struct _GtkCurve
{
  GtkDrawingArea graph;

  gint cursor_type;
  gfloat min_x;
  gfloat max_x;
  gfloat min_y;
  gfloat max_y;
  GdkPixmap *pixmap;
  GtkCurveType curve_type;
  gint height;
  gint grab_point;
  gint last;


  gint num_points;
  GdkPoint *point;


  gint num_ctlpoints;
  gfloat (*ctlpoint)[2];
};

struct _GtkCurveClass
{
  GtkDrawingAreaClass parent_class;

  void (* curve_type_changed) (GtkCurve *curve);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_curve_get_type (void) ;
GtkWidget* gtk_curve_new (void);
void gtk_curve_reset (GtkCurve *curve);
void gtk_curve_set_gamma (GtkCurve *curve, gfloat gamma_);
void gtk_curve_set_range (GtkCurve *curve,
                                         gfloat min_x, gfloat max_x,
                                         gfloat min_y, gfloat max_y);
void gtk_curve_get_vector (GtkCurve *curve,
                                         int veclen, gfloat vector[]);
void gtk_curve_set_vector (GtkCurve *curve,
                                         int veclen, gfloat vector[]);
void gtk_curve_set_curve_type (GtkCurve *curve, GtkCurveType type);
# 60 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkdnd.h" 1 3 4
# 39 "/usr/include/gtk-2.0/gtk/gtkdnd.h" 3 4
typedef enum {
  GTK_DEST_DEFAULT_MOTION = 1 << 0,
  GTK_DEST_DEFAULT_HIGHLIGHT = 1 << 1,
  GTK_DEST_DEFAULT_DROP = 1 << 2,
  GTK_DEST_DEFAULT_ALL = 0x07
} GtkDestDefaults;



typedef enum {
  GTK_TARGET_SAME_APP = 1 << 0,
  GTK_TARGET_SAME_WIDGET = 1 << 1
} GtkTargetFlags;



void gtk_drag_get_data (GtkWidget *widget,
                        GdkDragContext *context,
                        GdkAtom target,
                        guint32 time_);
void gtk_drag_finish (GdkDragContext *context,
                        gboolean success,
                        gboolean del,
                        guint32 time_);

GtkWidget *gtk_drag_get_source_widget (GdkDragContext *context);

void gtk_drag_highlight (GtkWidget *widget);
void gtk_drag_unhighlight (GtkWidget *widget);

void gtk_drag_dest_set (GtkWidget *widget,
                          GtkDestDefaults flags,
                          const GtkTargetEntry *targets,
                          gint n_targets,
                          GdkDragAction actions);

void gtk_drag_dest_set_proxy (GtkWidget *widget,
                              GdkWindow *proxy_window,
                              GdkDragProtocol protocol,
                              gboolean use_coordinates);

void gtk_drag_dest_unset (GtkWidget *widget);

GdkAtom gtk_drag_dest_find_target (GtkWidget *widget,
                                              GdkDragContext *context,
                                              GtkTargetList *target_list);
GtkTargetList* gtk_drag_dest_get_target_list (GtkWidget *widget);
void gtk_drag_dest_set_target_list (GtkWidget *widget,
                                              GtkTargetList *target_list);



void gtk_drag_source_set (GtkWidget *widget,
                           GdkModifierType start_button_mask,
                           const GtkTargetEntry *targets,
                           gint n_targets,
                           GdkDragAction actions);

void gtk_drag_source_unset (GtkWidget *widget);

void gtk_drag_source_set_icon (GtkWidget *widget,
                                      GdkColormap *colormap,
                                      GdkPixmap *pixmap,
                                      GdkBitmap *mask);
void gtk_drag_source_set_icon_pixbuf (GtkWidget *widget,
                                      GdkPixbuf *pixbuf);
void gtk_drag_source_set_icon_stock (GtkWidget *widget,
                                      const gchar *stock_id);





GdkDragContext *gtk_drag_begin (GtkWidget *widget,
                                GtkTargetList *targets,
                                GdkDragAction actions,
                                gint button,
                                GdkEvent *event);



void gtk_drag_set_icon_widget (GdkDragContext *context,
                               GtkWidget *widget,
                               gint hot_x,
                               gint hot_y);
void gtk_drag_set_icon_pixmap (GdkDragContext *context,
                               GdkColormap *colormap,
                               GdkPixmap *pixmap,
                               GdkBitmap *mask,
                               gint hot_x,
                               gint hot_y);
void gtk_drag_set_icon_pixbuf (GdkDragContext *context,
                               GdkPixbuf *pixbuf,
                               gint hot_x,
                               gint hot_y);
void gtk_drag_set_icon_stock (GdkDragContext *context,
                               const gchar *stock_id,
                               gint hot_x,
                               gint hot_y);

void gtk_drag_set_icon_default (GdkDragContext *context);

gboolean gtk_drag_check_threshold (GtkWidget *widget,
                                   gint start_x,
                                   gint start_y,
                                   gint current_x,
                                   gint current_y);


void _gtk_drag_source_handle_event (GtkWidget *widget,
                                    GdkEvent *event);
void _gtk_drag_dest_handle_event (GtkWidget *toplevel,
                                  GdkEvent *event);


void gtk_drag_set_default_icon (GdkColormap *colormap,
                                GdkPixmap *pixmap,
                                GdkBitmap *mask,
                                gint hot_x,
                                gint hot_y);
# 62 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkeditable.h" 1 3 4
# 46 "/usr/include/gtk-2.0/gtk/gtkeditable.h" 3 4
typedef struct _GtkEditable GtkEditable;
typedef struct _GtkEditableClass GtkEditableClass;

struct _GtkEditableClass
{
  GTypeInterface base_iface;


  void (* insert_text) (GtkEditable *editable,
                                     const gchar *text,
                                     gint length,
                                     gint *position);
  void (* delete_text) (GtkEditable *editable,
                                     gint start_pos,
                                     gint end_pos);
  void (* changed) (GtkEditable *editable);


  void (* do_insert_text) (GtkEditable *editable,
                                     const gchar *text,
                                     gint length,
                                     gint *position);
  void (* do_delete_text) (GtkEditable *editable,
                                     gint start_pos,
                                     gint end_pos);

  gchar* (* get_chars) (GtkEditable *editable,
                                     gint start_pos,
                                     gint end_pos);
  void (* set_selection_bounds) (GtkEditable *editable,
                                     gint start_pos,
                                     gint end_pos);
  gboolean (* get_selection_bounds) (GtkEditable *editable,
                                     gint *start_pos,
                                     gint *end_pos);
  void (* set_position) (GtkEditable *editable,
                                     gint position);
  gint (* get_position) (GtkEditable *editable);
};

GType gtk_editable_get_type (void) ;
void gtk_editable_select_region (GtkEditable *editable,
                                            gint start,
                                            gint end);
gboolean gtk_editable_get_selection_bounds (GtkEditable *editable,
                                            gint *start,
                                            gint *end);
void gtk_editable_insert_text (GtkEditable *editable,
                                            const gchar *new_text,
                                            gint new_text_length,
                                            gint *position);
void gtk_editable_delete_text (GtkEditable *editable,
                                            gint start_pos,
                                            gint end_pos);
gchar* gtk_editable_get_chars (GtkEditable *editable,
                                            gint start_pos,
                                            gint end_pos);
void gtk_editable_cut_clipboard (GtkEditable *editable);
void gtk_editable_copy_clipboard (GtkEditable *editable);
void gtk_editable_paste_clipboard (GtkEditable *editable);
void gtk_editable_delete_selection (GtkEditable *editable);
void gtk_editable_set_position (GtkEditable *editable,
                                            gint position);
gint gtk_editable_get_position (GtkEditable *editable);
void gtk_editable_set_editable (GtkEditable *editable,
                                            gboolean is_editable);
gboolean gtk_editable_get_editable (GtkEditable *editable);
# 64 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkentry.h" 1 3 4
# 33 "/usr/include/gtk-2.0/gtk/gtkentry.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkimcontext.h" 1 3 4
# 40 "/usr/include/gtk-2.0/gtk/gtkimcontext.h" 3 4
typedef struct _GtkIMContext GtkIMContext;
typedef struct _GtkIMContextClass GtkIMContextClass;

struct _GtkIMContext
{
  GObject parent_instance;
};

struct _GtkIMContextClass
{



  GtkObjectClass parent_class;


  void (*preedit_start) (GtkIMContext *context);
  void (*preedit_end) (GtkIMContext *context);
  void (*preedit_changed) (GtkIMContext *context);
  void (*commit) (GtkIMContext *context, const gchar *str);
  gboolean (*retrieve_surrounding) (GtkIMContext *context);
  gboolean (*delete_surrounding) (GtkIMContext *context,
                                    gint offset,
                                    gint n_chars);


  void (*set_client_window) (GtkIMContext *context,
                                   GdkWindow *window);
  void (*get_preedit_string) (GtkIMContext *context,
                                   gchar **str,
                                   PangoAttrList **attrs,
                                   gint *cursor_pos);
  gboolean (*filter_keypress) (GtkIMContext *context,
                                   GdkEventKey *event);
  void (*focus_in) (GtkIMContext *context);
  void (*focus_out) (GtkIMContext *context);
  void (*reset) (GtkIMContext *context);
  void (*set_cursor_location) (GtkIMContext *context,
                                   GdkRectangle *area);
  void (*set_use_preedit) (GtkIMContext *context,
                                   gboolean use_preedit);
  void (*set_surrounding) (GtkIMContext *context,
                                   const gchar *text,
                                   gint len,
                                   gint cursor_index);
  gboolean (*get_surrounding) (GtkIMContext *context,
                                   gchar **text,
                                   gint *cursor_index);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
  void (*_gtk_reserved5) (void);
  void (*_gtk_reserved6) (void);
};

GType gtk_im_context_get_type (void) ;

void gtk_im_context_set_client_window (GtkIMContext *context,
                                             GdkWindow *window);
void gtk_im_context_get_preedit_string (GtkIMContext *context,
                                             gchar **str,
                                             PangoAttrList **attrs,
                                             gint *cursor_pos);
gboolean gtk_im_context_filter_keypress (GtkIMContext *context,
                                             GdkEventKey *event);
void gtk_im_context_focus_in (GtkIMContext *context);
void gtk_im_context_focus_out (GtkIMContext *context);
void gtk_im_context_reset (GtkIMContext *context);
void gtk_im_context_set_cursor_location (GtkIMContext *context,
                                             GdkRectangle *area);
void gtk_im_context_set_use_preedit (GtkIMContext *context,
                                             gboolean use_preedit);
void gtk_im_context_set_surrounding (GtkIMContext *context,
                                             const gchar *text,
                                             gint len,
                                             gint cursor_index);
gboolean gtk_im_context_get_surrounding (GtkIMContext *context,
                                             gchar **text,
                                             gint *cursor_index);
gboolean gtk_im_context_delete_surrounding (GtkIMContext *context,
                                             gint offset,
                                             gint n_chars);
# 34 "/usr/include/gtk-2.0/gtk/gtkentry.h" 2 3 4
# 50 "/usr/include/gtk-2.0/gtk/gtkentry.h" 3 4
typedef struct _GtkEntry GtkEntry;
typedef struct _GtkEntryClass GtkEntryClass;

struct _GtkEntry
{
  GtkWidget widget;

  gchar *text;

  guint editable : 1;
  guint visible : 1;
  guint overwrite_mode : 1;
  guint in_drag : 1;

  guint16 text_length;
  guint16 text_max_length;


  GdkWindow *text_area;
  GtkIMContext *im_context;
  GtkWidget *popup_menu;

  gint current_pos;
  gint selection_bound;

  PangoLayout *cached_layout;
  guint cache_includes_preedit : 1;

  guint need_im_reset : 1;

  guint has_frame : 1;

  guint activates_default : 1;

  guint cursor_visible : 1;

  guint in_click : 1;

  guint is_cell_renderer : 1;
  guint editing_canceled : 1;

  guint mouse_cursor_obscured : 1;

  guint button;
  guint blink_timeout;
  guint recompute_idle;
  gint scroll_offset;
  gint ascent;
  gint descent;

  guint16 text_size;
  guint16 n_bytes;

  guint16 preedit_length;
  guint16 preedit_cursor;

  gint dnd_position;

  gint drag_start_x;
  gint drag_start_y;

  gunichar invisible_char;

  gint width_chars;
};

struct _GtkEntryClass
{
  GtkWidgetClass parent_class;


  void (* populate_popup) (GtkEntry *entry,
                             GtkMenu *menu);



  void (* activate) (GtkEntry *entry);
  void (* move_cursor) (GtkEntry *entry,
                               GtkMovementStep step,
                               gint count,
                               gboolean extend_selection);
  void (* insert_at_cursor) (GtkEntry *entry,
                               const gchar *str);
  void (* delete_from_cursor) (GtkEntry *entry,
                               GtkDeleteType type,
                               gint count);
  void (* cut_clipboard) (GtkEntry *entry);
  void (* copy_clipboard) (GtkEntry *entry);
  void (* paste_clipboard) (GtkEntry *entry);
  void (* toggle_overwrite) (GtkEntry *entry);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_entry_get_type (void) ;
GtkWidget* gtk_entry_new (void);
void gtk_entry_set_visibility (GtkEntry *entry,
                                                 gboolean visible);
gboolean gtk_entry_get_visibility (GtkEntry *entry);
void gtk_entry_set_invisible_char (GtkEntry *entry,
                                                 gunichar ch);
gunichar gtk_entry_get_invisible_char (GtkEntry *entry);
void gtk_entry_set_has_frame (GtkEntry *entry,
                                                 gboolean setting);
gboolean gtk_entry_get_has_frame (GtkEntry *entry);

void gtk_entry_set_max_length (GtkEntry *entry,
                                                 gint max);
gint gtk_entry_get_max_length (GtkEntry *entry);
void gtk_entry_set_activates_default (GtkEntry *entry,
                                                 gboolean setting);
gboolean gtk_entry_get_activates_default (GtkEntry *entry);

void gtk_entry_set_width_chars (GtkEntry *entry,
                                                 gint n_chars);
gint gtk_entry_get_width_chars (GtkEntry *entry);



void gtk_entry_set_text (GtkEntry *entry,
                                                 const gchar *text);

const gchar* gtk_entry_get_text (GtkEntry *entry);

PangoLayout* gtk_entry_get_layout (GtkEntry *entry);
void gtk_entry_get_layout_offsets (GtkEntry *entry,
                                                 gint *x,
                                                 gint *y);





GtkWidget* gtk_entry_new_with_max_length (gint max);
void gtk_entry_append_text (GtkEntry *entry,
                                                 const gchar *text);
void gtk_entry_prepend_text (GtkEntry *entry,
                                                 const gchar *text);
void gtk_entry_set_position (GtkEntry *entry,
                                                 gint position);
void gtk_entry_select_region (GtkEntry *entry,
                                                 gint start,
                                                 gint end);
void gtk_entry_set_editable (GtkEntry *entry,
                                                 gboolean editable);
# 65 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkeventbox.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkeventbox.h" 3 4
typedef struct _GtkEventBox GtkEventBox;
typedef struct _GtkEventBoxClass GtkEventBoxClass;

struct _GtkEventBox
{
  GtkBin bin;
};

struct _GtkEventBoxClass
{
  GtkBinClass parent_class;
};

GType gtk_event_box_get_type (void) ;
GtkWidget* gtk_event_box_new (void);
# 67 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkfilesel.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkfilesel.h" 3 4
typedef struct _GtkFileSelection GtkFileSelection;
typedef struct _GtkFileSelectionClass GtkFileSelectionClass;

struct _GtkFileSelection
{

  GtkDialog parent_instance;


  GtkWidget *dir_list;
  GtkWidget *file_list;
  GtkWidget *selection_entry;
  GtkWidget *selection_text;
  GtkWidget *main_vbox;
  GtkWidget *ok_button;
  GtkWidget *cancel_button;
  GtkWidget *help_button;
  GtkWidget *history_pulldown;
  GtkWidget *history_menu;
  GList *history_list;
  GtkWidget *fileop_dialog;
  GtkWidget *fileop_entry;
  gchar *fileop_file;
  gpointer cmpl_state;

  GtkWidget *fileop_c_dir;
  GtkWidget *fileop_del_file;
  GtkWidget *fileop_ren_file;

  GtkWidget *button_area;
  GtkWidget *action_area;


  GPtrArray *selected_names;
  gchar *last_selected;
};

struct _GtkFileSelectionClass
{
  GtkDialogClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_file_selection_get_type (void) ;
GtkWidget* gtk_file_selection_new (const gchar *title);
void gtk_file_selection_set_filename (GtkFileSelection *filesel,
                                                   const gchar *filename);






const gchar* gtk_file_selection_get_filename (GtkFileSelection *filesel);

void gtk_file_selection_complete (GtkFileSelection *filesel,
                                                   const gchar *pattern);
void gtk_file_selection_show_fileop_buttons (GtkFileSelection *filesel);
void gtk_file_selection_hide_fileop_buttons (GtkFileSelection *filesel);

gchar** gtk_file_selection_get_selections (GtkFileSelection *filesel);

void gtk_file_selection_set_select_multiple (GtkFileSelection *filesel,
                                                   gboolean select_multiple);
gboolean gtk_file_selection_get_select_multiple (GtkFileSelection *filesel);
# 68 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkfixed.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkfixed.h" 3 4
typedef struct _GtkFixed GtkFixed;
typedef struct _GtkFixedClass GtkFixedClass;
typedef struct _GtkFixedChild GtkFixedChild;

struct _GtkFixed
{
  GtkContainer container;

  GList *children;
};

struct _GtkFixedClass
{
  GtkContainerClass parent_class;
};

struct _GtkFixedChild
{
  GtkWidget *widget;
  gint x;
  gint y;
};


GType gtk_fixed_get_type (void) ;
GtkWidget* gtk_fixed_new (void);
void gtk_fixed_put (GtkFixed *fixed,
                                        GtkWidget *widget,
                                        gint x,
                                        gint y);
void gtk_fixed_move (GtkFixed *fixed,
                                        GtkWidget *widget,
                                        gint x,
                                        gint y);
void gtk_fixed_set_has_window (GtkFixed *fixed,
                                        gboolean has_window);
gboolean gtk_fixed_get_has_window (GtkFixed *fixed);
# 69 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkfontsel.h" 1 3 4
# 59 "/usr/include/gtk-2.0/gtk/gtkfontsel.h" 3 4
typedef struct _GtkFontSelection GtkFontSelection;
typedef struct _GtkFontSelectionClass GtkFontSelectionClass;

typedef struct _GtkFontSelectionDialog GtkFontSelectionDialog;
typedef struct _GtkFontSelectionDialogClass GtkFontSelectionDialogClass;

struct _GtkFontSelection
{
  GtkVBox parent_instance;

  GtkWidget *font_entry;
  GtkWidget *family_list;
  GtkWidget *font_style_entry;
  GtkWidget *face_list;
  GtkWidget *size_entry;
  GtkWidget *size_list;
  GtkWidget *pixels_button;
  GtkWidget *points_button;
  GtkWidget *filter_button;
  GtkWidget *preview_entry;

  PangoFontFamily *family;
  PangoFontFace *face;

  gint size;

  GdkFont *font;


};

struct _GtkFontSelectionClass
{
  GtkVBoxClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


struct _GtkFontSelectionDialog
{
  GtkDialog parent_instance;


  GtkWidget *fontsel;

  GtkWidget *main_vbox;
  GtkWidget *action_area;

  GtkWidget *ok_button;
  GtkWidget *apply_button;
  GtkWidget *cancel_button;






  gint dialog_width;
  gboolean auto_resize;
};

struct _GtkFontSelectionDialogClass
{
  GtkDialogClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};
# 143 "/usr/include/gtk-2.0/gtk/gtkfontsel.h" 3 4
GType gtk_font_selection_get_type (void) ;
GtkWidget* gtk_font_selection_new (void);
gchar* gtk_font_selection_get_font_name (GtkFontSelection *fontsel);


GdkFont* gtk_font_selection_get_font (GtkFontSelection *fontsel);


gboolean gtk_font_selection_set_font_name (GtkFontSelection *fontsel,
                                                           const gchar *fontname);
const gchar* gtk_font_selection_get_preview_text (GtkFontSelection *fontsel);
void gtk_font_selection_set_preview_text (GtkFontSelection *fontsel,
                                                           const gchar *text);







GType gtk_font_selection_dialog_get_type (void) ;
GtkWidget* gtk_font_selection_dialog_new (const gchar *title);






gchar* gtk_font_selection_dialog_get_font_name (GtkFontSelectionDialog *fsd);





GdkFont* gtk_font_selection_dialog_get_font (GtkFontSelectionDialog *fsd);






gboolean gtk_font_selection_dialog_set_font_name (GtkFontSelectionDialog *fsd,
                                                     const gchar *fontname);



const gchar* gtk_font_selection_dialog_get_preview_text (GtkFontSelectionDialog *fsd);



void gtk_font_selection_dialog_set_preview_text (GtkFontSelectionDialog *fsd,
                                                     const gchar *text);
# 70 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkgamma.h" 1 3 4
# 57 "/usr/include/gtk-2.0/gtk/gtkgamma.h" 3 4
typedef struct _GtkGammaCurve GtkGammaCurve;
typedef struct _GtkGammaCurveClass GtkGammaCurveClass;


struct _GtkGammaCurve
{
  GtkVBox vbox;

  GtkWidget *table;
  GtkWidget *curve;
  GtkWidget *button[5];

  gfloat gamma;
  GtkWidget *gamma_dialog;
  GtkWidget *gamma_text;
};

struct _GtkGammaCurveClass
{
  GtkVBoxClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_gamma_curve_get_type (void) ;
GtkWidget* gtk_gamma_curve_new (void);
# 72 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkgc.h" 1 3 4
# 39 "/usr/include/gtk-2.0/gtk/gtkgc.h" 3 4
GdkGC* gtk_gc_get (gint depth,
                       GdkColormap *colormap,
                       GdkGCValues *values,
                       GdkGCValuesMask values_mask);
void gtk_gc_release (GdkGC *gc);
# 73 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkhandlebox.h" 1 3 4
# 54 "/usr/include/gtk-2.0/gtk/gtkhandlebox.h" 3 4
typedef struct _GtkHandleBox GtkHandleBox;
typedef struct _GtkHandleBoxClass GtkHandleBoxClass;

struct _GtkHandleBox
{
  GtkBin bin;

  GdkWindow *bin_window;
  GdkWindow *float_window;
  GtkShadowType shadow_type;
  guint handle_position : 2;
  guint float_window_mapped : 1;
  guint child_detached : 1;
  guint in_drag : 1;
  guint shrink_on_detach : 1;

  signed int snap_edge : 3;



  gint deskoff_x, deskoff_y;

  GtkAllocation attach_allocation;
  GtkAllocation float_allocation;
};

struct _GtkHandleBoxClass
{
  GtkBinClass parent_class;

  void (*child_attached) (GtkHandleBox *handle_box,
                                 GtkWidget *child);
  void (*child_detached) (GtkHandleBox *handle_box,
                                 GtkWidget *child);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_handle_box_get_type (void) ;
GtkWidget* gtk_handle_box_new (void);
void gtk_handle_box_set_shadow_type (GtkHandleBox *handle_box,
                                                   GtkShadowType type);
GtkShadowType gtk_handle_box_get_shadow_type (GtkHandleBox *handle_box);
void gtk_handle_box_set_handle_position (GtkHandleBox *handle_box,
                                                   GtkPositionType position);
GtkPositionType gtk_handle_box_get_handle_position(GtkHandleBox *handle_box);
void gtk_handle_box_set_snap_edge (GtkHandleBox *handle_box,
                                                   GtkPositionType edge);
GtkPositionType gtk_handle_box_get_snap_edge (GtkHandleBox *handle_box);
# 74 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkhbbox.h" 1 3 4
# 47 "/usr/include/gtk-2.0/gtk/gtkhbbox.h" 3 4
typedef struct _GtkHButtonBox GtkHButtonBox;
typedef struct _GtkHButtonBoxClass GtkHButtonBoxClass;

struct _GtkHButtonBox
{
  GtkButtonBox button_box;
};

struct _GtkHButtonBoxClass
{
  GtkButtonBoxClass parent_class;
};


GType gtk_hbutton_box_get_type (void) ;
GtkWidget* gtk_hbutton_box_new (void);




gint gtk_hbutton_box_get_spacing_default (void);
GtkButtonBoxStyle gtk_hbutton_box_get_layout_default (void);

void gtk_hbutton_box_set_spacing_default (gint spacing);
void gtk_hbutton_box_set_layout_default (GtkButtonBoxStyle layout);
# 76 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkhpaned.h" 1 3 4
# 30 "/usr/include/gtk-2.0/gtk/gtkhpaned.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkpaned.h" 1 3 4
# 46 "/usr/include/gtk-2.0/gtk/gtkpaned.h" 3 4
typedef struct _GtkPaned GtkPaned;
typedef struct _GtkPanedClass GtkPanedClass;
typedef struct _GtkPanedPrivate GtkPanedPrivate;

struct _GtkPaned
{
  GtkContainer container;

  GtkWidget *child1;
  GtkWidget *child2;

  GdkWindow *handle;
  GdkGC *xor_gc;
  GdkCursorType cursor_type;


  GdkRectangle handle_pos;

  gint child1_size;
  gint last_allocation;
  gint min_position;
  gint max_position;

  guint position_set : 1;
  guint in_drag : 1;
  guint child1_shrink : 1;
  guint child1_resize : 1;
  guint child2_shrink : 1;
  guint child2_resize : 1;
  guint orientation : 1;
  guint in_recursion : 1;
  guint handle_prelit : 1;

  GtkWidget *last_child1_focus;
  GtkWidget *last_child2_focus;
  GtkPanedPrivate *priv;

  gint drag_pos;
  gint original_position;
};

struct _GtkPanedClass
{
  GtkContainerClass parent_class;

  gboolean (* cycle_child_focus) (GtkPaned *paned,
                                    gboolean reverse);
  gboolean (* toggle_handle_focus) (GtkPaned *paned);
  gboolean (* move_handle) (GtkPaned *paned,
                                    GtkScrollType scroll);
  gboolean (* cycle_handle_focus) (GtkPaned *paned,
                                    gboolean reverse);
  gboolean (* accept_position) (GtkPaned *paned);
  gboolean (* cancel_position) (GtkPaned *paned);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_paned_get_type (void) ;
void gtk_paned_add1 (GtkPaned *paned,
                                   GtkWidget *child);
void gtk_paned_add2 (GtkPaned *paned,
                                   GtkWidget *child);
void gtk_paned_pack1 (GtkPaned *paned,
                                   GtkWidget *child,
                                   gboolean resize,
                                   gboolean shrink);
void gtk_paned_pack2 (GtkPaned *paned,
                                   GtkWidget *child,
                                   gboolean resize,
                                   gboolean shrink);
gint gtk_paned_get_position (GtkPaned *paned);
void gtk_paned_set_position (GtkPaned *paned,
                                   gint position);


void gtk_paned_compute_position (GtkPaned *paned,
                                    gint allocation,
                                    gint child1_req,
                                    gint child2_req);
# 31 "/usr/include/gtk-2.0/gtk/gtkhpaned.h" 2 3 4
# 44 "/usr/include/gtk-2.0/gtk/gtkhpaned.h" 3 4
typedef struct _GtkHPaned GtkHPaned;
typedef struct _GtkHPanedClass GtkHPanedClass;

struct _GtkHPaned
{
  GtkPaned paned;
};

struct _GtkHPanedClass
{
  GtkPanedClass parent_class;
};

GType gtk_hpaned_get_type (void) ;
GtkWidget *gtk_hpaned_new (void);
# 77 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkhruler.h" 1 3 4
# 42 "/usr/include/gtk-2.0/gtk/gtkhruler.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkruler.h" 1 3 4
# 58 "/usr/include/gtk-2.0/gtk/gtkruler.h" 3 4
typedef struct _GtkRuler GtkRuler;
typedef struct _GtkRulerClass GtkRulerClass;
typedef struct _GtkRulerMetric GtkRulerMetric;




struct _GtkRuler
{
  GtkWidget widget;

  GdkPixmap *backing_store;
  GdkGC *non_gr_exp_gc;
  GtkRulerMetric *metric;
  gint xsrc, ysrc;
  gint slider_size;


  gdouble lower;

  gdouble upper;

  gdouble position;

  gdouble max_size;
};

struct _GtkRulerClass
{
  GtkWidgetClass parent_class;

  void (* draw_ticks) (GtkRuler *ruler);
  void (* draw_pos) (GtkRuler *ruler);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

struct _GtkRulerMetric
{
  gchar *metric_name;
  gchar *abbrev;


  gdouble pixels_per_unit;
  gdouble ruler_scale[10];
  gint subdivide[5];
};


GType gtk_ruler_get_type (void) ;
void gtk_ruler_set_metric (GtkRuler *ruler,
                              GtkMetricType metric);
void gtk_ruler_set_range (GtkRuler *ruler,
                              gdouble lower,
                              gdouble upper,
                              gdouble position,
                              gdouble max_size);
void gtk_ruler_draw_ticks (GtkRuler *ruler);
void gtk_ruler_draw_pos (GtkRuler *ruler);

GtkMetricType gtk_ruler_get_metric (GtkRuler *ruler);
void gtk_ruler_get_range (GtkRuler *ruler,
                                    gdouble *lower,
                                    gdouble *upper,
                                    gdouble *position,
                                    gdouble *max_size);
# 43 "/usr/include/gtk-2.0/gtk/gtkhruler.h" 2 3 4
# 58 "/usr/include/gtk-2.0/gtk/gtkhruler.h" 3 4
typedef struct _GtkHRuler GtkHRuler;
typedef struct _GtkHRulerClass GtkHRulerClass;

struct _GtkHRuler
{
  GtkRuler ruler;
};

struct _GtkHRulerClass
{
  GtkRulerClass parent_class;
};


GType gtk_hruler_get_type (void) ;
GtkWidget* gtk_hruler_new (void);
# 78 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkhscale.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkhscale.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkscale.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkscale.h" 3 4
typedef struct _GtkScale GtkScale;
typedef struct _GtkScaleClass GtkScaleClass;

struct _GtkScale
{
  GtkRange range;

  gint digits;
  guint draw_value : 1;
  guint value_pos : 2;
};

struct _GtkScaleClass
{
  GtkRangeClass parent_class;

  gchar* (* format_value) (GtkScale *scale,
                           gdouble value);

  void (* draw_value) (GtkScale *scale);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_scale_get_type (void) ;

void gtk_scale_set_digits (GtkScale *scale,
                                          gint digits);
gint gtk_scale_get_digits (GtkScale *scale);
void gtk_scale_set_draw_value (GtkScale *scale,
                                          gboolean draw_value);
gboolean gtk_scale_get_draw_value (GtkScale *scale);
void gtk_scale_set_value_pos (GtkScale *scale,
                                          GtkPositionType pos);
GtkPositionType gtk_scale_get_value_pos (GtkScale *scale);


void _gtk_scale_get_value_size (GtkScale *scale,
                                    gint *width,
                                    gint *height);
gchar *_gtk_scale_format_value (GtkScale *scale,
                                   gdouble value);
# 33 "/usr/include/gtk-2.0/gtk/gtkhscale.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkhscale.h" 3 4
typedef struct _GtkHScale GtkHScale;
typedef struct _GtkHScaleClass GtkHScaleClass;

struct _GtkHScale
{
  GtkScale scale;
};

struct _GtkHScaleClass
{
  GtkScaleClass parent_class;
};


GType gtk_hscale_get_type (void) ;
GtkWidget* gtk_hscale_new (GtkAdjustment *adjustment);
GtkWidget* gtk_hscale_new_with_range (gdouble min,
                                      gdouble max,
                                      gdouble step);
# 79 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkhseparator.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkhseparator.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkseparator.h" 1 3 4
# 49 "/usr/include/gtk-2.0/gtk/gtkseparator.h" 3 4
typedef struct _GtkSeparator GtkSeparator;
typedef struct _GtkSeparatorClass GtkSeparatorClass;

struct _GtkSeparator
{
  GtkWidget widget;
};

struct _GtkSeparatorClass
{
  GtkWidgetClass parent_class;
};


GType gtk_separator_get_type (void) ;
# 33 "/usr/include/gtk-2.0/gtk/gtkhseparator.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkhseparator.h" 3 4
typedef struct _GtkHSeparator GtkHSeparator;
typedef struct _GtkHSeparatorClass GtkHSeparatorClass;

struct _GtkHSeparator
{
  GtkSeparator separator;
};

struct _GtkHSeparatorClass
{
  GtkSeparatorClass parent_class;
};


GType gtk_hseparator_get_type (void) ;
GtkWidget* gtk_hseparator_new (void);
# 81 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkiconfactory.h" 1 3 4
# 37 "/usr/include/gtk-2.0/gtk/gtkiconfactory.h" 3 4
typedef struct _GtkIconFactoryClass GtkIconFactoryClass;
# 48 "/usr/include/gtk-2.0/gtk/gtkiconfactory.h" 3 4
struct _GtkIconFactory
{
  GObject parent_instance;

  GHashTable *icons;
};

struct _GtkIconFactoryClass
{
  GObjectClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_icon_factory_get_type (void);
GtkIconFactory* gtk_icon_factory_new (void);
void gtk_icon_factory_add (GtkIconFactory *factory,
                                           const gchar *stock_id,
                                           GtkIconSet *icon_set);
GtkIconSet* gtk_icon_factory_lookup (GtkIconFactory *factory,
                                           const gchar *stock_id);



void gtk_icon_factory_add_default (GtkIconFactory *factory);
void gtk_icon_factory_remove_default (GtkIconFactory *factory);
GtkIconSet* gtk_icon_factory_lookup_default (const gchar *stock_id);
# 92 "/usr/include/gtk-2.0/gtk/gtkiconfactory.h" 3 4
gboolean gtk_icon_size_lookup (GtkIconSize size,
                                            gint *width,
                                            gint *height);

gboolean gtk_icon_size_lookup_for_settings (GtkSettings *settings,
                                            GtkIconSize size,
                                            gint *width,
                                            gint *height);

GtkIconSize gtk_icon_size_register (const gchar *name,
                                                    gint width,
                                                    gint height);
void gtk_icon_size_register_alias (const gchar *alias,
                                                    GtkIconSize target);
GtkIconSize gtk_icon_size_from_name (const gchar *name);
const gchar* gtk_icon_size_get_name (GtkIconSize size);



GType gtk_icon_set_get_type (void);
GtkIconSet* gtk_icon_set_new (void);
GtkIconSet* gtk_icon_set_new_from_pixbuf (GdkPixbuf *pixbuf);

GtkIconSet* gtk_icon_set_ref (GtkIconSet *icon_set);
void gtk_icon_set_unref (GtkIconSet *icon_set);
GtkIconSet* gtk_icon_set_copy (GtkIconSet *icon_set);




GdkPixbuf* gtk_icon_set_render_icon (GtkIconSet *icon_set,
                                          GtkStyle *style,
                                          GtkTextDirection direction,
                                          GtkStateType state,
                                          GtkIconSize size,
                                          GtkWidget *widget,
                                          const char *detail);


void gtk_icon_set_add_source (GtkIconSet *icon_set,
                                          const GtkIconSource *source);

void gtk_icon_set_get_sizes (GtkIconSet *icon_set,
                                          GtkIconSize **sizes,
                                          gint *n_sizes);

GType gtk_icon_source_get_type (void);
GtkIconSource* gtk_icon_source_new (void);
GtkIconSource* gtk_icon_source_copy (const GtkIconSource *source);
void gtk_icon_source_free (GtkIconSource *source);

void gtk_icon_source_set_filename (GtkIconSource *source,
                                                         const gchar *filename);
void gtk_icon_source_set_pixbuf (GtkIconSource *source,
                                                         GdkPixbuf *pixbuf);

const gchar* gtk_icon_source_get_filename (const GtkIconSource *source);
GdkPixbuf* gtk_icon_source_get_pixbuf (const GtkIconSource *source);

void gtk_icon_source_set_direction_wildcarded (GtkIconSource *source,
                                                           gboolean setting);
void gtk_icon_source_set_state_wildcarded (GtkIconSource *source,
                                                           gboolean setting);
void gtk_icon_source_set_size_wildcarded (GtkIconSource *source,
                                                           gboolean setting);
gboolean gtk_icon_source_get_size_wildcarded (const GtkIconSource *source);
gboolean gtk_icon_source_get_state_wildcarded (const GtkIconSource *source);
gboolean gtk_icon_source_get_direction_wildcarded (const GtkIconSource *source);
void gtk_icon_source_set_direction (GtkIconSource *source,
                                                           GtkTextDirection direction);
void gtk_icon_source_set_state (GtkIconSource *source,
                                                           GtkStateType state);
void gtk_icon_source_set_size (GtkIconSource *source,
                                                           GtkIconSize size);
GtkTextDirection gtk_icon_source_get_direction (const GtkIconSource *source);
GtkStateType gtk_icon_source_get_state (const GtkIconSource *source);
GtkIconSize gtk_icon_source_get_size (const GtkIconSource *source);



void _gtk_icon_set_invalidate_caches (void);
GSList* _gtk_icon_factory_list_ids (void);
# 82 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkimage.h" 1 3 4
# 47 "/usr/include/gtk-2.0/gtk/gtkimage.h" 3 4
typedef struct _GtkImage GtkImage;
typedef struct _GtkImageClass GtkImageClass;

typedef struct _GtkImagePixmapData GtkImagePixmapData;
typedef struct _GtkImageImageData GtkImageImageData;
typedef struct _GtkImagePixbufData GtkImagePixbufData;
typedef struct _GtkImageStockData GtkImageStockData;
typedef struct _GtkImageIconSetData GtkImageIconSetData;
typedef struct _GtkImageAnimationData GtkImageAnimationData;

struct _GtkImagePixmapData
{
  GdkPixmap *pixmap;
};

struct _GtkImageImageData
{
  GdkImage *image;
};

struct _GtkImagePixbufData
{
  GdkPixbuf *pixbuf;
};

struct _GtkImageStockData
{
  gchar *stock_id;
};

struct _GtkImageIconSetData
{
  GtkIconSet *icon_set;
};

struct _GtkImageAnimationData
{
  GdkPixbufAnimation *anim;
  GdkPixbufAnimationIter *iter;
  guint frame_timeout;
};

typedef enum
{
  GTK_IMAGE_EMPTY,
  GTK_IMAGE_PIXMAP,
  GTK_IMAGE_IMAGE,
  GTK_IMAGE_PIXBUF,
  GTK_IMAGE_STOCK,
  GTK_IMAGE_ICON_SET,
  GTK_IMAGE_ANIMATION
} GtkImageType;

struct _GtkImage
{
  GtkMisc misc;

  GtkImageType storage_type;

  union
  {
    GtkImagePixmapData pixmap;
    GtkImageImageData image;
    GtkImagePixbufData pixbuf;
    GtkImageStockData stock;
    GtkImageIconSetData icon_set;
    GtkImageAnimationData anim;
  } data;


  GdkBitmap *mask;


  GtkIconSize icon_size;
};

struct _GtkImageClass
{
  GtkMiscClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_image_get_type (void) ;

GtkWidget* gtk_image_new (void);
GtkWidget* gtk_image_new_from_pixmap (GdkPixmap *pixmap,
                                         GdkBitmap *mask);
GtkWidget* gtk_image_new_from_image (GdkImage *image,
                                         GdkBitmap *mask);
GtkWidget* gtk_image_new_from_file (const gchar *filename);
GtkWidget* gtk_image_new_from_pixbuf (GdkPixbuf *pixbuf);
GtkWidget* gtk_image_new_from_stock (const gchar *stock_id,
                                         GtkIconSize size);
GtkWidget* gtk_image_new_from_icon_set (GtkIconSet *icon_set,
                                         GtkIconSize size);
GtkWidget* gtk_image_new_from_animation (GdkPixbufAnimation *animation);

void gtk_image_set_from_pixmap (GtkImage *image,
                                   GdkPixmap *pixmap,
                                   GdkBitmap *mask);
void gtk_image_set_from_image (GtkImage *image,
                                   GdkImage *gdk_image,
                                   GdkBitmap *mask);
void gtk_image_set_from_file (GtkImage *image,
                                   const gchar *filename);
void gtk_image_set_from_pixbuf (GtkImage *image,
                                   GdkPixbuf *pixbuf);
void gtk_image_set_from_stock (GtkImage *image,
                                   const gchar *stock_id,
                                   GtkIconSize size);
void gtk_image_set_from_icon_set (GtkImage *image,
                                   GtkIconSet *icon_set,
                                   GtkIconSize size);
void gtk_image_set_from_animation (GtkImage *image,
                                   GdkPixbufAnimation *animation);

GtkImageType gtk_image_get_storage_type (GtkImage *image);

void gtk_image_get_pixmap (GtkImage *image,
                                   GdkPixmap **pixmap,
                                   GdkBitmap **mask);
void gtk_image_get_image (GtkImage *image,
                                   GdkImage **gdk_image,
                                   GdkBitmap **mask);
GdkPixbuf* gtk_image_get_pixbuf (GtkImage *image);
void gtk_image_get_stock (GtkImage *image,
                                   gchar **stock_id,
                                   GtkIconSize *size);
void gtk_image_get_icon_set (GtkImage *image,
                                   GtkIconSet **icon_set,
                                   GtkIconSize *size);
GdkPixbufAnimation* gtk_image_get_animation (GtkImage *image);





void gtk_image_set (GtkImage *image,
                               GdkImage *val,
                               GdkBitmap *mask);
void gtk_image_get (GtkImage *image,
                               GdkImage **val,
                               GdkBitmap **mask);
# 83 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h" 3 4
typedef struct _GtkImageMenuItem GtkImageMenuItem;
typedef struct _GtkImageMenuItemClass GtkImageMenuItemClass;

struct _GtkImageMenuItem
{
  GtkMenuItem menu_item;


  GtkWidget *image;
};

struct _GtkImageMenuItemClass
{
  GtkMenuItemClass parent_class;
};


GType gtk_image_menu_item_get_type (void) ;
GtkWidget* gtk_image_menu_item_new (void);
GtkWidget* gtk_image_menu_item_new_with_label (const gchar *label);
GtkWidget* gtk_image_menu_item_new_with_mnemonic (const gchar *label);
GtkWidget* gtk_image_menu_item_new_from_stock (const gchar *stock_id,
                                                  GtkAccelGroup *accel_group);
void gtk_image_menu_item_set_image (GtkImageMenuItem *image_menu_item,
                                                  GtkWidget *image);
GtkWidget* gtk_image_menu_item_get_image (GtkImageMenuItem *image_menu_item);
# 84 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h" 1 3 4
# 38 "/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h" 3 4
typedef struct _GtkIMContextSimple GtkIMContextSimple;
typedef struct _GtkIMContextSimpleClass GtkIMContextSimpleClass;



struct _GtkIMContextSimple
{
  GtkIMContext object;

  GSList *tables;

  guint compose_buffer[7 + 1];
  gunichar tentative_match;
  gint tentative_match_len;

  guint in_hex_sequence : 1;
};

struct _GtkIMContextSimpleClass
{
  GtkIMContextClass parent_class;
};

GType gtk_im_context_simple_get_type (void) ;
GtkIMContext *gtk_im_context_simple_new (void);

void gtk_im_context_simple_add_table (GtkIMContextSimple *context_simple,
                                               guint16 *data,
                                               gint max_seq_len,
                                               gint n_seqs);
# 86 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkimmulticontext.h" 1 3 4
# 39 "/usr/include/gtk-2.0/gtk/gtkimmulticontext.h" 3 4
typedef struct _GtkIMMulticontext GtkIMMulticontext;
typedef struct _GtkIMMulticontextClass GtkIMMulticontextClass;
typedef struct _GtkIMMulticontextPrivate GtkIMMulticontextPrivate;

struct _GtkIMMulticontext
{
  GtkIMContext object;

  GtkIMContext *slave;

  GtkIMMulticontextPrivate *priv;

  const gchar *context_id;
};

struct _GtkIMMulticontextClass
{
  GtkIMContextClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_im_multicontext_get_type (void) ;
GtkIMContext *gtk_im_multicontext_new (void);

void gtk_im_multicontext_append_menuitems (GtkIMMulticontext *context,
                                                    GtkMenuShell *menushell);
# 87 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkinputdialog.h" 1 3 4
# 58 "/usr/include/gtk-2.0/gtk/gtkinputdialog.h" 3 4
typedef struct _GtkInputDialog GtkInputDialog;
typedef struct _GtkInputDialogClass GtkInputDialogClass;

struct _GtkInputDialog
{
  GtkDialog dialog;

  GtkWidget *axis_list;
  GtkWidget *axis_listbox;
  GtkWidget *mode_optionmenu;

  GtkWidget *close_button;
  GtkWidget *save_button;

  GtkWidget *axis_items[GDK_AXIS_LAST];
  GdkDevice *current_device;

  GtkWidget *keys_list;
  GtkWidget *keys_listbox;
};

struct _GtkInputDialogClass
{
  GtkDialogClass parent_class;

  void (* enable_device) (GtkInputDialog *inputd,
                                        GdkDevice *device);
  void (* disable_device) (GtkInputDialog *inputd,
                                        GdkDevice *device);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_input_dialog_get_type (void) ;
GtkWidget* gtk_input_dialog_new (void);
# 88 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkinvisible.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtkinvisible.h" 3 4

# 42 "/usr/include/gtk-2.0/gtk/gtkinvisible.h" 3 4
typedef struct _GtkInvisible GtkInvisible;
typedef struct _GtkInvisibleClass GtkInvisibleClass;

struct _GtkInvisible
{
  GtkWidget widget;
  gboolean has_user_ref_count;
  GdkScreen *screen;
};

struct _GtkInvisibleClass
{
  GtkWidgetClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_invisible_get_type (void) ;

GtkWidget* gtk_invisible_new (void);
GtkWidget* gtk_invisible_new_for_screen (GdkScreen *screen);
void gtk_invisible_set_screen (GtkInvisible *invisible,
                                         GdkScreen *screen);
GdkScreen* gtk_invisible_get_screen (GtkInvisible *invisible);


# 89 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h" 1 3 4
# 42 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h" 3 4
typedef void (*GtkPrintFunc) (gpointer func_data,
                                            const gchar *str);
typedef gchar * (*GtkTranslateFunc) (const gchar *path,
                                            gpointer func_data);





typedef void (*GtkItemFactoryCallback) ();
typedef void (*GtkItemFactoryCallback1) (gpointer callback_data,
                                            guint callback_action,
                                            GtkWidget *widget);
# 64 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h" 3 4
typedef struct _GtkItemFactory GtkItemFactory;
typedef struct _GtkItemFactoryClass GtkItemFactoryClass;
typedef struct _GtkItemFactoryEntry GtkItemFactoryEntry;
typedef struct _GtkItemFactoryItem GtkItemFactoryItem;

struct _GtkItemFactory
{
  GtkObject object;

  gchar *path;
  GtkAccelGroup *accel_group;
  GtkWidget *widget;
  GSList *items;

  GtkTranslateFunc translate_func;
  gpointer translate_data;
  GtkDestroyNotify translate_notify;
};

struct _GtkItemFactoryClass
{
  GtkObjectClass object_class;

  GHashTable *item_ht;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

struct _GtkItemFactoryEntry
{
  gchar *path;
  gchar *accelerator;

  GtkItemFactoryCallback callback;
  guint callback_action;
# 120 "/usr/include/gtk-2.0/gtk/gtkitemfactory.h" 3 4
  gchar *item_type;





  gconstpointer extra_data;
};

struct _GtkItemFactoryItem
{
  gchar *path;
  GSList *widgets;
};


GType gtk_item_factory_get_type (void) ;




GtkItemFactory* gtk_item_factory_new (GType container_type,
                                            const gchar *path,
                                            GtkAccelGroup *accel_group);
void gtk_item_factory_construct (GtkItemFactory *ifactory,
                                            GType container_type,
                                            const gchar *path,
                                            GtkAccelGroup *accel_group);



void gtk_item_factory_add_foreign (GtkWidget *accel_widget,
                                                     const gchar *full_path,
                                                     GtkAccelGroup *accel_group,
                                                     guint keyval,
                                                     GdkModifierType modifiers);

GtkItemFactory* gtk_item_factory_from_widget (GtkWidget *widget);
const gchar* gtk_item_factory_path_from_widget (GtkWidget *widget);

GtkWidget* gtk_item_factory_get_item (GtkItemFactory *ifactory,
                                                       const gchar *path);
GtkWidget* gtk_item_factory_get_widget (GtkItemFactory *ifactory,
                                                       const gchar *path);
GtkWidget* gtk_item_factory_get_widget_by_action (GtkItemFactory *ifactory,
                                                       guint action);
GtkWidget* gtk_item_factory_get_item_by_action (GtkItemFactory *ifactory,
                                                       guint action);

void gtk_item_factory_create_item (GtkItemFactory *ifactory,
                                         GtkItemFactoryEntry *entry,
                                         gpointer callback_data,
                                         guint callback_type);
void gtk_item_factory_create_items (GtkItemFactory *ifactory,
                                         guint n_entries,
                                         GtkItemFactoryEntry *entries,
                                         gpointer callback_data);
void gtk_item_factory_delete_item (GtkItemFactory *ifactory,
                                         const gchar *path);
void gtk_item_factory_delete_entry (GtkItemFactory *ifactory,
                                         GtkItemFactoryEntry *entry);
void gtk_item_factory_delete_entries (GtkItemFactory *ifactory,
                                         guint n_entries,
                                         GtkItemFactoryEntry *entries);
void gtk_item_factory_popup (GtkItemFactory *ifactory,
                                         guint x,
                                         guint y,
                                         guint mouse_button,
                                         guint32 time_);
void gtk_item_factory_popup_with_data(GtkItemFactory *ifactory,
                                         gpointer popup_data,
                                         GtkDestroyNotify destroy,
                                         guint x,
                                         guint y,
                                         guint mouse_button,
                                         guint32 time_);
gpointer gtk_item_factory_popup_data (GtkItemFactory *ifactory);
gpointer gtk_item_factory_popup_data_from_widget (GtkWidget *widget);
void gtk_item_factory_set_translate_func (GtkItemFactory *ifactory,
                                            GtkTranslateFunc func,
                                            gpointer data,
                                            GtkDestroyNotify notify);






typedef void (*GtkMenuCallback) (GtkWidget *widget,
                                 gpointer user_data);
typedef struct {
  gchar *path;
  gchar *accelerator;
  GtkMenuCallback callback;
  gpointer callback_data;
  GtkWidget *widget;
} GtkMenuEntry;


typedef void (*GtkItemFactoryCallback2) (GtkWidget *widget,
                                            gpointer callback_data,
                                            guint callback_action);


void gtk_item_factory_create_items_ac (GtkItemFactory *ifactory,
                                          guint n_entries,
                                          GtkItemFactoryEntry *entries,
                                          gpointer callback_data,
                                          guint callback_type);



GtkItemFactory* gtk_item_factory_from_path (const gchar *path);
void gtk_item_factory_create_menu_entries (guint n_entries,
                                              GtkMenuEntry *entries);
void gtk_item_factories_path_delete (const gchar *ifactory_path,
                                            const gchar *path);
# 91 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtklayout.h" 1 3 4
# 51 "/usr/include/gtk-2.0/gtk/gtklayout.h" 3 4
typedef struct _GtkLayout GtkLayout;
typedef struct _GtkLayoutClass GtkLayoutClass;

struct _GtkLayout
{
  GtkContainer container;

  GList *children;

  guint width;
  guint height;

  GtkAdjustment *hadjustment;
  GtkAdjustment *vadjustment;


  GdkWindow *bin_window;


  GdkVisibilityState visibility;
  gint scroll_x;
  gint scroll_y;

  guint freeze_count;
};

struct _GtkLayoutClass
{
  GtkContainerClass parent_class;

  void (*set_scroll_adjustments) (GtkLayout *layout,
                                     GtkAdjustment *hadjustment,
                                     GtkAdjustment *vadjustment);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_layout_get_type (void) ;
GtkWidget* gtk_layout_new (GtkAdjustment *hadjustment,
                                           GtkAdjustment *vadjustment);
void gtk_layout_put (GtkLayout *layout,
                                           GtkWidget *child_widget,
                                           gint x,
                                           gint y);

void gtk_layout_move (GtkLayout *layout,
                                           GtkWidget *child_widget,
                                           gint x,
                                           gint y);

void gtk_layout_set_size (GtkLayout *layout,
                                           guint width,
                                           guint height);
void gtk_layout_get_size (GtkLayout *layout,
                                           guint *width,
                                           guint *height);

GtkAdjustment* gtk_layout_get_hadjustment (GtkLayout *layout);
GtkAdjustment* gtk_layout_get_vadjustment (GtkLayout *layout);
void gtk_layout_set_hadjustment (GtkLayout *layout,
                                           GtkAdjustment *adjustment);
void gtk_layout_set_vadjustment (GtkLayout *layout,
                                           GtkAdjustment *adjustment);
# 129 "/usr/include/gtk-2.0/gtk/gtklayout.h" 3 4
void gtk_layout_freeze (GtkLayout *layout);
void gtk_layout_thaw (GtkLayout *layout);
# 93 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtklist.h" 1 3 4
# 36 "/usr/include/gtk-2.0/gtk/gtklist.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtklistitem.h" 1 3 4
# 50 "/usr/include/gtk-2.0/gtk/gtklistitem.h" 3 4
typedef struct _GtkListItem GtkListItem;
typedef struct _GtkListItemClass GtkListItemClass;

struct _GtkListItem
{
  GtkItem item;
};

struct _GtkListItemClass
{
  GtkItemClass parent_class;

  void (*toggle_focus_row) (GtkListItem *list_item);
  void (*select_all) (GtkListItem *list_item);
  void (*unselect_all) (GtkListItem *list_item);
  void (*undo_selection) (GtkListItem *list_item);
  void (*start_selection) (GtkListItem *list_item);
  void (*end_selection) (GtkListItem *list_item);
  void (*extend_selection) (GtkListItem *list_item,
                             GtkScrollType scroll_type,
                             gfloat position,
                             gboolean auto_start_selection);
  void (*scroll_horizontal) (GtkListItem *list_item,
                             GtkScrollType scroll_type,
                             gfloat position);
  void (*scroll_vertical) (GtkListItem *list_item,
                             GtkScrollType scroll_type,
                             gfloat position);
  void (*toggle_add_mode) (GtkListItem *list_item);
};


GtkType gtk_list_item_get_type (void) ;
GtkWidget* gtk_list_item_new (void);
GtkWidget* gtk_list_item_new_with_label (const gchar *label);
void gtk_list_item_select (GtkListItem *list_item);
void gtk_list_item_deselect (GtkListItem *list_item);
# 37 "/usr/include/gtk-2.0/gtk/gtklist.h" 2 3 4
# 51 "/usr/include/gtk-2.0/gtk/gtklist.h" 3 4
typedef struct _GtkList GtkList;
typedef struct _GtkListClass GtkListClass;

struct _GtkList
{
  GtkContainer container;

  GList *children;
  GList *selection;

  GList *undo_selection;
  GList *undo_unselection;

  GtkWidget *last_focus_child;
  GtkWidget *undo_focus_child;

  guint htimer;
  guint vtimer;

  gint anchor;
  gint drag_pos;
  GtkStateType anchor_state;

  guint selection_mode : 2;
  guint drag_selection:1;
  guint add_mode:1;
};

struct _GtkListClass
{
  GtkContainerClass parent_class;

  void (* selection_changed) (GtkList *list);
  void (* select_child) (GtkList *list,
                              GtkWidget *child);
  void (* unselect_child) (GtkList *list,
                              GtkWidget *child);
};


GtkType gtk_list_get_type (void) ;
GtkWidget* gtk_list_new (void);
void gtk_list_insert_items (GtkList *list,
                                           GList *items,
                                           gint position);
void gtk_list_append_items (GtkList *list,
                                           GList *items);
void gtk_list_prepend_items (GtkList *list,
                                           GList *items);
void gtk_list_remove_items (GtkList *list,
                                           GList *items);
void gtk_list_remove_items_no_unref (GtkList *list,
                                           GList *items);
void gtk_list_clear_items (GtkList *list,
                                           gint start,
                                           gint end);
void gtk_list_select_item (GtkList *list,
                                           gint item);
void gtk_list_unselect_item (GtkList *list,
                                           gint item);
void gtk_list_select_child (GtkList *list,
                                           GtkWidget *child);
void gtk_list_unselect_child (GtkList *list,
                                           GtkWidget *child);
gint gtk_list_child_position (GtkList *list,
                                           GtkWidget *child);
void gtk_list_set_selection_mode (GtkList *list,
                                           GtkSelectionMode mode);

void gtk_list_extend_selection (GtkList *list,
                                           GtkScrollType scroll_type,
                                           gfloat position,
                                           gboolean auto_start_selection);
void gtk_list_start_selection (GtkList *list);
void gtk_list_end_selection (GtkList *list);
void gtk_list_select_all (GtkList *list);
void gtk_list_unselect_all (GtkList *list);
void gtk_list_scroll_horizontal (GtkList *list,
                                           GtkScrollType scroll_type,
                                           gfloat position);
void gtk_list_scroll_vertical (GtkList *list,
                                           GtkScrollType scroll_type,
                                           gfloat position);
void gtk_list_toggle_add_mode (GtkList *list);
void gtk_list_toggle_focus_row (GtkList *list);
void gtk_list_toggle_row (GtkList *list,
                                           GtkWidget *item);
void gtk_list_undo_selection (GtkList *list);
void gtk_list_end_drag_selection (GtkList *list);
# 94 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtklistitem.h" 1 3 4
# 95 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkliststore.h" 1 3 4
# 23 "/usr/include/gtk-2.0/gtk/gtkliststore.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktreemodel.h" 1 3 4
# 28 "/usr/include/gtk-2.0/gtk/gtktreemodel.h" 3 4

# 39 "/usr/include/gtk-2.0/gtk/gtktreemodel.h" 3 4
typedef struct _GtkTreeIter GtkTreeIter;
typedef struct _GtkTreePath GtkTreePath;
typedef struct _GtkTreeRowReference GtkTreeRowReference;
typedef struct _GtkTreeModel GtkTreeModel;
typedef struct _GtkTreeModelIface GtkTreeModelIface;
typedef gboolean (* GtkTreeModelForeachFunc) (GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data);


typedef enum
{
  GTK_TREE_MODEL_ITERS_PERSIST = 1 << 0,
  GTK_TREE_MODEL_LIST_ONLY = 1 << 1
} GtkTreeModelFlags;

struct _GtkTreeIter
{
  gint stamp;
  gpointer user_data;
  gpointer user_data2;
  gpointer user_data3;
};

struct _GtkTreeModelIface
{
  GTypeInterface g_iface;


  void (* row_changed) (GtkTreeModel *tree_model,
                                          GtkTreePath *path,
                                          GtkTreeIter *iter);
  void (* row_inserted) (GtkTreeModel *tree_model,
                                          GtkTreePath *path,
                                          GtkTreeIter *iter);
  void (* row_has_child_toggled) (GtkTreeModel *tree_model,
                                          GtkTreePath *path,
                                          GtkTreeIter *iter);
  void (* row_deleted) (GtkTreeModel *tree_model,
                                          GtkTreePath *path);
  void (* rows_reordered) (GtkTreeModel *tree_model,
                                          GtkTreePath *path,
                                          GtkTreeIter *iter,
                                          gint *new_order);


  GtkTreeModelFlags (* get_flags) (GtkTreeModel *tree_model);

  gint (* get_n_columns) (GtkTreeModel *tree_model);
  GType (* get_column_type) (GtkTreeModel *tree_model,
                                    gint index_);
  gboolean (* get_iter) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter,
                                    GtkTreePath *path);
  GtkTreePath *(* get_path) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter);
  void (* get_value) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter,
                                    gint column,
                                    GValue *value);
  gboolean (* iter_next) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter);
  gboolean (* iter_children) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter,
                                    GtkTreeIter *parent);
  gboolean (* iter_has_child) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter);
  gint (* iter_n_children) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter);
  gboolean (* iter_nth_child) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter,
                                    GtkTreeIter *parent,
                                    gint n);
  gboolean (* iter_parent) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter,
                                    GtkTreeIter *child);
  void (* ref_node) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter);
  void (* unref_node) (GtkTreeModel *tree_model,
                                    GtkTreeIter *iter);
};



GtkTreePath *gtk_tree_path_new (void);
GtkTreePath *gtk_tree_path_new_from_string (const gchar *path);
GtkTreePath *gtk_tree_path_new_from_indices (gint first_index,
                                             ...);
gchar *gtk_tree_path_to_string (GtkTreePath *path);

GtkTreePath *gtk_tree_path_new_first (void);
void gtk_tree_path_append_index (GtkTreePath *path,
                                             gint index_);
void gtk_tree_path_prepend_index (GtkTreePath *path,
                                             gint index_);
gint gtk_tree_path_get_depth (GtkTreePath *path);
gint *gtk_tree_path_get_indices (GtkTreePath *path);
void gtk_tree_path_free (GtkTreePath *path);
GtkTreePath *gtk_tree_path_copy (const GtkTreePath *path);
GType gtk_tree_path_get_type (void);
gint gtk_tree_path_compare (const GtkTreePath *a,
                                             const GtkTreePath *b);
void gtk_tree_path_next (GtkTreePath *path);
gboolean gtk_tree_path_prev (GtkTreePath *path);
gboolean gtk_tree_path_up (GtkTreePath *path);
void gtk_tree_path_down (GtkTreePath *path);

gboolean gtk_tree_path_is_ancestor (GtkTreePath *path,
                                             GtkTreePath *descendant);
gboolean gtk_tree_path_is_descendant (GtkTreePath *path,
                                             GtkTreePath *ancestor);






GType gtk_tree_row_reference_get_type (void);
GtkTreeRowReference *gtk_tree_row_reference_new (GtkTreeModel *model,
                                                       GtkTreePath *path);
GtkTreeRowReference *gtk_tree_row_reference_new_proxy (GObject *proxy,
                                                       GtkTreeModel *model,
                                                       GtkTreePath *path);
GtkTreePath *gtk_tree_row_reference_get_path (GtkTreeRowReference *reference);
gboolean gtk_tree_row_reference_valid (GtkTreeRowReference *reference);
GtkTreeRowReference *gtk_tree_row_reference_copy (GtkTreeRowReference *reference);
void gtk_tree_row_reference_free (GtkTreeRowReference *reference);


void gtk_tree_row_reference_inserted (GObject *proxy,
                                                       GtkTreePath *path);
void gtk_tree_row_reference_deleted (GObject *proxy,
                                                       GtkTreePath *path);
void gtk_tree_row_reference_reordered (GObject *proxy,
                                                       GtkTreePath *path,
                                                       GtkTreeIter *iter,
                                                       gint *new_order);


GtkTreeIter * gtk_tree_iter_copy (GtkTreeIter *iter);
void gtk_tree_iter_free (GtkTreeIter *iter);
GType gtk_tree_iter_get_type (void);

GType gtk_tree_model_get_type (void) ;
GtkTreeModelFlags gtk_tree_model_get_flags (GtkTreeModel *tree_model);
gint gtk_tree_model_get_n_columns (GtkTreeModel *tree_model);
GType gtk_tree_model_get_column_type (GtkTreeModel *tree_model,
                                                  gint index_);



gboolean gtk_tree_model_get_iter (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter,
                                                  GtkTreePath *path);
gboolean gtk_tree_model_get_iter_from_string (GtkTreeModel *tree_model,
                                                       GtkTreeIter *iter,
                                                       const gchar *path_string);
gchar * gtk_tree_model_get_string_from_iter (GtkTreeModel *tree_model,
                                                       GtkTreeIter *iter);

gboolean gtk_tree_model_get_iter_first (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter);
GtkTreePath * gtk_tree_model_get_path (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter);
void gtk_tree_model_get_value (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter,
                                                  gint column,
                                                  GValue *value);
gboolean gtk_tree_model_iter_next (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter);
gboolean gtk_tree_model_iter_children (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter,
                                                  GtkTreeIter *parent);
gboolean gtk_tree_model_iter_has_child (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter);
gint gtk_tree_model_iter_n_children (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter);
gboolean gtk_tree_model_iter_nth_child (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter,
                                                  GtkTreeIter *parent,
                                                  gint n);
gboolean gtk_tree_model_iter_parent (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter,
                                                  GtkTreeIter *child);
void gtk_tree_model_ref_node (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter);
void gtk_tree_model_unref_node (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter);
void gtk_tree_model_get (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter,
                                                  ...);
void gtk_tree_model_get_valist (GtkTreeModel *tree_model,
                                                  GtkTreeIter *iter,
                                                  va_list var_args);


void gtk_tree_model_foreach (GtkTreeModel *model,
                                                  GtkTreeModelForeachFunc func,
                                                  gpointer user_data);



void gtk_tree_model_row_changed (GtkTreeModel *tree_model,
                                           GtkTreePath *path,
                                           GtkTreeIter *iter);
void gtk_tree_model_row_inserted (GtkTreeModel *tree_model,
                                           GtkTreePath *path,
                                           GtkTreeIter *iter);
void gtk_tree_model_row_has_child_toggled (GtkTreeModel *tree_model,
                                           GtkTreePath *path,
                                           GtkTreeIter *iter);
void gtk_tree_model_row_deleted (GtkTreeModel *tree_model,
                                           GtkTreePath *path);
void gtk_tree_model_rows_reordered (GtkTreeModel *tree_model,
                                           GtkTreePath *path,
                                           GtkTreeIter *iter,
                                           gint *new_order);





# 24 "/usr/include/gtk-2.0/gtk/gtkliststore.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktreesortable.h" 1 3 4
# 27 "/usr/include/gtk-2.0/gtk/gtktreesortable.h" 3 4








enum {
  GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID = -1
};

typedef struct _GtkTreeSortable GtkTreeSortable;
typedef struct _GtkTreeSortableIface GtkTreeSortableIface;

typedef gint (* GtkTreeIterCompareFunc) (GtkTreeModel *model,
                                         GtkTreeIter *a,
                                         GtkTreeIter *b,
                                         gpointer user_data);


struct _GtkTreeSortableIface
{
  GTypeInterface g_iface;


  void (* sort_column_changed) (GtkTreeSortable *sortable);


  gboolean (* get_sort_column_id) (GtkTreeSortable *sortable,
                                      gint *sort_column_id,
                                      GtkSortType *order);
  void (* set_sort_column_id) (GtkTreeSortable *sortable,
                                      gint sort_column_id,
                                      GtkSortType order);
  void (* set_sort_func) (GtkTreeSortable *sortable,
                                      gint sort_column_id,
                                      GtkTreeIterCompareFunc func,
                                      gpointer data,
                                      GtkDestroyNotify destroy);
  void (* set_default_sort_func) (GtkTreeSortable *sortable,
                                      GtkTreeIterCompareFunc func,
                                      gpointer data,
                                      GtkDestroyNotify destroy);
  gboolean (* has_default_sort_func) (GtkTreeSortable *sortable);
};


GType gtk_tree_sortable_get_type (void) ;

void gtk_tree_sortable_sort_column_changed (GtkTreeSortable *sortable);
gboolean gtk_tree_sortable_get_sort_column_id (GtkTreeSortable *sortable,
                                                  gint *sort_column_id,
                                                  GtkSortType *order);
void gtk_tree_sortable_set_sort_column_id (GtkTreeSortable *sortable,
                                                  gint sort_column_id,
                                                  GtkSortType order);
void gtk_tree_sortable_set_sort_func (GtkTreeSortable *sortable,
                                                  gint sort_column_id,
                                                  GtkTreeIterCompareFunc sort_func,
                                                  gpointer user_data,
                                                  GtkDestroyNotify destroy);
void gtk_tree_sortable_set_default_sort_func (GtkTreeSortable *sortable,
                                                  GtkTreeIterCompareFunc sort_func,
                                                  gpointer user_data,
                                                  GtkDestroyNotify destroy);
gboolean gtk_tree_sortable_has_default_sort_func (GtkTreeSortable *sortable);



# 25 "/usr/include/gtk-2.0/gtk/gtkliststore.h" 2 3 4
# 37 "/usr/include/gtk-2.0/gtk/gtkliststore.h" 3 4
typedef struct _GtkListStore GtkListStore;
typedef struct _GtkListStoreClass GtkListStoreClass;

struct _GtkListStore
{
  GObject parent;


  gint stamp;
  gpointer root;
  gpointer tail;
  GList *sort_list;
  gint n_columns;
  gint sort_column_id;
  GtkSortType order;
  GType *column_headers;
  gint length;
  GtkTreeIterCompareFunc default_sort_func;
  gpointer default_sort_data;
  GtkDestroyNotify default_sort_destroy;
  guint columns_dirty : 1;
};

struct _GtkListStoreClass
{
  GObjectClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_list_store_get_type (void);
GtkListStore *gtk_list_store_new (gint n_columns,
                                               ...);
GtkListStore *gtk_list_store_newv (gint n_columns,
                                               GType *types);
void gtk_list_store_set_column_types (GtkListStore *list_store,
                                               gint n_columns,
                                               GType *types);



void gtk_list_store_set_value (GtkListStore *list_store,
                                               GtkTreeIter *iter,
                                               gint column,
                                               GValue *value);
void gtk_list_store_set (GtkListStore *list_store,
                                               GtkTreeIter *iter,
                                               ...);
void gtk_list_store_set_valist (GtkListStore *list_store,
                                               GtkTreeIter *iter,
                                               va_list var_args);
gboolean gtk_list_store_remove (GtkListStore *list_store,
                                               GtkTreeIter *iter);
void gtk_list_store_insert (GtkListStore *list_store,
                                               GtkTreeIter *iter,
                                               gint position);
void gtk_list_store_insert_before (GtkListStore *list_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *sibling);
void gtk_list_store_insert_after (GtkListStore *list_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *sibling);
void gtk_list_store_prepend (GtkListStore *list_store,
                                               GtkTreeIter *iter);
void gtk_list_store_append (GtkListStore *list_store,
                                               GtkTreeIter *iter);
void gtk_list_store_clear (GtkListStore *list_store);
gboolean gtk_list_store_iter_is_valid (GtkListStore *list_store,
                                               GtkTreeIter *iter);
void gtk_list_store_reorder (GtkListStore *store,
                                               gint *new_order);
void gtk_list_store_swap (GtkListStore *store,
                                               GtkTreeIter *a,
                                               GtkTreeIter *b);
void gtk_list_store_move_after (GtkListStore *store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *position);
void gtk_list_store_move_before (GtkListStore *store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *position);
# 96 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkmain.h" 1 3 4
# 60 "/usr/include/gtk-2.0/gtk/gtkmain.h" 3 4
typedef void (*GtkModuleInitFunc) (gint *argc,
                                             gchar ***argv);
typedef void (*GtkModuleDisplayInitFunc) (GdkDisplay *display);
typedef gint (*GtkKeySnoopFunc) (GtkWidget *grab_widget,
                                             GdkEventKey *event,
                                             gpointer func_data);
# 79 "/usr/include/gtk-2.0/gtk/gtkmain.h" 3 4
extern const guint gtk_major_version;
extern const guint gtk_minor_version;
extern const guint gtk_micro_version;
extern const guint gtk_binary_age;
extern const guint gtk_interface_age;
gchar* gtk_check_version (guint required_major,
                          guint required_minor,
                          guint required_micro);





void gtk_init (int *argc,
                                   char ***argv);

gboolean gtk_init_check (int *argc,
                                   char ***argv);
# 119 "/usr/include/gtk-2.0/gtk/gtkmain.h" 3 4
void gtk_exit (gint error_code);


void gtk_disable_setlocale (void);
gchar * gtk_set_locale (void);
PangoLanguage *gtk_get_default_language (void);
gint gtk_events_pending (void);





void gtk_main_do_event (GdkEvent *event);

void gtk_main (void);
guint gtk_main_level (void);
void gtk_main_quit (void);
gboolean gtk_main_iteration (void);

gboolean gtk_main_iteration_do (gboolean blocking);

gboolean gtk_true (void) ;
gboolean gtk_false (void) ;

void gtk_grab_add (GtkWidget *widget);
GtkWidget* gtk_grab_get_current (void);
void gtk_grab_remove (GtkWidget *widget);

void gtk_init_add (GtkFunction function,
                                    gpointer data);
void gtk_quit_add_destroy (guint main_level,
                                    GtkObject *object);
guint gtk_quit_add (guint main_level,
                                    GtkFunction function,
                                    gpointer data);
guint gtk_quit_add_full (guint main_level,
                                    GtkFunction function,
                                    GtkCallbackMarshal marshal,
                                    gpointer data,
                                    GtkDestroyNotify destroy);
void gtk_quit_remove (guint quit_handler_id);
void gtk_quit_remove_by_data (gpointer data);
guint gtk_timeout_add (guint32 interval,
                                    GtkFunction function,
                                    gpointer data);
guint gtk_timeout_add_full (guint32 interval,
                                    GtkFunction function,
                                    GtkCallbackMarshal marshal,
                                    gpointer data,
                                    GtkDestroyNotify destroy);
void gtk_timeout_remove (guint timeout_handler_id);

guint gtk_idle_add (GtkFunction function,
                                    gpointer data);
guint gtk_idle_add_priority (gint priority,
                                    GtkFunction function,
                                    gpointer data);
guint gtk_idle_add_full (gint priority,
                                    GtkFunction function,
                                    GtkCallbackMarshal marshal,
                                    gpointer data,
                                    GtkDestroyNotify destroy);
void gtk_idle_remove (guint idle_handler_id);
void gtk_idle_remove_by_data (gpointer data);
guint gtk_input_add_full (gint source,
                                    GdkInputCondition condition,
                                    GdkInputFunction function,
                                    GtkCallbackMarshal marshal,
                                    gpointer data,
                                    GtkDestroyNotify destroy);
void gtk_input_remove (guint input_handler_id);


guint gtk_key_snooper_install (GtkKeySnoopFunc snooper,
                                    gpointer func_data);
void gtk_key_snooper_remove (guint snooper_handler_id);

GdkEvent* gtk_get_current_event (void);
guint32 gtk_get_current_event_time (void);
gboolean gtk_get_current_event_state (GdkModifierType *state);

GtkWidget* gtk_get_event_widget (GdkEvent *event);




void gtk_propagate_event (GtkWidget *widget,
                                    GdkEvent *event);

gboolean _gtk_boolean_handled_accumulator (GSignalInvocationHint *ihint,
                                   GValue *return_accu,
                                   const GValue *handler_return,
                                   gpointer dummy);

gchar * _gtk_find_module (const gchar *name,
                              const gchar *type);
gchar **_gtk_get_module_path (const gchar *type);
# 97 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkmenubar.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkmenubar.h" 3 4
typedef struct _GtkMenuBar GtkMenuBar;
typedef struct _GtkMenuBarClass GtkMenuBarClass;

struct _GtkMenuBar
{
  GtkMenuShell menu_shell;
};

struct _GtkMenuBarClass
{
  GtkMenuShellClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_menu_bar_get_type (void) ;
GtkWidget* gtk_menu_bar_new (void);
# 78 "/usr/include/gtk-2.0/gtk/gtkmenubar.h" 3 4
void _gtk_menu_bar_cycle_focus (GtkMenuBar *menubar,
                                GtkDirectionType dir);
# 99 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4


# 1 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h" 1 3 4
# 36 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h" 3 4
typedef enum
{
  GTK_MESSAGE_INFO,
  GTK_MESSAGE_WARNING,
  GTK_MESSAGE_QUESTION,
  GTK_MESSAGE_ERROR
} GtkMessageType;

typedef enum
{
  GTK_BUTTONS_NONE,
  GTK_BUTTONS_OK,
  GTK_BUTTONS_CLOSE,
  GTK_BUTTONS_CANCEL,
  GTK_BUTTONS_YES_NO,
  GTK_BUTTONS_OK_CANCEL
} GtkButtonsType;
# 62 "/usr/include/gtk-2.0/gtk/gtkmessagedialog.h" 3 4
typedef struct _GtkMessageDialog GtkMessageDialog;
typedef struct _GtkMessageDialogClass GtkMessageDialogClass;

struct _GtkMessageDialog
{


  GtkDialog parent_instance;

  GtkWidget *image;
  GtkWidget *label;
};

struct _GtkMessageDialogClass
{
  GtkDialogClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_message_dialog_get_type (void);

GtkWidget* gtk_message_dialog_new (GtkWindow *parent,
                                        GtkDialogFlags flags,
                                        GtkMessageType type,
                                        GtkButtonsType buttons,
                                        const gchar *message_format,
                                        ...) ;
# 102 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtknotebook.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtknotebook.h" 3 4
typedef enum
{
  GTK_NOTEBOOK_TAB_FIRST,
  GTK_NOTEBOOK_TAB_LAST
} GtkNotebookTab;

typedef struct _GtkNotebook GtkNotebook;
typedef struct _GtkNotebookClass GtkNotebookClass;
typedef struct _GtkNotebookPage GtkNotebookPage;

struct _GtkNotebook
{
  GtkContainer container;

  GtkNotebookPage *cur_page;
  GList *children;
  GList *first_tab;
  GList *focus_tab;

  GtkWidget *menu;
  GdkWindow *event_window;

  guint32 timer;

  guint16 tab_hborder;
  guint16 tab_vborder;

  guint show_tabs : 1;
  guint homogeneous : 1;
  guint show_border : 1;
  guint tab_pos : 2;
  guint scrollable : 1;
  guint in_child : 2;
  guint click_child : 2;
  guint button : 2;
  guint need_timer : 1;
  guint child_has_focus : 1;
  guint have_visible_child : 1;
  guint focus_out : 1;
};

struct _GtkNotebookClass
{
  GtkContainerClass parent_class;

  void (* switch_page) (GtkNotebook *notebook,
                              GtkNotebookPage *page,
                              guint page_num);


  gboolean (* select_page) (GtkNotebook *notebook,
                                gboolean move_focus);
  gboolean (* focus_tab) (GtkNotebook *notebook,
                                GtkNotebookTab type);
  void (* change_current_page) (GtkNotebook *notebook,
                                gint offset);
  void (* move_focus_out) (GtkNotebook *notebook,
                                GtkDirectionType direction);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};





GType gtk_notebook_get_type (void) ;
GtkWidget * gtk_notebook_new (void);
void gtk_notebook_append_page (GtkNotebook *notebook,
                                     GtkWidget *child,
                                     GtkWidget *tab_label);
void gtk_notebook_append_page_menu (GtkNotebook *notebook,
                                     GtkWidget *child,
                                     GtkWidget *tab_label,
                                     GtkWidget *menu_label);
void gtk_notebook_prepend_page (GtkNotebook *notebook,
                                     GtkWidget *child,
                                     GtkWidget *tab_label);
void gtk_notebook_prepend_page_menu (GtkNotebook *notebook,
                                     GtkWidget *child,
                                     GtkWidget *tab_label,
                                     GtkWidget *menu_label);
void gtk_notebook_insert_page (GtkNotebook *notebook,
                                     GtkWidget *child,
                                     GtkWidget *tab_label,
                                     gint position);
void gtk_notebook_insert_page_menu (GtkNotebook *notebook,
                                     GtkWidget *child,
                                     GtkWidget *tab_label,
                                     GtkWidget *menu_label,
                                     gint position);
void gtk_notebook_remove_page (GtkNotebook *notebook,
                                     gint page_num);





gint gtk_notebook_get_current_page (GtkNotebook *notebook);
GtkWidget* gtk_notebook_get_nth_page (GtkNotebook *notebook,
                                          gint page_num);
gint gtk_notebook_get_n_pages (GtkNotebook *notebook);
gint gtk_notebook_page_num (GtkNotebook *notebook,
                                          GtkWidget *child);
void gtk_notebook_set_current_page (GtkNotebook *notebook,
                                          gint page_num);
void gtk_notebook_next_page (GtkNotebook *notebook);
void gtk_notebook_prev_page (GtkNotebook *notebook);





void gtk_notebook_set_show_border (GtkNotebook *notebook,
                                            gboolean show_border);
gboolean gtk_notebook_get_show_border (GtkNotebook *notebook);
void gtk_notebook_set_show_tabs (GtkNotebook *notebook,
                                            gboolean show_tabs);
gboolean gtk_notebook_get_show_tabs (GtkNotebook *notebook);
void gtk_notebook_set_tab_pos (GtkNotebook *notebook,
                                            GtkPositionType pos);
GtkPositionType gtk_notebook_get_tab_pos (GtkNotebook *notebook);


void gtk_notebook_set_homogeneous_tabs (GtkNotebook *notebook,
                                            gboolean homogeneous);
void gtk_notebook_set_tab_border (GtkNotebook *notebook,
                                            guint border_width);
void gtk_notebook_set_tab_hborder (GtkNotebook *notebook,
                                            guint tab_hborder);
void gtk_notebook_set_tab_vborder (GtkNotebook *notebook,
                                            guint tab_vborder);


void gtk_notebook_set_scrollable (GtkNotebook *notebook,
                                            gboolean scrollable);
gboolean gtk_notebook_get_scrollable (GtkNotebook *notebook);





void gtk_notebook_popup_enable (GtkNotebook *notebook);
void gtk_notebook_popup_disable (GtkNotebook *notebook);





GtkWidget * gtk_notebook_get_tab_label (GtkNotebook *notebook,
                                           GtkWidget *child);
void gtk_notebook_set_tab_label (GtkNotebook *notebook,
                                           GtkWidget *child,
                                           GtkWidget *tab_label);
void gtk_notebook_set_tab_label_text (GtkNotebook *notebook,
                                           GtkWidget *child,
                                           const gchar *tab_text);
const gchar *gtk_notebook_get_tab_label_text (GtkNotebook *notebook,
                                                       GtkWidget *child);
GtkWidget * gtk_notebook_get_menu_label (GtkNotebook *notebook,
                                           GtkWidget *child);
void gtk_notebook_set_menu_label (GtkNotebook *notebook,
                                           GtkWidget *child,
                                           GtkWidget *menu_label);
void gtk_notebook_set_menu_label_text (GtkNotebook *notebook,
                                           GtkWidget *child,
                                           const gchar *menu_text);
const gchar *gtk_notebook_get_menu_label_text (GtkNotebook *notebook,
                                                        GtkWidget *child);
void gtk_notebook_query_tab_label_packing (GtkNotebook *notebook,
                                           GtkWidget *child,
                                           gboolean *expand,
                                           gboolean *fill,
                                           GtkPackType *pack_type);
void gtk_notebook_set_tab_label_packing (GtkNotebook *notebook,
                                           GtkWidget *child,
                                           gboolean expand,
                                           gboolean fill,
                                           GtkPackType pack_type);
void gtk_notebook_reorder_child (GtkNotebook *notebook,
                                           GtkWidget *child,
                                           gint position);
# 104 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkoldeditable.h" 1 3 4
# 50 "/usr/include/gtk-2.0/gtk/gtkoldeditable.h" 3 4
typedef struct _GtkOldEditable GtkOldEditable;
typedef struct _GtkOldEditableClass GtkOldEditableClass;

typedef void (*GtkTextFunction) (GtkOldEditable *editable, guint32 time_);

struct _GtkOldEditable
{
  GtkWidget widget;


  guint current_pos;

  guint selection_start_pos;
  guint selection_end_pos;
  guint has_selection : 1;


  guint editable : 1;
  guint visible : 1;

  gchar *clipboard_text;
};

struct _GtkOldEditableClass
{
  GtkWidgetClass parent_class;


  void (* activate) (GtkOldEditable *editable);
  void (* set_editable) (GtkOldEditable *editable,
                            gboolean is_editable);
  void (* move_cursor) (GtkOldEditable *editable,
                            gint x,
                            gint y);
  void (* move_word) (GtkOldEditable *editable,
                            gint n);
  void (* move_page) (GtkOldEditable *editable,
                            gint x,
                            gint y);
  void (* move_to_row) (GtkOldEditable *editable,
                            gint row);
  void (* move_to_column) (GtkOldEditable *editable,
                            gint row);
  void (* kill_char) (GtkOldEditable *editable,
                            gint direction);
  void (* kill_word) (GtkOldEditable *editable,
                            gint direction);
  void (* kill_line) (GtkOldEditable *editable,
                            gint direction);
  void (* cut_clipboard) (GtkOldEditable *editable);
  void (* copy_clipboard) (GtkOldEditable *editable);
  void (* paste_clipboard) (GtkOldEditable *editable);






  void (* update_text) (GtkOldEditable *editable,
                         gint start_pos,
                         gint end_pos);
  gchar* (* get_chars) (GtkOldEditable *editable,
                         gint start_pos,
                         gint end_pos);
  void (* set_selection)(GtkOldEditable *editable,
                         gint start_pos,
                         gint end_pos);
  void (* set_position) (GtkOldEditable *editable,
                         gint position);
};

GtkType gtk_old_editable_get_type (void) ;
void gtk_old_editable_claim_selection (GtkOldEditable *old_editable,
                                             gboolean claim,
                                             guint32 time_);
void gtk_old_editable_changed (GtkOldEditable *old_editable);
# 106 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkoptionmenu.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkoptionmenu.h" 3 4
typedef struct _GtkOptionMenu GtkOptionMenu;
typedef struct _GtkOptionMenuClass GtkOptionMenuClass;

struct _GtkOptionMenu
{
  GtkButton button;

  GtkWidget *menu;
  GtkWidget *menu_item;

  guint16 width;
  guint16 height;
};

struct _GtkOptionMenuClass
{
  GtkButtonClass parent_class;

  void (*changed) (GtkOptionMenu *option_menu);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_option_menu_get_type (void) ;
GtkWidget* gtk_option_menu_new (void);
GtkWidget* gtk_option_menu_get_menu (GtkOptionMenu *option_menu);
void gtk_option_menu_set_menu (GtkOptionMenu *option_menu,
                                        GtkWidget *menu);
void gtk_option_menu_remove_menu (GtkOptionMenu *option_menu);
gint gtk_option_menu_get_history (GtkOptionMenu *option_menu);
void gtk_option_menu_set_history (GtkOptionMenu *option_menu,
                                        guint index_);
# 107 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkpixmap.h" 1 3 4
# 50 "/usr/include/gtk-2.0/gtk/gtkpixmap.h" 3 4
typedef struct _GtkPixmap GtkPixmap;
typedef struct _GtkPixmapClass GtkPixmapClass;

struct _GtkPixmap
{
  GtkMisc misc;

  GdkPixmap *pixmap;
  GdkBitmap *mask;

  GdkPixmap *pixmap_insensitive;
  guint build_insensitive : 1;
};

struct _GtkPixmapClass
{
  GtkMiscClass parent_class;
};


GtkType gtk_pixmap_get_type (void) ;
GtkWidget* gtk_pixmap_new (GdkPixmap *pixmap,
                                  GdkBitmap *mask);
void gtk_pixmap_set (GtkPixmap *pixmap,
                                  GdkPixmap *val,
                                  GdkBitmap *mask);
void gtk_pixmap_get (GtkPixmap *pixmap,
                                  GdkPixmap **val,
                                  GdkBitmap **mask);

void gtk_pixmap_set_build_insensitive (GtkPixmap *pixmap,
                                             gboolean build);
# 109 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkplug.h" 1 3 4
# 31 "/usr/include/gtk-2.0/gtk/gtkplug.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtksocket.h" 1 3 4
# 44 "/usr/include/gtk-2.0/gtk/gtksocket.h" 3 4
typedef struct _GtkSocket GtkSocket;
typedef struct _GtkSocketClass GtkSocketClass;

struct _GtkSocket
{
  GtkContainer container;

  guint16 request_width;
  guint16 request_height;
  guint16 current_width;
  guint16 current_height;

  GdkWindow *plug_window;
  GtkWidget *plug_widget;

  gshort xembed_version;
  guint same_app : 1;
  guint focus_in : 1;
  guint have_size : 1;
  guint need_map : 1;
  guint is_mapped : 1;
  guint active : 1;

  GtkAccelGroup *accel_group;
  GtkWidget *toplevel;
};

struct _GtkSocketClass
{
  GtkContainerClass parent_class;

  void (*plug_added) (GtkSocket *socket_);
  gboolean (*plug_removed) (GtkSocket *socket_);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_socket_get_type (void) ;
GtkWidget* gtk_socket_new (void);

void gtk_socket_add_id (GtkSocket *socket_,
                                   GdkNativeWindow window_id);
GdkNativeWindow gtk_socket_get_id (GtkSocket *socket_);


void gtk_socket_steal (GtkSocket *socket_,
                                    GdkNativeWindow wid);
# 32 "/usr/include/gtk-2.0/gtk/gtkplug.h" 2 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkplug.h" 3 4
typedef struct _GtkPlug GtkPlug;
typedef struct _GtkPlugClass GtkPlugClass;


struct _GtkPlug
{
  GtkWindow window;

  GdkWindow *socket_window;
  GtkWidget *modality_window;
  GtkWindowGroup *modality_group;
  GHashTable *grabbed_keys;

  guint same_app : 1;
};

struct _GtkPlugClass
{
  GtkWindowClass parent_class;

  void (*embedded) (GtkPlug *plug);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_plug_get_type (void) ;


void gtk_plug_construct (GtkPlug *plug,
                               GdkNativeWindow socket_id);
GtkWidget* gtk_plug_new (GdkNativeWindow socket_id);


void gtk_plug_construct_for_display (GtkPlug *plug,
                                           GdkDisplay *display,
                                           GdkNativeWindow socket_id);
GtkWidget* gtk_plug_new_for_display (GdkDisplay *display,
                                           GdkNativeWindow socket_id);

GdkNativeWindow gtk_plug_get_id (GtkPlug *plug);

void _gtk_plug_add_to_socket (GtkPlug *plug,
                                   GtkSocket *socket_);
void _gtk_plug_remove_from_socket (GtkPlug *plug,
                                   GtkSocket *socket_);
# 110 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkpreview.h" 1 3 4
# 49 "/usr/include/gtk-2.0/gtk/gtkpreview.h" 3 4
typedef struct _GtkPreview GtkPreview;
typedef struct _GtkPreviewInfo GtkPreviewInfo;
typedef union _GtkDitherInfo GtkDitherInfo;
typedef struct _GtkPreviewClass GtkPreviewClass;

struct _GtkPreview
{
  GtkWidget widget;

  guchar *buffer;
  guint16 buffer_width;
  guint16 buffer_height;

  guint16 bpp;
  guint16 rowstride;

  GdkRgbDither dither;

  guint type : 1;
  guint expand : 1;
};

struct _GtkPreviewInfo
{
  guchar *lookup;

  gdouble gamma;
};

union _GtkDitherInfo
{
  gushort s[2];
  guchar c[4];
};

struct _GtkPreviewClass
{
  GtkWidgetClass parent_class;

  GtkPreviewInfo info;

};


GtkType gtk_preview_get_type (void) ;
void gtk_preview_uninit (void);
GtkWidget* gtk_preview_new (GtkPreviewType type);
void gtk_preview_size (GtkPreview *preview,
                                                gint width,
                                                gint height);
void gtk_preview_put (GtkPreview *preview,
                                                GdkWindow *window,
                                                GdkGC *gc,
                                                gint srcx,
                                                gint srcy,
                                                gint destx,
                                                gint desty,
                                                gint width,
                                                gint height);
void gtk_preview_draw_row (GtkPreview *preview,
                                                guchar *data,
                                                gint x,
                                                gint y,
                                                gint w);
void gtk_preview_set_expand (GtkPreview *preview,
                                                gboolean expand);

void gtk_preview_set_gamma (double gamma_);
void gtk_preview_set_color_cube (guint nred_shades,
                                                guint ngreen_shades,
                                                guint nblue_shades,
                                                guint ngray_shades);
void gtk_preview_set_install_cmap (gint install_cmap);
void gtk_preview_set_reserved (gint nreserved);
void gtk_preview_set_dither (GtkPreview *preview,
                                                GdkRgbDither dither);

GdkVisual* gtk_preview_get_visual (void);
GdkColormap* gtk_preview_get_cmap (void);

GtkPreviewInfo* gtk_preview_get_info (void);






void gtk_preview_reset (void);
# 111 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkprogress.h" 1 3 4
# 51 "/usr/include/gtk-2.0/gtk/gtkprogress.h" 3 4
typedef struct _GtkProgress GtkProgress;
typedef struct _GtkProgressClass GtkProgressClass;


struct _GtkProgress
{
  GtkWidget widget;

  GtkAdjustment *adjustment;
  GdkPixmap *offscreen_pixmap;
  gchar *format;
  gfloat x_align;
  gfloat y_align;

  guint show_text : 1;
  guint activity_mode : 1;
  guint use_text_format : 1;
};

struct _GtkProgressClass
{
  GtkWidgetClass parent_class;

  void (* paint) (GtkProgress *progress);
  void (* update) (GtkProgress *progress);
  void (* act_mode_enter) (GtkProgress *progress);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};







GType gtk_progress_get_type (void) ;
void gtk_progress_set_show_text (GtkProgress *progress,
                                             gboolean show_text);
void gtk_progress_set_text_alignment (GtkProgress *progress,
                                             gfloat x_align,
                                             gfloat y_align);
void gtk_progress_set_format_string (GtkProgress *progress,
                                             const gchar *format);
void gtk_progress_set_adjustment (GtkProgress *progress,
                                             GtkAdjustment *adjustment);
void gtk_progress_configure (GtkProgress *progress,
                                             gdouble value,
                                             gdouble min,
                                             gdouble max);
void gtk_progress_set_percentage (GtkProgress *progress,
                                             gdouble percentage);
void gtk_progress_set_value (GtkProgress *progress,
                                             gdouble value);
gdouble gtk_progress_get_value (GtkProgress *progress);
void gtk_progress_set_activity_mode (GtkProgress *progress,
                                             gboolean activity_mode);
gchar* gtk_progress_get_current_text (GtkProgress *progress);
gchar* gtk_progress_get_text_from_value (GtkProgress *progress,
                                             gdouble value);
gdouble gtk_progress_get_current_percentage (GtkProgress *progress);
gdouble gtk_progress_get_percentage_from_value (GtkProgress *progress,
                                                   gdouble value);
# 112 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h" 3 4
typedef struct _GtkProgressBar GtkProgressBar;
typedef struct _GtkProgressBarClass GtkProgressBarClass;

typedef enum
{
  GTK_PROGRESS_CONTINUOUS,
  GTK_PROGRESS_DISCRETE
} GtkProgressBarStyle;

typedef enum
{
  GTK_PROGRESS_LEFT_TO_RIGHT,
  GTK_PROGRESS_RIGHT_TO_LEFT,
  GTK_PROGRESS_BOTTOM_TO_TOP,
  GTK_PROGRESS_TOP_TO_BOTTOM
} GtkProgressBarOrientation;

struct _GtkProgressBar
{
  GtkProgress progress;

  GtkProgressBarStyle bar_style;
  GtkProgressBarOrientation orientation;

  guint blocks;
  gint in_block;

  gint activity_pos;
  guint activity_step;
  guint activity_blocks;

  gdouble pulse_fraction;

  guint activity_dir : 1;
};

struct _GtkProgressBarClass
{
  GtkProgressClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_progress_bar_get_type (void) ;
GtkWidget* gtk_progress_bar_new (void);
# 126 "/usr/include/gtk-2.0/gtk/gtkprogressbar.h" 3 4
void gtk_progress_bar_pulse (GtkProgressBar *pbar);
void gtk_progress_bar_set_text (GtkProgressBar *pbar,
                                                  const gchar *text);
void gtk_progress_bar_set_fraction (GtkProgressBar *pbar,
                                                  gdouble fraction);

void gtk_progress_bar_set_pulse_step (GtkProgressBar *pbar,
                                                  gdouble fraction);
void gtk_progress_bar_set_orientation (GtkProgressBar *pbar,
                                                  GtkProgressBarOrientation orientation);

const gchar* gtk_progress_bar_get_text (GtkProgressBar *pbar);
gdouble gtk_progress_bar_get_fraction (GtkProgressBar *pbar);
gdouble gtk_progress_bar_get_pulse_step (GtkProgressBar *pbar);

GtkProgressBarOrientation gtk_progress_bar_get_orientation (GtkProgressBar *pbar);





GtkWidget* gtk_progress_bar_new_with_adjustment (GtkAdjustment *adjustment);
void gtk_progress_bar_set_bar_style (GtkProgressBar *pbar,
                                                  GtkProgressBarStyle style);
void gtk_progress_bar_set_discrete_blocks (GtkProgressBar *pbar,
                                                  guint blocks);




void gtk_progress_bar_set_activity_step (GtkProgressBar *pbar,
                                                  guint step);
void gtk_progress_bar_set_activity_blocks (GtkProgressBar *pbar,
                                                  guint blocks);
void gtk_progress_bar_update (GtkProgressBar *pbar,
                                                  gdouble percentage);
# 113 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkradiobutton.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkradiobutton.h" 3 4
typedef struct _GtkRadioButton GtkRadioButton;
typedef struct _GtkRadioButtonClass GtkRadioButtonClass;

struct _GtkRadioButton
{
  GtkCheckButton check_button;

  GSList *group;
};

struct _GtkRadioButtonClass
{
  GtkCheckButtonClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_radio_button_get_type (void) ;

GtkWidget* gtk_radio_button_new (GSList *group);
GtkWidget* gtk_radio_button_new_from_widget (GtkRadioButton *group);
GtkWidget* gtk_radio_button_new_with_label (GSList *group,
                                                           const gchar *label);
GtkWidget* gtk_radio_button_new_with_label_from_widget (GtkRadioButton *group,
                                                           const gchar *label);
GtkWidget* gtk_radio_button_new_with_mnemonic (GSList *group,
                                                           const gchar *label);
GtkWidget* gtk_radio_button_new_with_mnemonic_from_widget (GtkRadioButton *group,
                                                           const gchar *label);
GSList* gtk_radio_button_get_group (GtkRadioButton *radio_button);
void gtk_radio_button_set_group (GtkRadioButton *radio_button,
                                                           GSList *group);
# 114 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h" 3 4
typedef struct _GtkRadioMenuItem GtkRadioMenuItem;
typedef struct _GtkRadioMenuItemClass GtkRadioMenuItemClass;

struct _GtkRadioMenuItem
{
  GtkCheckMenuItem check_menu_item;

  GSList *group;
};

struct _GtkRadioMenuItemClass
{
  GtkCheckMenuItemClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_radio_menu_item_get_type (void) ;
GtkWidget* gtk_radio_menu_item_new (GSList *group);
GtkWidget* gtk_radio_menu_item_new_with_label (GSList *group,
                                                  const gchar *label);
GtkWidget* gtk_radio_menu_item_new_with_mnemonic (GSList *group,
                                                  const gchar *label);
GSList* gtk_radio_menu_item_get_group (GtkRadioMenuItem *radio_menu_item);
void gtk_radio_menu_item_set_group (GtkRadioMenuItem *radio_menu_item,
                                                  GSList *group);
# 115 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4





# 1 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h" 1 3 4
# 34 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkviewport.h" 1 3 4
# 49 "/usr/include/gtk-2.0/gtk/gtkviewport.h" 3 4
typedef struct _GtkViewport GtkViewport;
typedef struct _GtkViewportClass GtkViewportClass;

struct _GtkViewport
{
  GtkBin bin;

  GtkShadowType shadow_type;
  GdkWindow *view_window;
  GdkWindow *bin_window;
  GtkAdjustment *hadjustment;
  GtkAdjustment *vadjustment;
};

struct _GtkViewportClass
{
  GtkBinClass parent_class;

  void (*set_scroll_adjustments) (GtkViewport *viewport,
                                         GtkAdjustment *hadjustment,
                                         GtkAdjustment *vadjustment);
};


GType gtk_viewport_get_type (void) ;
GtkWidget* gtk_viewport_new (GtkAdjustment *hadjustment,
                                             GtkAdjustment *vadjustment);
GtkAdjustment* gtk_viewport_get_hadjustment (GtkViewport *viewport);
GtkAdjustment* gtk_viewport_get_vadjustment (GtkViewport *viewport);
void gtk_viewport_set_hadjustment (GtkViewport *viewport,
                                             GtkAdjustment *adjustment);
void gtk_viewport_set_vadjustment (GtkViewport *viewport,
                                             GtkAdjustment *adjustment);
void gtk_viewport_set_shadow_type (GtkViewport *viewport,
                                             GtkShadowType type);
GtkShadowType gtk_viewport_get_shadow_type (GtkViewport *viewport);
# 35 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h" 2 3 4
# 51 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h" 3 4
typedef struct _GtkScrolledWindow GtkScrolledWindow;
typedef struct _GtkScrolledWindowClass GtkScrolledWindowClass;

struct _GtkScrolledWindow
{
  GtkBin container;

  GtkWidget *hscrollbar;
  GtkWidget *vscrollbar;

  guint hscrollbar_policy : 2;
  guint vscrollbar_policy : 2;
  guint hscrollbar_visible : 1;
  guint vscrollbar_visible : 1;
  guint window_placement : 2;
  guint focus_out : 1;

  guint16 shadow_type;
};

struct _GtkScrolledWindowClass
{
  GtkBinClass parent_class;

  gint scrollbar_spacing;
# 84 "/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h" 3 4
  void (*scroll_child) (GtkScrolledWindow *scrolled_window,
                        GtkScrollType scroll,
                        gboolean horizontal);

  void (* move_focus_out) (GtkScrolledWindow *scrolled_window,
                           GtkDirectionType direction);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_scrolled_window_get_type (void) ;
GtkWidget* gtk_scrolled_window_new (GtkAdjustment *hadjustment,
                                                      GtkAdjustment *vadjustment);
void gtk_scrolled_window_set_hadjustment (GtkScrolledWindow *scrolled_window,
                                                      GtkAdjustment *hadjustment);
void gtk_scrolled_window_set_vadjustment (GtkScrolledWindow *scrolled_window,
                                                      GtkAdjustment *hadjustment);
GtkAdjustment* gtk_scrolled_window_get_hadjustment (GtkScrolledWindow *scrolled_window);
GtkAdjustment* gtk_scrolled_window_get_vadjustment (GtkScrolledWindow *scrolled_window);
void gtk_scrolled_window_set_policy (GtkScrolledWindow *scrolled_window,
                                                      GtkPolicyType hscrollbar_policy,
                                                      GtkPolicyType vscrollbar_policy);
void gtk_scrolled_window_get_policy (GtkScrolledWindow *scrolled_window,
                                                      GtkPolicyType *hscrollbar_policy,
                                                      GtkPolicyType *vscrollbar_policy);
void gtk_scrolled_window_set_placement (GtkScrolledWindow *scrolled_window,
                                                      GtkCornerType window_placement);
GtkCornerType gtk_scrolled_window_get_placement (GtkScrolledWindow *scrolled_window);
void gtk_scrolled_window_set_shadow_type (GtkScrolledWindow *scrolled_window,
                                                      GtkShadowType type);
GtkShadowType gtk_scrolled_window_get_shadow_type (GtkScrolledWindow *scrolled_window);
void gtk_scrolled_window_add_with_viewport (GtkScrolledWindow *scrolled_window,
                                                      GtkWidget *child);

gint _gtk_scrolled_window_get_scrollbar_spacing (GtkScrolledWindow *scrolled_window);
# 121 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4


# 1 "/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h" 1 3 4
# 47 "/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h" 3 4
typedef struct _GtkSeparatorMenuItem GtkSeparatorMenuItem;
typedef struct _GtkSeparatorMenuItemClass GtkSeparatorMenuItemClass;

struct _GtkSeparatorMenuItem
{
  GtkMenuItem menu_item;
};

struct _GtkSeparatorMenuItemClass
{
  GtkMenuItemClass parent_class;
};


GType gtk_separator_menu_item_get_type (void) ;
GtkWidget* gtk_separator_menu_item_new (void);
# 124 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4


# 1 "/usr/include/gtk-2.0/gtk/gtksizegroup.h" 1 3 4
# 38 "/usr/include/gtk-2.0/gtk/gtksizegroup.h" 3 4
typedef struct _GtkSizeGroup GtkSizeGroup;
typedef struct _GtkSizeGroupClass GtkSizeGroupClass;

struct _GtkSizeGroup
{
  GObject parent_instance;

  GSList *widgets;

  guint8 mode;

  guint have_width : 1;
  guint have_height : 1;

  GtkRequisition requisition;
};

struct _GtkSizeGroupClass
{
  GObjectClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};
# 76 "/usr/include/gtk-2.0/gtk/gtksizegroup.h" 3 4
typedef enum {
  GTK_SIZE_GROUP_NONE,
  GTK_SIZE_GROUP_HORIZONTAL,
  GTK_SIZE_GROUP_VERTICAL,
  GTK_SIZE_GROUP_BOTH
} GtkSizeGroupMode;

GType gtk_size_group_get_type (void) ;

GtkSizeGroup * gtk_size_group_new (GtkSizeGroupMode mode);
void gtk_size_group_set_mode (GtkSizeGroup *size_group,
                                               GtkSizeGroupMode mode);
GtkSizeGroupMode gtk_size_group_get_mode (GtkSizeGroup *size_group);
void gtk_size_group_add_widget (GtkSizeGroup *size_group,
                                               GtkWidget *widget);
void gtk_size_group_remove_widget (GtkSizeGroup *size_group,
                                               GtkWidget *widget);


void _gtk_size_group_get_child_requisition (GtkWidget *widget,
                                            GtkRequisition *requisition);
void _gtk_size_group_compute_requisition (GtkWidget *widget,
                                            GtkRequisition *requisition);
void _gtk_size_group_queue_resize (GtkWidget *widget);
# 127 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h" 1 3 4
# 53 "/usr/include/gtk-2.0/gtk/gtkspinbutton.h" 3 4
typedef enum
{
  GTK_UPDATE_ALWAYS,
  GTK_UPDATE_IF_VALID
} GtkSpinButtonUpdatePolicy;

typedef enum
{
  GTK_SPIN_STEP_FORWARD,
  GTK_SPIN_STEP_BACKWARD,
  GTK_SPIN_PAGE_FORWARD,
  GTK_SPIN_PAGE_BACKWARD,
  GTK_SPIN_HOME,
  GTK_SPIN_END,
  GTK_SPIN_USER_DEFINED
} GtkSpinType;


typedef struct _GtkSpinButton GtkSpinButton;
typedef struct _GtkSpinButtonClass GtkSpinButtonClass;


struct _GtkSpinButton
{
  GtkEntry entry;

  GtkAdjustment *adjustment;

  GdkWindow *panel;

  guint32 timer;

  gdouble climb_rate;
  gdouble timer_step;

  GtkSpinButtonUpdatePolicy update_policy;

  guint in_child : 2;
  guint click_child : 2;
  guint button : 2;
  guint need_timer : 1;
  guint timer_calls : 3;
  guint digits : 10;
  guint numeric : 1;
  guint wrap : 1;
  guint snap_to_ticks : 1;
};

struct _GtkSpinButtonClass
{
  GtkEntryClass parent_class;

  gint (*input) (GtkSpinButton *spin_button,
                  gdouble *new_value);
  gint (*output) (GtkSpinButton *spin_button);
  void (*value_changed) (GtkSpinButton *spin_button);


  void (*change_value) (GtkSpinButton *spin_button,
                        GtkScrollType scroll);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_spin_button_get_type (void) ;

void gtk_spin_button_configure (GtkSpinButton *spin_button,
                                                    GtkAdjustment *adjustment,
                                                    gdouble climb_rate,
                                                    guint digits);

GtkWidget* gtk_spin_button_new (GtkAdjustment *adjustment,
                                                    gdouble climb_rate,
                                                    guint digits);

GtkWidget* gtk_spin_button_new_with_range (gdouble min,
                                                    gdouble max,
                                                    gdouble step);

void gtk_spin_button_set_adjustment (GtkSpinButton *spin_button,
                                                    GtkAdjustment *adjustment);

GtkAdjustment* gtk_spin_button_get_adjustment (GtkSpinButton *spin_button);

void gtk_spin_button_set_digits (GtkSpinButton *spin_button,
                                                    guint digits);
guint gtk_spin_button_get_digits (GtkSpinButton *spin_button);

void gtk_spin_button_set_increments (GtkSpinButton *spin_button,
                                                    gdouble step,
                                                    gdouble page);
void gtk_spin_button_get_increments (GtkSpinButton *spin_button,
                                                    gdouble *step,
                                                    gdouble *page);

void gtk_spin_button_set_range (GtkSpinButton *spin_button,
                                                    gdouble min,
                                                    gdouble max);
void gtk_spin_button_get_range (GtkSpinButton *spin_button,
                                                    gdouble *min,
                                                    gdouble *max);

gdouble gtk_spin_button_get_value (GtkSpinButton *spin_button);

gint gtk_spin_button_get_value_as_int (GtkSpinButton *spin_button);

void gtk_spin_button_set_value (GtkSpinButton *spin_button,
                                                    gdouble value);

void gtk_spin_button_set_update_policy (GtkSpinButton *spin_button,
                                                    GtkSpinButtonUpdatePolicy policy);
GtkSpinButtonUpdatePolicy gtk_spin_button_get_update_policy (GtkSpinButton *spin_button);

void gtk_spin_button_set_numeric (GtkSpinButton *spin_button,
                                                    gboolean numeric);
gboolean gtk_spin_button_get_numeric (GtkSpinButton *spin_button);

void gtk_spin_button_spin (GtkSpinButton *spin_button,
                                                    GtkSpinType direction,
                                                    gdouble increment);

void gtk_spin_button_set_wrap (GtkSpinButton *spin_button,
                                                    gboolean wrap);
gboolean gtk_spin_button_get_wrap (GtkSpinButton *spin_button);

void gtk_spin_button_set_snap_to_ticks (GtkSpinButton *spin_button,
                                                    gboolean snap_to_ticks);
gboolean gtk_spin_button_get_snap_to_ticks (GtkSpinButton *spin_button);
void gtk_spin_button_update (GtkSpinButton *spin_button);
# 129 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkstock.h" 1 3 4
# 37 "/usr/include/gtk-2.0/gtk/gtkstock.h" 3 4
typedef struct _GtkStockItem GtkStockItem;

struct _GtkStockItem
{
  gchar *stock_id;
  gchar *label;
  GdkModifierType modifier;
  guint keyval;
  gchar *translation_domain;
};

void gtk_stock_add (const GtkStockItem *items,
                               guint n_items);
void gtk_stock_add_static (const GtkStockItem *items,
                               guint n_items);
gboolean gtk_stock_lookup (const gchar *stock_id,
                               GtkStockItem *item);




GSList* gtk_stock_list_ids (void);

GtkStockItem *gtk_stock_item_copy (const GtkStockItem *item);
void gtk_stock_item_free (GtkStockItem *item);
# 130 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkstatusbar.h" 1 3 4
# 46 "/usr/include/gtk-2.0/gtk/gtkstatusbar.h" 3 4
typedef struct _GtkStatusbar GtkStatusbar;
typedef struct _GtkStatusbarClass GtkStatusbarClass;

struct _GtkStatusbar
{
  GtkHBox parent_widget;

  GtkWidget *frame;
  GtkWidget *label;

  GSList *messages;
  GSList *keys;

  guint seq_context_id;
  guint seq_message_id;

  GdkWindow *grip_window;

  guint has_resize_grip : 1;
};

struct _GtkStatusbarClass
{
  GtkHBoxClass parent_class;

  GMemChunk *messages_mem_chunk;

  void (*text_pushed) (GtkStatusbar *statusbar,
                         guint context_id,
                         const gchar *text);
  void (*text_popped) (GtkStatusbar *statusbar,
                         guint context_id,
                         const gchar *text);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_statusbar_get_type (void) ;
GtkWidget* gtk_statusbar_new (void);



guint gtk_statusbar_get_context_id (GtkStatusbar *statusbar,
                                         const gchar *context_description);

guint gtk_statusbar_push (GtkStatusbar *statusbar,
                                         guint context_id,
                                         const gchar *text);
void gtk_statusbar_pop (GtkStatusbar *statusbar,
                                         guint context_id);
void gtk_statusbar_remove (GtkStatusbar *statusbar,
                                         guint context_id,
                                         guint message_id);

void gtk_statusbar_set_has_resize_grip (GtkStatusbar *statusbar,
                                            gboolean setting);
gboolean gtk_statusbar_get_has_resize_grip (GtkStatusbar *statusbar);
# 132 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktable.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtktable.h" 3 4
typedef struct _GtkTable GtkTable;
typedef struct _GtkTableClass GtkTableClass;
typedef struct _GtkTableChild GtkTableChild;
typedef struct _GtkTableRowCol GtkTableRowCol;

struct _GtkTable
{
  GtkContainer container;

  GList *children;
  GtkTableRowCol *rows;
  GtkTableRowCol *cols;
  guint16 nrows;
  guint16 ncols;
  guint16 column_spacing;
  guint16 row_spacing;
  guint homogeneous : 1;
};

struct _GtkTableClass
{
  GtkContainerClass parent_class;
};

struct _GtkTableChild
{
  GtkWidget *widget;
  guint16 left_attach;
  guint16 right_attach;
  guint16 top_attach;
  guint16 bottom_attach;
  guint16 xpadding;
  guint16 ypadding;
  guint xexpand : 1;
  guint yexpand : 1;
  guint xshrink : 1;
  guint yshrink : 1;
  guint xfill : 1;
  guint yfill : 1;
};

struct _GtkTableRowCol
{
  guint16 requisition;
  guint16 allocation;
  guint16 spacing;
  guint need_expand : 1;
  guint need_shrink : 1;
  guint expand : 1;
  guint shrink : 1;
  guint empty : 1;
};


GType gtk_table_get_type (void) ;
GtkWidget* gtk_table_new (guint rows,
                                       guint columns,
                                       gboolean homogeneous);
void gtk_table_resize (GtkTable *table,
                                       guint rows,
                                       guint columns);
void gtk_table_attach (GtkTable *table,
                                       GtkWidget *child,
                                       guint left_attach,
                                       guint right_attach,
                                       guint top_attach,
                                       guint bottom_attach,
                                       GtkAttachOptions xoptions,
                                       GtkAttachOptions yoptions,
                                       guint xpadding,
                                       guint ypadding);
void gtk_table_attach_defaults (GtkTable *table,
                                       GtkWidget *widget,
                                       guint left_attach,
                                       guint right_attach,
                                       guint top_attach,
                                       guint bottom_attach);
void gtk_table_set_row_spacing (GtkTable *table,
                                       guint row,
                                       guint spacing);
guint gtk_table_get_row_spacing (GtkTable *table,
                                       guint row);
void gtk_table_set_col_spacing (GtkTable *table,
                                       guint column,
                                       guint spacing);
guint gtk_table_get_col_spacing (GtkTable *table,
                                       guint column);
void gtk_table_set_row_spacings (GtkTable *table,
                                       guint spacing);
guint gtk_table_get_default_row_spacing (GtkTable *table);
void gtk_table_set_col_spacings (GtkTable *table,
                                       guint spacing);
guint gtk_table_get_default_col_spacing (GtkTable *table);
void gtk_table_set_homogeneous (GtkTable *table,
                                       gboolean homogeneous);
gboolean gtk_table_get_homogeneous (GtkTable *table);
# 133 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h" 3 4
typedef struct _GtkTearoffMenuItem GtkTearoffMenuItem;
typedef struct _GtkTearoffMenuItemClass GtkTearoffMenuItemClass;

struct _GtkTearoffMenuItem
{
  GtkMenuItem menu_item;

  guint torn_off : 1;
};

struct _GtkTearoffMenuItemClass
{
  GtkMenuItemClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_tearoff_menu_item_get_type (void) ;
GtkWidget* gtk_tearoff_menu_item_new (void);
# 134 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktext.h" 1 3 4
# 135 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h" 1 3 4
# 32 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktexttagtable.h" 1 3 4



# 1 "/usr/include/gtk-2.0/gtk/gtktexttag.h" 1 3 4
# 15 "/usr/include/gtk-2.0/gtk/gtktexttag.h" 3 4
typedef struct _GtkTextIter GtkTextIter;
typedef struct _GtkTextTagTable GtkTextTagTable;

typedef struct _GtkTextAttributes GtkTextAttributes;
# 29 "/usr/include/gtk-2.0/gtk/gtktexttag.h" 3 4
typedef struct _GtkTextTag GtkTextTag;
typedef struct _GtkTextTagClass GtkTextTagClass;

struct _GtkTextTag
{
  GObject parent_instance;

  GtkTextTagTable *table;

  char *name;



  int priority;
# 54 "/usr/include/gtk-2.0/gtk/gtktexttag.h" 3 4
  GtkTextAttributes *values;




  guint bg_color_set : 1;
  guint bg_stipple_set : 1;
  guint fg_color_set : 1;
  guint scale_set : 1;
  guint fg_stipple_set : 1;
  guint justification_set : 1;
  guint left_margin_set : 1;
  guint indent_set : 1;
  guint rise_set : 1;
  guint strikethrough_set : 1;
  guint right_margin_set : 1;
  guint pixels_above_lines_set : 1;
  guint pixels_below_lines_set : 1;
  guint pixels_inside_wrap_set : 1;
  guint tabs_set : 1;
  guint underline_set : 1;
  guint wrap_mode_set : 1;
  guint bg_full_height_set : 1;
  guint invisible_set : 1;
  guint editable_set : 1;
  guint language_set : 1;
  guint pad1 : 1;
  guint pad2 : 1;
  guint pad3 : 1;
};

struct _GtkTextTagClass
{
  GObjectClass parent_class;

  gboolean (* event) (GtkTextTag *tag,
                      GObject *event_object,
                      GdkEvent *event,
                      const GtkTextIter *iter);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_text_tag_get_type (void) ;
GtkTextTag *gtk_text_tag_new (const gchar *name);
gint gtk_text_tag_get_priority (GtkTextTag *tag);
void gtk_text_tag_set_priority (GtkTextTag *tag,
                                        gint priority);
gboolean gtk_text_tag_event (GtkTextTag *tag,
                                        GObject *event_object,
                                        GdkEvent *event,
                                        const GtkTextIter *iter);





typedef struct _GtkTextAppearance GtkTextAppearance;

struct _GtkTextAppearance
{

  GdkColor bg_color;
  GdkColor fg_color;
  GdkBitmap *bg_stipple;
  GdkBitmap *fg_stipple;


  gint rise;





  gpointer padding1;


  guint underline : 4;
  guint strikethrough : 1;






  guint draw_bg : 1;





  guint inside_selection : 1;
  guint is_text : 1;


  guint pad1 : 1;
  guint pad2 : 1;
  guint pad3 : 1;
  guint pad4 : 1;
};

struct _GtkTextAttributes
{

  guint refcount;


  GtkTextAppearance appearance;

  GtkJustification justification;
  GtkTextDirection direction;


  PangoFontDescription *font;

  gdouble font_scale;

  gint left_margin;

  gint indent;

  gint right_margin;

  gint pixels_above_lines;

  gint pixels_below_lines;

  gint pixels_inside_wrap;

  PangoTabArray *tabs;

  GtkWrapMode wrap_mode;




  PangoLanguage *language;





  gpointer padding1;



  guint invisible : 1;




  guint bg_full_height : 1;


  guint editable : 1;


  guint realized : 1;


  guint pad1 : 1;
  guint pad2 : 1;
  guint pad3 : 1;
  guint pad4 : 1;
};

GtkTextAttributes* gtk_text_attributes_new (void);
GtkTextAttributes* gtk_text_attributes_copy (GtkTextAttributes *src);
void gtk_text_attributes_copy_values (GtkTextAttributes *src,
                                                    GtkTextAttributes *dest);
void gtk_text_attributes_unref (GtkTextAttributes *values);
void gtk_text_attributes_ref (GtkTextAttributes *values);

GType gtk_text_attributes_get_type (void);
# 5 "/usr/include/gtk-2.0/gtk/gtktexttagtable.h" 2 3 4







typedef void (* GtkTextTagTableForeach) (GtkTextTag *tag, gpointer data);
# 21 "/usr/include/gtk-2.0/gtk/gtktexttagtable.h" 3 4
typedef struct _GtkTextTagTableClass GtkTextTagTableClass;

struct _GtkTextTagTable
{
  GObject parent_instance;

  GHashTable *hash;
  GSList *anonymous;
  gint anon_count;

  GSList *buffers;
};

struct _GtkTextTagTableClass
{
  GObjectClass parent_class;

  void (* tag_changed) (GtkTextTagTable *table, GtkTextTag *tag, gboolean size_changed);
  void (* tag_added) (GtkTextTagTable *table, GtkTextTag *tag);
  void (* tag_removed) (GtkTextTagTable *table, GtkTextTag *tag);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_text_tag_table_get_type (void) ;

GtkTextTagTable *gtk_text_tag_table_new (void);
void gtk_text_tag_table_add (GtkTextTagTable *table,
                                              GtkTextTag *tag);
void gtk_text_tag_table_remove (GtkTextTagTable *table,
                                              GtkTextTag *tag);
GtkTextTag *gtk_text_tag_table_lookup (GtkTextTagTable *table,
                                              const gchar *name);
void gtk_text_tag_table_foreach (GtkTextTagTable *table,
                                              GtkTextTagTableForeach func,
                                              gpointer data);
gint gtk_text_tag_table_get_size (GtkTextTagTable *table);





void _gtk_text_tag_table_add_buffer (GtkTextTagTable *table,
                                        gpointer buffer);
void _gtk_text_tag_table_remove_buffer (GtkTextTagTable *table,
                                        gpointer buffer);
# 33 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktextiter.h" 1 3 4
# 31 "/usr/include/gtk-2.0/gtk/gtktextiter.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktextchild.h" 1 3 4
# 42 "/usr/include/gtk-2.0/gtk/gtktextchild.h" 3 4
typedef struct _GtkTextChildAnchor GtkTextChildAnchor;
typedef struct _GtkTextChildAnchorClass GtkTextChildAnchorClass;
# 52 "/usr/include/gtk-2.0/gtk/gtktextchild.h" 3 4
struct _GtkTextChildAnchor
{
  GObject parent_instance;

  gpointer segment;
};

struct _GtkTextChildAnchorClass
{
  GObjectClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_text_child_anchor_get_type (void) ;

GtkTextChildAnchor* gtk_text_child_anchor_new (void);

GList* gtk_text_child_anchor_get_widgets (GtkTextChildAnchor *anchor);
gboolean gtk_text_child_anchor_get_deleted (GtkTextChildAnchor *anchor);
# 32 "/usr/include/gtk-2.0/gtk/gtktextiter.h" 2 3 4





typedef enum {
  GTK_TEXT_SEARCH_VISIBLE_ONLY,
  GTK_TEXT_SEARCH_TEXT_ONLY

} GtkTextSearchFlags;







typedef struct _GtkTextBuffer GtkTextBuffer;



struct _GtkTextIter {





  gpointer dummy1;
  gpointer dummy2;
  gint dummy3;
  gint dummy4;
  gint dummy5;
  gint dummy6;
  gint dummy7;
  gint dummy8;
  gpointer dummy9;
  gpointer dummy10;
  gint dummy11;
  gint dummy12;

  gint dummy13;
  gpointer dummy14;
};




GtkTextBuffer *gtk_text_iter_get_buffer (const GtkTextIter *iter);





GtkTextIter *gtk_text_iter_copy (const GtkTextIter *iter);
void gtk_text_iter_free (GtkTextIter *iter);

GType gtk_text_iter_get_type (void);





gint gtk_text_iter_get_offset (const GtkTextIter *iter);
gint gtk_text_iter_get_line (const GtkTextIter *iter);
gint gtk_text_iter_get_line_offset (const GtkTextIter *iter);
gint gtk_text_iter_get_line_index (const GtkTextIter *iter);

gint gtk_text_iter_get_visible_line_offset (const GtkTextIter *iter);
gint gtk_text_iter_get_visible_line_index (const GtkTextIter *iter);





gunichar gtk_text_iter_get_char (const GtkTextIter *iter);




gchar *gtk_text_iter_get_slice (const GtkTextIter *start,
                                          const GtkTextIter *end);


gchar *gtk_text_iter_get_text (const GtkTextIter *start,
                                          const GtkTextIter *end);

gchar *gtk_text_iter_get_visible_slice (const GtkTextIter *start,
                                          const GtkTextIter *end);
gchar *gtk_text_iter_get_visible_text (const GtkTextIter *start,
                                          const GtkTextIter *end);

GdkPixbuf* gtk_text_iter_get_pixbuf (const GtkTextIter *iter);
GSList * gtk_text_iter_get_marks (const GtkTextIter *iter);

GtkTextChildAnchor* gtk_text_iter_get_child_anchor (const GtkTextIter *iter);




GSList *gtk_text_iter_get_toggled_tags (const GtkTextIter *iter,
                                          gboolean toggled_on);

gboolean gtk_text_iter_begins_tag (const GtkTextIter *iter,
                                          GtkTextTag *tag);

gboolean gtk_text_iter_ends_tag (const GtkTextIter *iter,
                                          GtkTextTag *tag);

gboolean gtk_text_iter_toggles_tag (const GtkTextIter *iter,
                                          GtkTextTag *tag);

gboolean gtk_text_iter_has_tag (const GtkTextIter *iter,
                                          GtkTextTag *tag);
GSList *gtk_text_iter_get_tags (const GtkTextIter *iter);

gboolean gtk_text_iter_editable (const GtkTextIter *iter,
                                          gboolean default_setting);
gboolean gtk_text_iter_can_insert (const GtkTextIter *iter,
                                          gboolean default_editability);

gboolean gtk_text_iter_starts_word (const GtkTextIter *iter);
gboolean gtk_text_iter_ends_word (const GtkTextIter *iter);
gboolean gtk_text_iter_inside_word (const GtkTextIter *iter);
gboolean gtk_text_iter_starts_sentence (const GtkTextIter *iter);
gboolean gtk_text_iter_ends_sentence (const GtkTextIter *iter);
gboolean gtk_text_iter_inside_sentence (const GtkTextIter *iter);
gboolean gtk_text_iter_starts_line (const GtkTextIter *iter);
gboolean gtk_text_iter_ends_line (const GtkTextIter *iter);
gboolean gtk_text_iter_is_cursor_position (const GtkTextIter *iter);

gint gtk_text_iter_get_chars_in_line (const GtkTextIter *iter);
gint gtk_text_iter_get_bytes_in_line (const GtkTextIter *iter);

gboolean gtk_text_iter_get_attributes (const GtkTextIter *iter,
                                             GtkTextAttributes *values);
PangoLanguage* gtk_text_iter_get_language (const GtkTextIter *iter);
gboolean gtk_text_iter_is_end (const GtkTextIter *iter);
gboolean gtk_text_iter_is_start (const GtkTextIter *iter);





gboolean gtk_text_iter_forward_char (GtkTextIter *iter);
gboolean gtk_text_iter_backward_char (GtkTextIter *iter);
gboolean gtk_text_iter_forward_chars (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_backward_chars (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_forward_line (GtkTextIter *iter);
gboolean gtk_text_iter_backward_line (GtkTextIter *iter);
gboolean gtk_text_iter_forward_lines (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_backward_lines (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_forward_word_end (GtkTextIter *iter);
gboolean gtk_text_iter_backward_word_start (GtkTextIter *iter);
gboolean gtk_text_iter_forward_word_ends (GtkTextIter *iter,
                                             gint count);
gboolean gtk_text_iter_backward_word_starts (GtkTextIter *iter,
                                             gint count);

gboolean gtk_text_iter_forward_sentence_end (GtkTextIter *iter);
gboolean gtk_text_iter_backward_sentence_start (GtkTextIter *iter);
gboolean gtk_text_iter_forward_sentence_ends (GtkTextIter *iter,
                                                 gint count);
gboolean gtk_text_iter_backward_sentence_starts (GtkTextIter *iter,
                                                 gint count);





gboolean gtk_text_iter_forward_cursor_position (GtkTextIter *iter);
gboolean gtk_text_iter_backward_cursor_position (GtkTextIter *iter);
gboolean gtk_text_iter_forward_cursor_positions (GtkTextIter *iter,
                                                  gint count);
gboolean gtk_text_iter_backward_cursor_positions (GtkTextIter *iter,
                                                  gint count);


void gtk_text_iter_set_offset (GtkTextIter *iter,
                                           gint char_offset);
void gtk_text_iter_set_line (GtkTextIter *iter,
                                           gint line_number);
void gtk_text_iter_set_line_offset (GtkTextIter *iter,
                                           gint char_on_line);
void gtk_text_iter_set_line_index (GtkTextIter *iter,
                                           gint byte_on_line);
void gtk_text_iter_forward_to_end (GtkTextIter *iter);
gboolean gtk_text_iter_forward_to_line_end (GtkTextIter *iter);

void gtk_text_iter_set_visible_line_offset (GtkTextIter *iter,
                                                gint char_on_line);
void gtk_text_iter_set_visible_line_index (GtkTextIter *iter,
                                                gint byte_on_line);





gboolean gtk_text_iter_forward_to_tag_toggle (GtkTextIter *iter,
                                              GtkTextTag *tag);

gboolean gtk_text_iter_backward_to_tag_toggle (GtkTextIter *iter,
                                               GtkTextTag *tag);

typedef gboolean (* GtkTextCharPredicate) (gunichar ch, gpointer user_data);

gboolean gtk_text_iter_forward_find_char (GtkTextIter *iter,
                                           GtkTextCharPredicate pred,
                                           gpointer user_data,
                                           const GtkTextIter *limit);
gboolean gtk_text_iter_backward_find_char (GtkTextIter *iter,
                                           GtkTextCharPredicate pred,
                                           gpointer user_data,
                                           const GtkTextIter *limit);

gboolean gtk_text_iter_forward_search (const GtkTextIter *iter,
                                        const gchar *str,
                                        GtkTextSearchFlags flags,
                                        GtkTextIter *match_start,
                                        GtkTextIter *match_end,
                                        const GtkTextIter *limit);

gboolean gtk_text_iter_backward_search (const GtkTextIter *iter,
                                        const gchar *str,
                                        GtkTextSearchFlags flags,
                                        GtkTextIter *match_start,
                                        GtkTextIter *match_end,
                                        const GtkTextIter *limit);





gboolean gtk_text_iter_equal (const GtkTextIter *lhs,
                                        const GtkTextIter *rhs);
gint gtk_text_iter_compare (const GtkTextIter *lhs,
                                        const GtkTextIter *rhs);
gboolean gtk_text_iter_in_range (const GtkTextIter *iter,
                                        const GtkTextIter *start,
                                        const GtkTextIter *end);


void gtk_text_iter_order (GtkTextIter *first,
                                        GtkTextIter *second);
# 34 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktextmark.h" 1 3 4
# 59 "/usr/include/gtk-2.0/gtk/gtktextmark.h" 3 4
typedef struct _GtkTextMark GtkTextMark;
typedef struct _GtkTextMarkClass GtkTextMarkClass;
# 69 "/usr/include/gtk-2.0/gtk/gtktextmark.h" 3 4
struct _GtkTextMark
{
  GObject parent_instance;

  gpointer segment;
};

struct _GtkTextMarkClass
{
  GObjectClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_text_mark_get_type (void) ;

void gtk_text_mark_set_visible (GtkTextMark *mark,
                                          gboolean setting);
gboolean gtk_text_mark_get_visible (GtkTextMark *mark);

const gchar* gtk_text_mark_get_name (GtkTextMark *mark);
gboolean gtk_text_mark_get_deleted (GtkTextMark *mark);
GtkTextBuffer* gtk_text_mark_get_buffer (GtkTextMark *mark);
gboolean gtk_text_mark_get_left_gravity (GtkTextMark *mark);
# 35 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h" 2 3 4
# 46 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h" 3 4
typedef struct _GtkTextBTree GtkTextBTree;

typedef struct _GtkTextLogAttrCache GtkTextLogAttrCache;
# 57 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h" 3 4
typedef struct _GtkTextBufferClass GtkTextBufferClass;

struct _GtkTextBuffer
{
  GObject parent_instance;

  GtkTextTagTable *tag_table;
  GtkTextBTree *btree;

  GSList *clipboard_contents_buffers;
  GSList *selection_clipboards;

  GtkTextLogAttrCache *log_attr_cache;

  guint user_action_count;


  guint modified : 1;
};

struct _GtkTextBufferClass
{
  GObjectClass parent_class;

  void (* insert_text) (GtkTextBuffer *buffer,
                            GtkTextIter *pos,
                            const gchar *text,
                            gint length);

  void (* insert_pixbuf) (GtkTextBuffer *buffer,
                            GtkTextIter *pos,
                            GdkPixbuf *pixbuf);

  void (* insert_child_anchor) (GtkTextBuffer *buffer,
                                  GtkTextIter *pos,
                                  GtkTextChildAnchor *anchor);

  void (* delete_range) (GtkTextBuffer *buffer,
                             GtkTextIter *start,
                             GtkTextIter *end);




  void (* changed) (GtkTextBuffer *buffer);



  void (* modified_changed) (GtkTextBuffer *buffer);


  void (* mark_set) (GtkTextBuffer *buffer,
                               const GtkTextIter *location,
                               GtkTextMark *mark);

  void (* mark_deleted) (GtkTextBuffer *buffer,
                               GtkTextMark *mark);

  void (* apply_tag) (GtkTextBuffer *buffer,
                               GtkTextTag *tag,
                               const GtkTextIter *start_char,
                               const GtkTextIter *end_char);

  void (* remove_tag) (GtkTextBuffer *buffer,
                               GtkTextTag *tag,
                               const GtkTextIter *start_char,
                               const GtkTextIter *end_char);


  void (* begin_user_action) (GtkTextBuffer *buffer);
  void (* end_user_action) (GtkTextBuffer *buffer);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
  void (*_gtk_reserved5) (void);
  void (*_gtk_reserved6) (void);
};

GType gtk_text_buffer_get_type (void) ;




GtkTextBuffer *gtk_text_buffer_new (GtkTextTagTable *table);
gint gtk_text_buffer_get_line_count (GtkTextBuffer *buffer);
gint gtk_text_buffer_get_char_count (GtkTextBuffer *buffer);


GtkTextTagTable* gtk_text_buffer_get_tag_table (GtkTextBuffer *buffer);


void gtk_text_buffer_set_text (GtkTextBuffer *buffer,
                                        const gchar *text,
                                        gint len);


void gtk_text_buffer_insert (GtkTextBuffer *buffer,
                                        GtkTextIter *iter,
                                        const gchar *text,
                                        gint len);
void gtk_text_buffer_insert_at_cursor (GtkTextBuffer *buffer,
                                        const gchar *text,
                                        gint len);

gboolean gtk_text_buffer_insert_interactive (GtkTextBuffer *buffer,
                                                       GtkTextIter *iter,
                                                       const gchar *text,
                                                       gint len,
                                                       gboolean default_editable);
gboolean gtk_text_buffer_insert_interactive_at_cursor (GtkTextBuffer *buffer,
                                                       const gchar *text,
                                                       gint len,
                                                       gboolean default_editable);

void gtk_text_buffer_insert_range (GtkTextBuffer *buffer,
                                                   GtkTextIter *iter,
                                                   const GtkTextIter *start,
                                                   const GtkTextIter *end);
gboolean gtk_text_buffer_insert_range_interactive (GtkTextBuffer *buffer,
                                                   GtkTextIter *iter,
                                                   const GtkTextIter *start,
                                                   const GtkTextIter *end,
                                                   gboolean default_editable);

void gtk_text_buffer_insert_with_tags (GtkTextBuffer *buffer,
                                                   GtkTextIter *iter,
                                                   const gchar *text,
                                                   gint len,
                                                   GtkTextTag *first_tag,
                                                   ...);

void gtk_text_buffer_insert_with_tags_by_name (GtkTextBuffer *buffer,
                                                   GtkTextIter *iter,
                                                   const gchar *text,
                                                   gint len,
                                                   const gchar *first_tag_name,
                                                   ...);


void gtk_text_buffer_delete (GtkTextBuffer *buffer,
                                             GtkTextIter *start,
                                             GtkTextIter *end);
gboolean gtk_text_buffer_delete_interactive (GtkTextBuffer *buffer,
                                             GtkTextIter *start_iter,
                                             GtkTextIter *end_iter,
                                             gboolean default_editable);




gchar *gtk_text_buffer_get_text (GtkTextBuffer *buffer,
                                                     const GtkTextIter *start,
                                                     const GtkTextIter *end,
                                                     gboolean include_hidden_chars);

gchar *gtk_text_buffer_get_slice (GtkTextBuffer *buffer,
                                                     const GtkTextIter *start,
                                                     const GtkTextIter *end,
                                                     gboolean include_hidden_chars);


void gtk_text_buffer_insert_pixbuf (GtkTextBuffer *buffer,
                                            GtkTextIter *iter,
                                            GdkPixbuf *pixbuf);


void gtk_text_buffer_insert_child_anchor (GtkTextBuffer *buffer,
                                                        GtkTextIter *iter,
                                                        GtkTextChildAnchor *anchor);


GtkTextChildAnchor *gtk_text_buffer_create_child_anchor (GtkTextBuffer *buffer,
                                                         GtkTextIter *iter);


GtkTextMark *gtk_text_buffer_create_mark (GtkTextBuffer *buffer,
                                            const gchar *mark_name,
                                            const GtkTextIter *where,
                                            gboolean left_gravity);
void gtk_text_buffer_move_mark (GtkTextBuffer *buffer,
                                            GtkTextMark *mark,
                                            const GtkTextIter *where);
void gtk_text_buffer_delete_mark (GtkTextBuffer *buffer,
                                            GtkTextMark *mark);
GtkTextMark* gtk_text_buffer_get_mark (GtkTextBuffer *buffer,
                                            const gchar *name);

void gtk_text_buffer_move_mark_by_name (GtkTextBuffer *buffer,
                                          const gchar *name,
                                          const GtkTextIter *where);
void gtk_text_buffer_delete_mark_by_name (GtkTextBuffer *buffer,
                                          const gchar *name);

GtkTextMark* gtk_text_buffer_get_insert (GtkTextBuffer *buffer);
GtkTextMark* gtk_text_buffer_get_selection_bound (GtkTextBuffer *buffer);


void gtk_text_buffer_place_cursor (GtkTextBuffer *buffer,
                                   const GtkTextIter *where);




void gtk_text_buffer_apply_tag (GtkTextBuffer *buffer,
                                            GtkTextTag *tag,
                                            const GtkTextIter *start,
                                            const GtkTextIter *end);
void gtk_text_buffer_remove_tag (GtkTextBuffer *buffer,
                                            GtkTextTag *tag,
                                            const GtkTextIter *start,
                                            const GtkTextIter *end);
void gtk_text_buffer_apply_tag_by_name (GtkTextBuffer *buffer,
                                            const gchar *name,
                                            const GtkTextIter *start,
                                            const GtkTextIter *end);
void gtk_text_buffer_remove_tag_by_name (GtkTextBuffer *buffer,
                                            const gchar *name,
                                            const GtkTextIter *start,
                                            const GtkTextIter *end);
void gtk_text_buffer_remove_all_tags (GtkTextBuffer *buffer,
                                            const GtkTextIter *start,
                                            const GtkTextIter *end);





GtkTextTag *gtk_text_buffer_create_tag (GtkTextBuffer *buffer,
                                           const gchar *tag_name,
                                           const gchar *first_property_name,
                                           ...);




void gtk_text_buffer_get_iter_at_line_offset (GtkTextBuffer *buffer,
                                              GtkTextIter *iter,
                                              gint line_number,
                                              gint char_offset);
void gtk_text_buffer_get_iter_at_line_index (GtkTextBuffer *buffer,
                                              GtkTextIter *iter,
                                              gint line_number,
                                              gint byte_index);
void gtk_text_buffer_get_iter_at_offset (GtkTextBuffer *buffer,
                                              GtkTextIter *iter,
                                              gint char_offset);
void gtk_text_buffer_get_iter_at_line (GtkTextBuffer *buffer,
                                              GtkTextIter *iter,
                                              gint line_number);
void gtk_text_buffer_get_start_iter (GtkTextBuffer *buffer,
                                              GtkTextIter *iter);
void gtk_text_buffer_get_end_iter (GtkTextBuffer *buffer,
                                              GtkTextIter *iter);
void gtk_text_buffer_get_bounds (GtkTextBuffer *buffer,
                                              GtkTextIter *start,
                                              GtkTextIter *end);
void gtk_text_buffer_get_iter_at_mark (GtkTextBuffer *buffer,
                                              GtkTextIter *iter,
                                              GtkTextMark *mark);

void gtk_text_buffer_get_iter_at_child_anchor (GtkTextBuffer *buffer,
                                               GtkTextIter *iter,
                                               GtkTextChildAnchor *anchor);
# 333 "/usr/include/gtk-2.0/gtk/gtktextbuffer.h" 3 4
gboolean gtk_text_buffer_get_modified (GtkTextBuffer *buffer);
void gtk_text_buffer_set_modified (GtkTextBuffer *buffer,
                                                         gboolean setting);

void gtk_text_buffer_add_selection_clipboard (GtkTextBuffer *buffer,
                                                 GtkClipboard *clipboard);
void gtk_text_buffer_remove_selection_clipboard (GtkTextBuffer *buffer,
                                                 GtkClipboard *clipboard);

void gtk_text_buffer_cut_clipboard (GtkTextBuffer *buffer,
                                                         GtkClipboard *clipboard,
                                                         gboolean default_editable);
void gtk_text_buffer_copy_clipboard (GtkTextBuffer *buffer,
                                                         GtkClipboard *clipboard);
void gtk_text_buffer_paste_clipboard (GtkTextBuffer *buffer,
                                                         GtkClipboard *clipboard,
                                                         GtkTextIter *override_location,
                                                         gboolean default_editable);

gboolean gtk_text_buffer_get_selection_bounds (GtkTextBuffer *buffer,
                                                         GtkTextIter *start,
                                                         GtkTextIter *end);
gboolean gtk_text_buffer_delete_selection (GtkTextBuffer *buffer,
                                                         gboolean interactive,
                                                         gboolean default_editable);


void gtk_text_buffer_begin_user_action (GtkTextBuffer *buffer);
void gtk_text_buffer_end_user_action (GtkTextBuffer *buffer);


void _gtk_text_buffer_spew (GtkTextBuffer *buffer);

GtkTextBTree* _gtk_text_buffer_get_btree (GtkTextBuffer *buffer);

const PangoLogAttr* _gtk_text_buffer_get_line_log_attrs (GtkTextBuffer *buffer,
                                                         const GtkTextIter *anywhere_in_line,
                                                         gint *char_len);

void _gtk_text_buffer_notify_will_remove_tag (GtkTextBuffer *buffer,
                                              GtkTextTag *tag);
# 136 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktextview.h" 1 3 4
# 46 "/usr/include/gtk-2.0/gtk/gtktextview.h" 3 4
typedef enum
{
  GTK_TEXT_WINDOW_PRIVATE,
  GTK_TEXT_WINDOW_WIDGET,
  GTK_TEXT_WINDOW_TEXT,
  GTK_TEXT_WINDOW_LEFT,
  GTK_TEXT_WINDOW_RIGHT,
  GTK_TEXT_WINDOW_TOP,
  GTK_TEXT_WINDOW_BOTTOM
} GtkTextWindowType;



typedef struct _GtkTextView GtkTextView;
typedef struct _GtkTextViewClass GtkTextViewClass;


typedef struct _GtkTextWindow GtkTextWindow;
typedef struct _GtkTextPendingScroll GtkTextPendingScroll;

struct _GtkTextView
{
  GtkContainer parent_instance;

  struct _GtkTextLayout *layout;
  GtkTextBuffer *buffer;

  guint selection_drag_handler;
  guint scroll_timeout;


  gint pixels_above_lines;
  gint pixels_below_lines;
  gint pixels_inside_wrap;
  GtkWrapMode wrap_mode;
  GtkJustification justify;
  gint left_margin;
  gint right_margin;
  gint indent;
  PangoTabArray *tabs;
  guint editable : 1;



  guint overwrite_mode : 1;
  guint cursor_visible : 1;
  guint need_im_reset : 1;

  guint just_selected_element : 1;


  guint reserved2 : 1;




  guint onscreen_validated : 1;

  guint mouse_cursor_obscured : 1;

  GtkTextWindow *text_window;
  GtkTextWindow *left_window;
  GtkTextWindow *right_window;
  GtkTextWindow *top_window;
  GtkTextWindow *bottom_window;

  GtkAdjustment *hadjustment;
  GtkAdjustment *vadjustment;

  gint xoffset;
  gint yoffset;
  gint width;
  gint height;
# 129 "/usr/include/gtk-2.0/gtk/gtktextview.h" 3 4
  gint virtual_cursor_x;
  gint virtual_cursor_y;

  GtkTextMark *first_para_mark;
  gint first_para_pixels;

  GtkTextMark *dnd_mark;
  guint blink_timeout;

  guint first_validate_idle;
  guint incremental_validate_idle;

  GtkIMContext *im_context;
  GtkWidget *popup_menu;

  gint drag_start_x;
  gint drag_start_y;

  GSList *children;

  GtkTextPendingScroll *pending_scroll;

  gint pending_place_cursor_button;
};

struct _GtkTextViewClass
{
  GtkContainerClass parent_class;

  void (* set_scroll_adjustments) (GtkTextView *text_view,
                                     GtkAdjustment *hadjustment,
                                     GtkAdjustment *vadjustment);

  void (* populate_popup) (GtkTextView *text_view,
                                     GtkMenu *menu);




  void (* move_cursor) (GtkTextView *text_view,
                        GtkMovementStep step,
                        gint count,
                        gboolean extend_selection);





  void (* page_horizontally) (GtkTextView *text_view,
                              gint count,
                              gboolean extend_selection);


  void (* set_anchor) (GtkTextView *text_view);


  void (* insert_at_cursor) (GtkTextView *text_view,
                                  const gchar *str);
  void (* delete_from_cursor) (GtkTextView *text_view,
                                  GtkDeleteType type,
                                  gint count);


  void (* cut_clipboard) (GtkTextView *text_view);
  void (* copy_clipboard) (GtkTextView *text_view);
  void (* paste_clipboard) (GtkTextView *text_view);

  void (* toggle_overwrite) (GtkTextView *text_view);


  void (* move_focus) (GtkTextView *text_view,
                             GtkDirectionType direction);



  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
  void (*_gtk_reserved5) (void);
  void (*_gtk_reserved6) (void);
  void (*_gtk_reserved7) (void);
  void (*_gtk_reserved8) (void);
};

GType gtk_text_view_get_type (void) ;
GtkWidget * gtk_text_view_new (void);
GtkWidget * gtk_text_view_new_with_buffer (GtkTextBuffer *buffer);
void gtk_text_view_set_buffer (GtkTextView *text_view,
                                                    GtkTextBuffer *buffer);
GtkTextBuffer *gtk_text_view_get_buffer (GtkTextView *text_view);
gboolean gtk_text_view_scroll_to_iter (GtkTextView *text_view,
                                                    GtkTextIter *iter,
                                                    gdouble within_margin,
                                                    gboolean use_align,
                                                    gdouble xalign,
                                                    gdouble yalign);
void gtk_text_view_scroll_to_mark (GtkTextView *text_view,
                                                    GtkTextMark *mark,
                                                    gdouble within_margin,
                                                    gboolean use_align,
                                                    gdouble xalign,
                                                    gdouble yalign);
void gtk_text_view_scroll_mark_onscreen (GtkTextView *text_view,
                                                    GtkTextMark *mark);
gboolean gtk_text_view_move_mark_onscreen (GtkTextView *text_view,
                                                    GtkTextMark *mark);
gboolean gtk_text_view_place_cursor_onscreen (GtkTextView *text_view);

void gtk_text_view_get_visible_rect (GtkTextView *text_view,
                                                    GdkRectangle *visible_rect);
void gtk_text_view_set_cursor_visible (GtkTextView *text_view,
                                                    gboolean setting);
gboolean gtk_text_view_get_cursor_visible (GtkTextView *text_view);

void gtk_text_view_get_iter_location (GtkTextView *text_view,
                                                    const GtkTextIter *iter,
                                                    GdkRectangle *location);
void gtk_text_view_get_iter_at_location (GtkTextView *text_view,
                                                    GtkTextIter *iter,
                                                    gint x,
                                                    gint y);
void gtk_text_view_get_line_yrange (GtkTextView *text_view,
                                                    const GtkTextIter *iter,
                                                    gint *y,
                                                    gint *height);

void gtk_text_view_get_line_at_y (GtkTextView *text_view,
                                                    GtkTextIter *target_iter,
                                                    gint y,
                                                    gint *line_top);

void gtk_text_view_buffer_to_window_coords (GtkTextView *text_view,
                                            GtkTextWindowType win,
                                            gint buffer_x,
                                            gint buffer_y,
                                            gint *window_x,
                                            gint *window_y);
void gtk_text_view_window_to_buffer_coords (GtkTextView *text_view,
                                            GtkTextWindowType win,
                                            gint window_x,
                                            gint window_y,
                                            gint *buffer_x,
                                            gint *buffer_y);

GdkWindow* gtk_text_view_get_window (GtkTextView *text_view,
                                                 GtkTextWindowType win);
GtkTextWindowType gtk_text_view_get_window_type (GtkTextView *text_view,
                                                 GdkWindow *window);

void gtk_text_view_set_border_window_size (GtkTextView *text_view,
                                           GtkTextWindowType type,
                                           gint size);
gint gtk_text_view_get_border_window_size (GtkTextView *text_view,
                                           GtkTextWindowType type);

gboolean gtk_text_view_forward_display_line (GtkTextView *text_view,
                                                       GtkTextIter *iter);
gboolean gtk_text_view_backward_display_line (GtkTextView *text_view,
                                                       GtkTextIter *iter);
gboolean gtk_text_view_forward_display_line_end (GtkTextView *text_view,
                                                       GtkTextIter *iter);
gboolean gtk_text_view_backward_display_line_start (GtkTextView *text_view,
                                                       GtkTextIter *iter);
gboolean gtk_text_view_starts_display_line (GtkTextView *text_view,
                                                       const GtkTextIter *iter);
gboolean gtk_text_view_move_visually (GtkTextView *text_view,
                                                       GtkTextIter *iter,
                                                       gint count);


void gtk_text_view_add_child_at_anchor (GtkTextView *text_view,
                                        GtkWidget *child,
                                        GtkTextChildAnchor *anchor);

void gtk_text_view_add_child_in_window (GtkTextView *text_view,
                                        GtkWidget *child,
                                        GtkTextWindowType which_window,

                                        gint xpos,
                                        gint ypos);

void gtk_text_view_move_child (GtkTextView *text_view,
                                        GtkWidget *child,

                                        gint xpos,
                                        gint ypos);



void gtk_text_view_set_wrap_mode (GtkTextView *text_view,
                                                       GtkWrapMode wrap_mode);
GtkWrapMode gtk_text_view_get_wrap_mode (GtkTextView *text_view);
void gtk_text_view_set_editable (GtkTextView *text_view,
                                                       gboolean setting);
gboolean gtk_text_view_get_editable (GtkTextView *text_view);
void gtk_text_view_set_pixels_above_lines (GtkTextView *text_view,
                                                       gint pixels_above_lines);
gint gtk_text_view_get_pixels_above_lines (GtkTextView *text_view);
void gtk_text_view_set_pixels_below_lines (GtkTextView *text_view,
                                                       gint pixels_below_lines);
gint gtk_text_view_get_pixels_below_lines (GtkTextView *text_view);
void gtk_text_view_set_pixels_inside_wrap (GtkTextView *text_view,
                                                       gint pixels_inside_wrap);
gint gtk_text_view_get_pixels_inside_wrap (GtkTextView *text_view);
void gtk_text_view_set_justification (GtkTextView *text_view,
                                                       GtkJustification justification);
GtkJustification gtk_text_view_get_justification (GtkTextView *text_view);
void gtk_text_view_set_left_margin (GtkTextView *text_view,
                                                       gint left_margin);
gint gtk_text_view_get_left_margin (GtkTextView *text_view);
void gtk_text_view_set_right_margin (GtkTextView *text_view,
                                                       gint right_margin);
gint gtk_text_view_get_right_margin (GtkTextView *text_view);
void gtk_text_view_set_indent (GtkTextView *text_view,
                                                       gint indent);
gint gtk_text_view_get_indent (GtkTextView *text_view);
void gtk_text_view_set_tabs (GtkTextView *text_view,
                                                       PangoTabArray *tabs);
PangoTabArray* gtk_text_view_get_tabs (GtkTextView *text_view);


GtkTextAttributes* gtk_text_view_get_default_attributes (GtkTextView *text_view);
# 137 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktipsquery.h" 1 3 4
# 54 "/usr/include/gtk-2.0/gtk/gtktipsquery.h" 3 4
typedef struct _GtkTipsQuery GtkTipsQuery;
typedef struct _GtkTipsQueryClass GtkTipsQueryClass;



struct _GtkTipsQuery
{
  GtkLabel label;

  guint emit_always : 1;
  guint in_query : 1;
  gchar *label_inactive;
  gchar *label_no_tip;

  GtkWidget *caller;
  GtkWidget *last_crossed;

  GdkCursor *query_cursor;
};

struct _GtkTipsQueryClass
{
  GtkLabelClass parent_class;

  void (*start_query) (GtkTipsQuery *tips_query);
  void (*stop_query) (GtkTipsQuery *tips_query);
  void (*widget_entered) (GtkTipsQuery *tips_query,
                                 GtkWidget *widget,
                                 const gchar *tip_text,
                                 const gchar *tip_private);
  gint (*widget_selected) (GtkTipsQuery *tips_query,
                                 GtkWidget *widget,
                                 const gchar *tip_text,
                                 const gchar *tip_private,
                                 GdkEventButton *event);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};



GtkType gtk_tips_query_get_type (void) ;
GtkWidget* gtk_tips_query_new (void);
void gtk_tips_query_start_query (GtkTipsQuery *tips_query);
void gtk_tips_query_stop_query (GtkTipsQuery *tips_query);
void gtk_tips_query_set_caller (GtkTipsQuery *tips_query,
                                                 GtkWidget *caller);
void gtk_tips_query_set_labels (GtkTipsQuery *tips_query,
                                                 const gchar *label_inactive,
                                                 const gchar *label_no_tip);
# 138 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtktoolbar.h" 1 3 4
# 35 "/usr/include/gtk-2.0/gtk/gtktoolbar.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktooltips.h" 1 3 4
# 46 "/usr/include/gtk-2.0/gtk/gtktooltips.h" 3 4
typedef struct _GtkTooltips GtkTooltips;
typedef struct _GtkTooltipsClass GtkTooltipsClass;
typedef struct _GtkTooltipsData GtkTooltipsData;

struct _GtkTooltipsData
{
  GtkTooltips *tooltips;
  GtkWidget *widget;
  gchar *tip_text;
  gchar *tip_private;
};

struct _GtkTooltips
{
  GtkObject parent_instance;

  GtkWidget *tip_window;
  GtkWidget *tip_label;
  GtkTooltipsData *active_tips_data;
  GList *tips_data_list;

  guint delay : 30;
  guint enabled : 1;
  guint have_grab : 1;
  guint use_sticky_delay : 1;
  gint timer_tag;
  GTimeVal last_popdown;
};

struct _GtkTooltipsClass
{
  GtkObjectClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_tooltips_get_type (void) ;
GtkTooltips* gtk_tooltips_new (void);

void gtk_tooltips_enable (GtkTooltips *tooltips);
void gtk_tooltips_disable (GtkTooltips *tooltips);

void gtk_tooltips_set_delay (GtkTooltips *tooltips,
                                            guint delay);

void gtk_tooltips_set_tip (GtkTooltips *tooltips,
                                            GtkWidget *widget,
                                            const gchar *tip_text,
                                            const gchar *tip_private);
GtkTooltipsData* gtk_tooltips_data_get (GtkWidget *widget);
void gtk_tooltips_force_window (GtkTooltips *tooltips);


void _gtk_tooltips_toggle_keyboard_mode (GtkWidget *widget);
# 36 "/usr/include/gtk-2.0/gtk/gtktoolbar.h" 2 3 4


# 1 "/usr/include/gtk-2.0/gtk/gtkpixmap.h" 1 3 4
# 39 "/usr/include/gtk-2.0/gtk/gtktoolbar.h" 2 3 4
# 55 "/usr/include/gtk-2.0/gtk/gtktoolbar.h" 3 4
typedef enum
{
  GTK_TOOLBAR_CHILD_SPACE,
  GTK_TOOLBAR_CHILD_BUTTON,
  GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
  GTK_TOOLBAR_CHILD_RADIOBUTTON,
  GTK_TOOLBAR_CHILD_WIDGET
} GtkToolbarChildType;

typedef enum
{
  GTK_TOOLBAR_SPACE_EMPTY,
  GTK_TOOLBAR_SPACE_LINE
} GtkToolbarSpaceStyle;

typedef struct _GtkToolbarChild GtkToolbarChild;
typedef struct _GtkToolbar GtkToolbar;
typedef struct _GtkToolbarClass GtkToolbarClass;

struct _GtkToolbarChild
{
  GtkToolbarChildType type;
  GtkWidget *widget;
  GtkWidget *icon;
  GtkWidget *label;
};

struct _GtkToolbar
{
  GtkContainer container;

  gint num_children;
  GList *children;
  GtkOrientation orientation;
  GtkToolbarStyle style;
  GtkIconSize icon_size;

  GtkTooltips *tooltips;

  gint button_maxw;
  gint button_maxh;

  guint style_set_connection;
  guint icon_size_connection;

  guint style_set : 1;
  guint icon_size_set : 1;
};

struct _GtkToolbarClass
{
  GtkContainerClass parent_class;

  void (* orientation_changed) (GtkToolbar *toolbar,
                                GtkOrientation orientation);
  void (* style_changed) (GtkToolbar *toolbar,
                                GtkToolbarStyle style);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_toolbar_get_type (void) ;
GtkWidget* gtk_toolbar_new (void);


GtkWidget* gtk_toolbar_append_item (GtkToolbar *toolbar,
                                        const char *text,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text,
                                        GtkWidget *icon,
                                        GtkSignalFunc callback,
                                        gpointer user_data);
GtkWidget* gtk_toolbar_prepend_item (GtkToolbar *toolbar,
                                        const char *text,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text,
                                        GtkWidget *icon,
                                        GtkSignalFunc callback,
                                        gpointer user_data);
GtkWidget* gtk_toolbar_insert_item (GtkToolbar *toolbar,
                                        const char *text,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text,
                                        GtkWidget *icon,
                                        GtkSignalFunc callback,
                                        gpointer user_data,
                                        gint position);


GtkWidget* gtk_toolbar_insert_stock (GtkToolbar *toolbar,
                                        const gchar *stock_id,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text,
                                        GtkSignalFunc callback,
                                        gpointer user_data,
                                        gint position);




void gtk_toolbar_append_space (GtkToolbar *toolbar);
void gtk_toolbar_prepend_space (GtkToolbar *toolbar);
void gtk_toolbar_insert_space (GtkToolbar *toolbar,
                                        gint position);
void gtk_toolbar_remove_space (GtkToolbar *toolbar,
                                        gint position);


GtkWidget* gtk_toolbar_append_element (GtkToolbar *toolbar,
                                        GtkToolbarChildType type,
                                        GtkWidget *widget,
                                        const char *text,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text,
                                        GtkWidget *icon,
                                        GtkSignalFunc callback,
                                        gpointer user_data);

GtkWidget* gtk_toolbar_prepend_element (GtkToolbar *toolbar,
                                        GtkToolbarChildType type,
                                        GtkWidget *widget,
                                        const char *text,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text,
                                        GtkWidget *icon,
                                        GtkSignalFunc callback,
                                        gpointer user_data);

GtkWidget* gtk_toolbar_insert_element (GtkToolbar *toolbar,
                                        GtkToolbarChildType type,
                                        GtkWidget *widget,
                                        const char *text,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text,
                                        GtkWidget *icon,
                                        GtkSignalFunc callback,
                                        gpointer user_data,
                                        gint position);


void gtk_toolbar_append_widget (GtkToolbar *toolbar,
                                        GtkWidget *widget,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text);
void gtk_toolbar_prepend_widget (GtkToolbar *toolbar,
                                        GtkWidget *widget,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text);
void gtk_toolbar_insert_widget (GtkToolbar *toolbar,
                                        GtkWidget *widget,
                                        const char *tooltip_text,
                                        const char *tooltip_private_text,
                                        gint position);


void gtk_toolbar_set_orientation (GtkToolbar *toolbar,
                                              GtkOrientation orientation);
void gtk_toolbar_set_style (GtkToolbar *toolbar,
                                              GtkToolbarStyle style);
void gtk_toolbar_set_icon_size (GtkToolbar *toolbar,
                                              GtkIconSize icon_size);
void gtk_toolbar_set_tooltips (GtkToolbar *toolbar,
                                              gboolean enable);
void gtk_toolbar_unset_style (GtkToolbar *toolbar);
void gtk_toolbar_unset_icon_size (GtkToolbar *toolbar);

GtkOrientation gtk_toolbar_get_orientation (GtkToolbar *toolbar);
GtkToolbarStyle gtk_toolbar_get_style (GtkToolbar *toolbar);
GtkIconSize gtk_toolbar_get_icon_size (GtkToolbar *toolbar);
gboolean gtk_toolbar_get_tooltips (GtkToolbar *toolbar);
# 140 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtktree.h" 1 3 4
# 142 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktreednd.h" 1 3 4
# 35 "/usr/include/gtk-2.0/gtk/gtktreednd.h" 3 4
typedef struct _GtkTreeDragSource GtkTreeDragSource;
typedef struct _GtkTreeDragSourceIface GtkTreeDragSourceIface;

struct _GtkTreeDragSourceIface
{
  GTypeInterface g_iface;



  gboolean (* row_draggable) (GtkTreeDragSource *drag_source,
                                         GtkTreePath *path);

  gboolean (* drag_data_get) (GtkTreeDragSource *drag_source,
                                         GtkTreePath *path,
                                         GtkSelectionData *selection_data);

  gboolean (* drag_data_delete) (GtkTreeDragSource *drag_source,
                                         GtkTreePath *path);
};

GType gtk_tree_drag_source_get_type (void) ;


gboolean gtk_tree_drag_source_row_draggable (GtkTreeDragSource *drag_source,
                                                GtkTreePath *path);


gboolean gtk_tree_drag_source_drag_data_delete (GtkTreeDragSource *drag_source,
                                                GtkTreePath *path);




gboolean gtk_tree_drag_source_drag_data_get (GtkTreeDragSource *drag_source,
                                                GtkTreePath *path,
                                                GtkSelectionData *selection_data);






typedef struct _GtkTreeDragDest GtkTreeDragDest;
typedef struct _GtkTreeDragDestIface GtkTreeDragDestIface;

struct _GtkTreeDragDestIface
{
  GTypeInterface g_iface;



  gboolean (* drag_data_received) (GtkTreeDragDest *drag_dest,
                                       GtkTreePath *dest,
                                       GtkSelectionData *selection_data);

  gboolean (* row_drop_possible) (GtkTreeDragDest *drag_dest,
                                       GtkTreePath *dest_path,
                                       GtkSelectionData *selection_data);
};

GType gtk_tree_drag_dest_get_type (void) ;




gboolean gtk_tree_drag_dest_drag_data_received (GtkTreeDragDest *drag_dest,
                                                GtkTreePath *dest,
                                                GtkSelectionData *selection_data);



gboolean gtk_tree_drag_dest_row_drop_possible (GtkTreeDragDest *drag_dest,
                                                GtkTreePath *dest_path,
                                                GtkSelectionData *selection_data);





gboolean gtk_tree_set_row_drag_data (GtkSelectionData *selection_data,
                                                GtkTreeModel *tree_model,
                                                GtkTreePath *path);
gboolean gtk_tree_get_row_drag_data (GtkSelectionData *selection_data,
                                                GtkTreeModel **tree_model,
                                                GtkTreePath **path);
# 143 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktreeitem.h" 1 3 4
# 144 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtktreemodelsort.h" 1 3 4
# 26 "/usr/include/gtk-2.0/gtk/gtktreemodelsort.h" 3 4

# 35 "/usr/include/gtk-2.0/gtk/gtktreemodelsort.h" 3 4
typedef struct _GtkTreeModelSort GtkTreeModelSort;
typedef struct _GtkTreeModelSortClass GtkTreeModelSortClass;

struct _GtkTreeModelSort
{
  GObject parent;


  gpointer root;
  gint stamp;
  guint child_flags;
  GtkTreeModel *child_model;
  gint zero_ref_count;


  GList *sort_list;
  gint sort_column_id;
  GtkSortType order;


  GtkTreeIterCompareFunc default_sort_func;
  gpointer default_sort_data;
  GtkDestroyNotify default_sort_destroy;


  guint changed_id;
  guint inserted_id;
  guint has_child_toggled_id;
  guint deleted_id;
  guint reordered_id;
};

struct _GtkTreeModelSortClass
{
  GObjectClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_tree_model_sort_get_type (void) ;
GtkTreeModel *gtk_tree_model_sort_new_with_model (GtkTreeModel *child_model);

GtkTreeModel *gtk_tree_model_sort_get_model (GtkTreeModelSort *tree_model);
GtkTreePath *gtk_tree_model_sort_convert_child_path_to_path (GtkTreeModelSort *tree_model_sort,
                                                              GtkTreePath *child_path);
void gtk_tree_model_sort_convert_child_iter_to_iter (GtkTreeModelSort *tree_model_sort,
                                                              GtkTreeIter *sort_iter,
                                                              GtkTreeIter *child_iter);
GtkTreePath *gtk_tree_model_sort_convert_path_to_child_path (GtkTreeModelSort *tree_model_sort,
                                                              GtkTreePath *sorted_path);
void gtk_tree_model_sort_convert_iter_to_child_iter (GtkTreeModelSort *tree_model_sort,
                                                              GtkTreeIter *child_iter,
                                                              GtkTreeIter *sorted_iter);
void gtk_tree_model_sort_reset_default_sort_func (GtkTreeModelSort *tree_model_sort);
void gtk_tree_model_sort_clear_cache (GtkTreeModelSort *tree_model_sort);
gboolean gtk_tree_model_sort_iter_is_valid (GtkTreeModelSort *tree_model_sort,
                                                              GtkTreeIter *iter);



# 146 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktreeselection.h" 1 3 4
# 24 "/usr/include/gtk-2.0/gtk/gtktreeselection.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktreeview.h" 1 3 4
# 25 "/usr/include/gtk-2.0/gtk/gtktreeview.h" 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h" 1 3 4
# 42 "/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h" 3 4
typedef enum
{
  GTK_TREE_VIEW_COLUMN_GROW_ONLY,
  GTK_TREE_VIEW_COLUMN_AUTOSIZE,
  GTK_TREE_VIEW_COLUMN_FIXED
} GtkTreeViewColumnSizing;

typedef struct _GtkTreeViewColumn GtkTreeViewColumn;
typedef struct _GtkTreeViewColumnClass GtkTreeViewColumnClass;

typedef void (* GtkTreeCellDataFunc) (GtkTreeViewColumn *tree_column,
                                      GtkCellRenderer *cell,
                                      GtkTreeModel *tree_model,
                                      GtkTreeIter *iter,
                                      gpointer data);


struct _GtkTreeViewColumn
{
  GtkObject parent;

  GtkWidget *tree_view;
  GtkWidget *button;
  GtkWidget *child;
  GtkWidget *arrow;
  GtkWidget *alignment;
  GdkWindow *window;
  GtkCellEditable *editable_widget;
  gfloat xalign;
  guint property_changed_signal;
  gint spacing;



  GtkTreeViewColumnSizing column_type;
  gint requested_width;
  gint button_request;
  gint resized_width;
  gint width;
  gint fixed_width;
  gint min_width;
  gint max_width;


  gint drag_x;
  gint drag_y;

  gchar *title;
  GList *cell_list;


  guint sort_clicked_signal;
  guint sort_column_changed_signal;
  gint sort_column_id;
  GtkSortType sort_order;


  guint visible : 1;
  guint resizable : 1;
  guint clickable : 1;
  guint dirty : 1;
  guint show_sort_indicator : 1;
  guint maybe_reordered : 1;
  guint reorderable : 1;
  guint use_resized_width : 1;
};

struct _GtkTreeViewColumnClass
{
  GtkObjectClass parent_class;

  void (*clicked) (GtkTreeViewColumn *tree_column);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};

GType gtk_tree_view_column_get_type (void);
GtkTreeViewColumn *gtk_tree_view_column_new (void);
GtkTreeViewColumn *gtk_tree_view_column_new_with_attributes (const gchar *title,
                                                                  GtkCellRenderer *cell,
                                                                  ...);
void gtk_tree_view_column_pack_start (GtkTreeViewColumn *tree_column,
                                                                  GtkCellRenderer *cell,
                                                                  gboolean expand);
void gtk_tree_view_column_pack_end (GtkTreeViewColumn *tree_column,
                                                                  GtkCellRenderer *cell,
                                                                  gboolean expand);
void gtk_tree_view_column_clear (GtkTreeViewColumn *tree_column);
GList *gtk_tree_view_column_get_cell_renderers (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_add_attribute (GtkTreeViewColumn *tree_column,
                                                                  GtkCellRenderer *cell_renderer,
                                                                  const gchar *attribute,
                                                                  gint column);
void gtk_tree_view_column_set_attributes (GtkTreeViewColumn *tree_column,
                                                                  GtkCellRenderer *cell_renderer,
                                                                  ...);
void gtk_tree_view_column_set_cell_data_func (GtkTreeViewColumn *tree_column,
                                                                  GtkCellRenderer *cell_renderer,
                                                                  GtkTreeCellDataFunc func,
                                                                  gpointer func_data,
                                                                  GtkDestroyNotify destroy);
void gtk_tree_view_column_clear_attributes (GtkTreeViewColumn *tree_column,
                                                                  GtkCellRenderer *cell_renderer);
void gtk_tree_view_column_set_spacing (GtkTreeViewColumn *tree_column,
                                                                  gint spacing);
gint gtk_tree_view_column_get_spacing (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_visible (GtkTreeViewColumn *tree_column,
                                                                  gboolean visible);
gboolean gtk_tree_view_column_get_visible (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_resizable (GtkTreeViewColumn *tree_column,
                                                                  gboolean resizable);
gboolean gtk_tree_view_column_get_resizable (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_sizing (GtkTreeViewColumn *tree_column,
                                                                  GtkTreeViewColumnSizing type);
GtkTreeViewColumnSizing gtk_tree_view_column_get_sizing (GtkTreeViewColumn *tree_column);
gint gtk_tree_view_column_get_width (GtkTreeViewColumn *tree_column);
gint gtk_tree_view_column_get_fixed_width (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_fixed_width (GtkTreeViewColumn *tree_column,
                                                                  gint fixed_width);
void gtk_tree_view_column_set_min_width (GtkTreeViewColumn *tree_column,
                                                                  gint min_width);
gint gtk_tree_view_column_get_min_width (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_max_width (GtkTreeViewColumn *tree_column,
                                                                  gint max_width);
gint gtk_tree_view_column_get_max_width (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_clicked (GtkTreeViewColumn *tree_column);





void gtk_tree_view_column_set_title (GtkTreeViewColumn *tree_column,
                                                                  const gchar *title);
const gchar *gtk_tree_view_column_get_title (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_clickable (GtkTreeViewColumn *tree_column,
                                                                  gboolean clickable);
gboolean gtk_tree_view_column_get_clickable (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_widget (GtkTreeViewColumn *tree_column,
                                                                  GtkWidget *widget);
GtkWidget *gtk_tree_view_column_get_widget (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_alignment (GtkTreeViewColumn *tree_column,
                                                                  gfloat xalign);
gfloat gtk_tree_view_column_get_alignment (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_reorderable (GtkTreeViewColumn *tree_column,
                                                                  gboolean reorderable);
gboolean gtk_tree_view_column_get_reorderable (GtkTreeViewColumn *tree_column);






void gtk_tree_view_column_set_sort_column_id (GtkTreeViewColumn *tree_column,
                                                                  gint sort_column_id);
gint gtk_tree_view_column_get_sort_column_id (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_sort_indicator (GtkTreeViewColumn *tree_column,
                                                                  gboolean setting);
gboolean gtk_tree_view_column_get_sort_indicator (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_set_sort_order (GtkTreeViewColumn *tree_column,
                                                                  GtkSortType order);
GtkSortType gtk_tree_view_column_get_sort_order (GtkTreeViewColumn *tree_column);




void gtk_tree_view_column_cell_set_cell_data (GtkTreeViewColumn *tree_column,
                                                                  GtkTreeModel *tree_model,
                                                                  GtkTreeIter *iter,
                                                                  gboolean is_expander,
                                                                  gboolean is_expanded);
void gtk_tree_view_column_cell_get_size (GtkTreeViewColumn *tree_column,
                                                                  GdkRectangle *cell_area,
                                                                  gint *x_offset,
                                                                  gint *y_offset,
                                                                  gint *width,
                                                                  gint *height);
gboolean gtk_tree_view_column_cell_is_visible (GtkTreeViewColumn *tree_column);
void gtk_tree_view_column_focus_cell (GtkTreeViewColumn *tree_column,
                                                                  GtkCellRenderer *cell);
gboolean gtk_tree_view_column_cell_get_position (GtkTreeViewColumn *tree_column,
                                                                  GtkCellRenderer *cell_renderer,
                                                                  gint *start_pos,
                                                                  gint *width);
# 26 "/usr/include/gtk-2.0/gtk/gtktreeview.h" 2 3 4






typedef enum
{

  GTK_TREE_VIEW_DROP_BEFORE,
  GTK_TREE_VIEW_DROP_AFTER,



  GTK_TREE_VIEW_DROP_INTO_OR_BEFORE,
  GTK_TREE_VIEW_DROP_INTO_OR_AFTER
} GtkTreeViewDropPosition;
# 51 "/usr/include/gtk-2.0/gtk/gtktreeview.h" 3 4
typedef struct _GtkTreeView GtkTreeView;
typedef struct _GtkTreeViewClass GtkTreeViewClass;
typedef struct _GtkTreeViewPrivate GtkTreeViewPrivate;
typedef struct _GtkTreeSelection GtkTreeSelection;
typedef struct _GtkTreeSelectionClass GtkTreeSelectionClass;

struct _GtkTreeView
{
  GtkContainer parent;

  GtkTreeViewPrivate *priv;
};

struct _GtkTreeViewClass
{
  GtkContainerClass parent_class;

  void (* set_scroll_adjustments) (GtkTreeView *tree_view,
                                           GtkAdjustment *hadjustment,
                                           GtkAdjustment *vadjustment);
  void (* row_activated) (GtkTreeView *tree_view,
                                           GtkTreePath *path,
                                           GtkTreeViewColumn *column);
  gboolean (* test_expand_row) (GtkTreeView *tree_view,
                                           GtkTreeIter *iter,
                                           GtkTreePath *path);
  gboolean (* test_collapse_row) (GtkTreeView *tree_view,
                                           GtkTreeIter *iter,
                                           GtkTreePath *path);
  void (* row_expanded) (GtkTreeView *tree_view,
                                           GtkTreeIter *iter,
                                           GtkTreePath *path);
  void (* row_collapsed) (GtkTreeView *tree_view,
                                           GtkTreeIter *iter,
                                           GtkTreePath *path);
  void (* columns_changed) (GtkTreeView *tree_view);
  void (* cursor_changed) (GtkTreeView *tree_view);


  gboolean (* move_cursor) (GtkTreeView *tree_view,
                                           GtkMovementStep step,
                                           gint count);
  gboolean (* select_all) (GtkTreeView *tree_view);
  gboolean (* unselect_all) (GtkTreeView *tree_view);
  gboolean (* select_cursor_row) (GtkTreeView *tree_view,
                                           gboolean start_editing);
  gboolean (* toggle_cursor_row) (GtkTreeView *tree_view);
  gboolean (* expand_collapse_cursor_row) (GtkTreeView *tree_view,
                                           gboolean logical,
                                           gboolean expand,
                                           gboolean open_all);
  gboolean (* select_cursor_parent) (GtkTreeView *tree_view);
  gboolean (* start_interactive_search) (GtkTreeView *tree_view);


  void (*_gtk_reserved0) (void);
  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


typedef gboolean (* GtkTreeViewColumnDropFunc) (GtkTreeView *tree_view,
                                                GtkTreeViewColumn *column,
                                                GtkTreeViewColumn *prev_column,
                                                GtkTreeViewColumn *next_column,
                                                gpointer data);
typedef void (* GtkTreeViewMappingFunc) (GtkTreeView *tree_view,
                                                GtkTreePath *path,
                                                gpointer user_data);
typedef gboolean (*GtkTreeViewSearchEqualFunc) (GtkTreeModel *model,
                                                gint column,
                                                const gchar *key,
                                                GtkTreeIter *iter,
                                                gpointer search_data);



GType gtk_tree_view_get_type (void);
GtkWidget *gtk_tree_view_new (void);
GtkWidget *gtk_tree_view_new_with_model (GtkTreeModel *model);


GtkTreeModel *gtk_tree_view_get_model (GtkTreeView *tree_view);
void gtk_tree_view_set_model (GtkTreeView *tree_view,
                                                                    GtkTreeModel *model);
GtkTreeSelection *gtk_tree_view_get_selection (GtkTreeView *tree_view);
GtkAdjustment *gtk_tree_view_get_hadjustment (GtkTreeView *tree_view);
void gtk_tree_view_set_hadjustment (GtkTreeView *tree_view,
                                                                    GtkAdjustment *adjustment);
GtkAdjustment *gtk_tree_view_get_vadjustment (GtkTreeView *tree_view);
void gtk_tree_view_set_vadjustment (GtkTreeView *tree_view,
                                                                    GtkAdjustment *adjustment);
gboolean gtk_tree_view_get_headers_visible (GtkTreeView *tree_view);
void gtk_tree_view_set_headers_visible (GtkTreeView *tree_view,
                                                                    gboolean headers_visible);
void gtk_tree_view_columns_autosize (GtkTreeView *tree_view);
void gtk_tree_view_set_headers_clickable (GtkTreeView *tree_view,
                                                                    gboolean setting);
void gtk_tree_view_set_rules_hint (GtkTreeView *tree_view,
                                                                    gboolean setting);
gboolean gtk_tree_view_get_rules_hint (GtkTreeView *tree_view);


gint gtk_tree_view_append_column (GtkTreeView *tree_view,
                                                                    GtkTreeViewColumn *column);
gint gtk_tree_view_remove_column (GtkTreeView *tree_view,
                                                                    GtkTreeViewColumn *column);
gint gtk_tree_view_insert_column (GtkTreeView *tree_view,
                                                                    GtkTreeViewColumn *column,
                                                                    gint position);
gint gtk_tree_view_insert_column_with_attributes (GtkTreeView *tree_view,
                                                                    gint position,
                                                                    const gchar *title,
                                                                    GtkCellRenderer *cell,
                                                                    ...);
gint gtk_tree_view_insert_column_with_data_func (GtkTreeView *tree_view,
                                                                    gint position,
                                                                    const gchar *title,
                                                                    GtkCellRenderer *cell,
                                                                    GtkTreeCellDataFunc func,
                                                                    gpointer data,
                                                                    GDestroyNotify dnotify);
GtkTreeViewColumn *gtk_tree_view_get_column (GtkTreeView *tree_view,
                                                                    gint n);
GList *gtk_tree_view_get_columns (GtkTreeView *tree_view);
void gtk_tree_view_move_column_after (GtkTreeView *tree_view,
                                                                    GtkTreeViewColumn *column,
                                                                    GtkTreeViewColumn *base_column);
void gtk_tree_view_set_expander_column (GtkTreeView *tree_view,
                                                                    GtkTreeViewColumn *column);
GtkTreeViewColumn *gtk_tree_view_get_expander_column (GtkTreeView *tree_view);
void gtk_tree_view_set_column_drag_function (GtkTreeView *tree_view,
                                                                    GtkTreeViewColumnDropFunc func,
                                                                    gpointer user_data,
                                                                    GtkDestroyNotify destroy);


void gtk_tree_view_scroll_to_point (GtkTreeView *tree_view,
                                                                    gint tree_x,
                                                                    gint tree_y);
void gtk_tree_view_scroll_to_cell (GtkTreeView *tree_view,
                                                                    GtkTreePath *path,
                                                                    GtkTreeViewColumn *column,
                                                                    gboolean use_align,
                                                                    gfloat row_align,
                                                                    gfloat col_align);
void gtk_tree_view_row_activated (GtkTreeView *tree_view,
                                                                    GtkTreePath *path,
                                                                    GtkTreeViewColumn *column);
void gtk_tree_view_expand_all (GtkTreeView *tree_view);
void gtk_tree_view_collapse_all (GtkTreeView *tree_view);
void gtk_tree_view_expand_to_path (GtkTreeView *tree_view,
                                                                    GtkTreePath *path);
gboolean gtk_tree_view_expand_row (GtkTreeView *tree_view,
                                                                    GtkTreePath *path,
                                                                    gboolean open_all);
gboolean gtk_tree_view_collapse_row (GtkTreeView *tree_view,
                                                                    GtkTreePath *path);
void gtk_tree_view_map_expanded_rows (GtkTreeView *tree_view,
                                                                    GtkTreeViewMappingFunc func,
                                                                    gpointer data);
gboolean gtk_tree_view_row_expanded (GtkTreeView *tree_view,
                                                                    GtkTreePath *path);
void gtk_tree_view_set_reorderable (GtkTreeView *tree_view,
                                                                    gboolean reorderable);
gboolean gtk_tree_view_get_reorderable (GtkTreeView *tree_view);
void gtk_tree_view_set_cursor (GtkTreeView *tree_view,
                                                                    GtkTreePath *path,
                                                                    GtkTreeViewColumn *focus_column,
                                                                    gboolean start_editing);
void gtk_tree_view_set_cursor_on_cell (GtkTreeView *tree_view,
                                                                    GtkTreePath *path,
                                                                    GtkTreeViewColumn *focus_column,
                                                                    GtkCellRenderer *focus_cell,
                                                                    gboolean start_editing);
void gtk_tree_view_get_cursor (GtkTreeView *tree_view,
                                                                    GtkTreePath **path,
                                                                    GtkTreeViewColumn **focus_column);



GdkWindow *gtk_tree_view_get_bin_window (GtkTreeView *tree_view);
gboolean gtk_tree_view_get_path_at_pos (GtkTreeView *tree_view,
                                                                    gint x,
                                                                    gint y,
                                                                    GtkTreePath **path,
                                                                    GtkTreeViewColumn **column,
                                                                    gint *cell_x,
                                                                    gint *cell_y);
void gtk_tree_view_get_cell_area (GtkTreeView *tree_view,
                                                                    GtkTreePath *path,
                                                                    GtkTreeViewColumn *column,
                                                                    GdkRectangle *rect);
void gtk_tree_view_get_background_area (GtkTreeView *tree_view,
                                                                    GtkTreePath *path,
                                                                    GtkTreeViewColumn *column,
                                                                    GdkRectangle *rect);
void gtk_tree_view_get_visible_rect (GtkTreeView *tree_view,
                                                                    GdkRectangle *visible_rect);
void gtk_tree_view_widget_to_tree_coords (GtkTreeView *tree_view,
                                                                    gint wx,
                                                                    gint wy,
                                                                    gint *tx,
                                                                    gint *ty);
void gtk_tree_view_tree_to_widget_coords (GtkTreeView *tree_view,
                                                                    gint tx,
                                                                    gint ty,
                                                                    gint *wx,
                                                                    gint *wy);


void gtk_tree_view_enable_model_drag_source (GtkTreeView *tree_view,
                                                                    GdkModifierType start_button_mask,
                                                                    const GtkTargetEntry *targets,
                                                                    gint n_targets,
                                                                    GdkDragAction actions);
void gtk_tree_view_enable_model_drag_dest (GtkTreeView *tree_view,
                                                                    const GtkTargetEntry *targets,
                                                                    gint n_targets,
                                                                    GdkDragAction actions);
void gtk_tree_view_unset_rows_drag_source (GtkTreeView *tree_view);
void gtk_tree_view_unset_rows_drag_dest (GtkTreeView *tree_view);



void gtk_tree_view_set_drag_dest_row (GtkTreeView *tree_view,
                                                                    GtkTreePath *path,
                                                                    GtkTreeViewDropPosition pos);
void gtk_tree_view_get_drag_dest_row (GtkTreeView *tree_view,
                                                                    GtkTreePath **path,
                                                                    GtkTreeViewDropPosition *pos);
gboolean gtk_tree_view_get_dest_row_at_pos (GtkTreeView *tree_view,
                                                                    gint drag_x,
                                                                    gint drag_y,
                                                                    GtkTreePath **path,
                                                                    GtkTreeViewDropPosition *pos);
GdkPixmap *gtk_tree_view_create_row_drag_icon (GtkTreeView *tree_view,
                                                                    GtkTreePath *path);


void gtk_tree_view_set_enable_search (GtkTreeView *tree_view,
                                                                gboolean enable_search);
gboolean gtk_tree_view_get_enable_search (GtkTreeView *tree_view);
gint gtk_tree_view_get_search_column (GtkTreeView *tree_view);
void gtk_tree_view_set_search_column (GtkTreeView *tree_view,
                                                                gint column);
GtkTreeViewSearchEqualFunc gtk_tree_view_get_search_equal_func (GtkTreeView *tree_view);
void gtk_tree_view_set_search_equal_func (GtkTreeView *tree_view,
                                                                GtkTreeViewSearchEqualFunc search_equal_func,
                                                                gpointer search_user_data,
                                                                GtkDestroyNotify search_destroy);



typedef void (* GtkTreeDestroyCountFunc) (GtkTreeView *tree_view,
                                           GtkTreePath *path,
                                           gint children,
                                           gpointer user_data);
void gtk_tree_view_set_destroy_count_func (GtkTreeView *tree_view,
                                           GtkTreeDestroyCountFunc func,
                                           gpointer data,
                                           GtkDestroyNotify destroy);
# 25 "/usr/include/gtk-2.0/gtk/gtktreeselection.h" 2 3 4
# 37 "/usr/include/gtk-2.0/gtk/gtktreeselection.h" 3 4
typedef gboolean (* GtkTreeSelectionFunc) (GtkTreeSelection *selection,
                                              GtkTreeModel *model,
                                              GtkTreePath *path,
                                              gboolean path_currently_selected,
                                              gpointer data);
typedef void (* GtkTreeSelectionForeachFunc) (GtkTreeModel *model,
                                              GtkTreePath *path,
                                              GtkTreeIter *iter,
                                              gpointer data);

struct _GtkTreeSelection
{
  GObject parent;



  GtkTreeView *tree_view;
  GtkSelectionMode type;
  GtkTreeSelectionFunc user_func;
  gpointer user_data;
  GtkDestroyNotify destroy;
};

struct _GtkTreeSelectionClass
{
  GObjectClass parent_class;

  void (* changed) (GtkTreeSelection *selection);


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_tree_selection_get_type (void);

void gtk_tree_selection_set_mode (GtkTreeSelection *selection,
                                                         GtkSelectionMode type);
GtkSelectionMode gtk_tree_selection_get_mode (GtkTreeSelection *selection);
void gtk_tree_selection_set_select_function (GtkTreeSelection *selection,
                                                         GtkTreeSelectionFunc func,
                                                         gpointer data,
                                                         GtkDestroyNotify destroy);
gpointer gtk_tree_selection_get_user_data (GtkTreeSelection *selection);
GtkTreeView* gtk_tree_selection_get_tree_view (GtkTreeSelection *selection);



gboolean gtk_tree_selection_get_selected (GtkTreeSelection *selection,
                                                         GtkTreeModel **model,
                                                         GtkTreeIter *iter);
GList * gtk_tree_selection_get_selected_rows (GtkTreeSelection *selection,
                                                         GtkTreeModel **model);
gint gtk_tree_selection_count_selected_rows (GtkTreeSelection *selection);
void gtk_tree_selection_selected_foreach (GtkTreeSelection *selection,
                                                         GtkTreeSelectionForeachFunc func,
                                                         gpointer data);
void gtk_tree_selection_select_path (GtkTreeSelection *selection,
                                                         GtkTreePath *path);
void gtk_tree_selection_unselect_path (GtkTreeSelection *selection,
                                                         GtkTreePath *path);
void gtk_tree_selection_select_iter (GtkTreeSelection *selection,
                                                         GtkTreeIter *iter);
void gtk_tree_selection_unselect_iter (GtkTreeSelection *selection,
                                                         GtkTreeIter *iter);
gboolean gtk_tree_selection_path_is_selected (GtkTreeSelection *selection,
                                                         GtkTreePath *path);
gboolean gtk_tree_selection_iter_is_selected (GtkTreeSelection *selection,
                                                         GtkTreeIter *iter);
void gtk_tree_selection_select_all (GtkTreeSelection *selection);
void gtk_tree_selection_unselect_all (GtkTreeSelection *selection);
void gtk_tree_selection_select_range (GtkTreeSelection *selection,
                                                         GtkTreePath *start_path,
                                                         GtkTreePath *end_path);
void gtk_tree_selection_unselect_range (GtkTreeSelection *selection,
                                                         GtkTreePath *start_path,
                                                         GtkTreePath *end_path);
# 147 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtktreestore.h" 1 3 4
# 38 "/usr/include/gtk-2.0/gtk/gtktreestore.h" 3 4
typedef struct _GtkTreeStore GtkTreeStore;
typedef struct _GtkTreeStoreClass GtkTreeStoreClass;

struct _GtkTreeStore
{
  GObject parent;

  gint stamp;
  gpointer root;
  gpointer last;
  gint n_columns;
  gint sort_column_id;
  GList *sort_list;
  GtkSortType order;
  GType *column_headers;
  GtkTreeIterCompareFunc default_sort_func;
  gpointer default_sort_data;
  GtkDestroyNotify default_sort_destroy;
  guint columns_dirty : 1;
};

struct _GtkTreeStoreClass
{
  GObjectClass parent_class;


  void (*_gtk_reserved1) (void);
  void (*_gtk_reserved2) (void);
  void (*_gtk_reserved3) (void);
  void (*_gtk_reserved4) (void);
};


GType gtk_tree_store_get_type (void);
GtkTreeStore *gtk_tree_store_new (gint n_columns,
                                               ...);
GtkTreeStore *gtk_tree_store_newv (gint n_columns,
                                               GType *types);
void gtk_tree_store_set_column_types (GtkTreeStore *tree_store,
                                               gint n_columns,
                                               GType *types);



void gtk_tree_store_set_value (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               gint column,
                                               GValue *value);
void gtk_tree_store_set (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               ...);
void gtk_tree_store_set_valist (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               va_list var_args);
gboolean gtk_tree_store_remove (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter);
void gtk_tree_store_insert (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *parent,
                                               gint position);
void gtk_tree_store_insert_before (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *parent,
                                               GtkTreeIter *sibling);
void gtk_tree_store_insert_after (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *parent,
                                               GtkTreeIter *sibling);
void gtk_tree_store_prepend (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *parent);
void gtk_tree_store_append (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *parent);
gboolean gtk_tree_store_is_ancestor (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *descendant);
gint gtk_tree_store_iter_depth (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter);
void gtk_tree_store_clear (GtkTreeStore *tree_store);
gboolean gtk_tree_store_iter_is_valid (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter);
void gtk_tree_store_reorder (GtkTreeStore *tree_store,
                                               GtkTreeIter *parent,
                                               gint *new_order);
void gtk_tree_store_swap (GtkTreeStore *tree_store,
                                               GtkTreeIter *a,
                                               GtkTreeIter *b);
void gtk_tree_store_move_before (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *position);
void gtk_tree_store_move_after (GtkTreeStore *tree_store,
                                               GtkTreeIter *iter,
                                               GtkTreeIter *position);
# 148 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4




# 1 "/usr/include/gtk-2.0/gtk/gtkvbbox.h" 1 3 4
# 47 "/usr/include/gtk-2.0/gtk/gtkvbbox.h" 3 4
typedef struct _GtkVButtonBox GtkVButtonBox;
typedef struct _GtkVButtonBoxClass GtkVButtonBoxClass;

struct _GtkVButtonBox
{
  GtkButtonBox button_box;
};

struct _GtkVButtonBoxClass
{
  GtkButtonBoxClass parent_class;
};


GType gtk_vbutton_box_get_type (void) ;
GtkWidget *gtk_vbutton_box_new (void);




gint gtk_vbutton_box_get_spacing_default (void);
void gtk_vbutton_box_set_spacing_default (gint spacing);

GtkButtonBoxStyle gtk_vbutton_box_get_layout_default (void);
void gtk_vbutton_box_set_layout_default (GtkButtonBoxStyle layout);
# 153 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkversion.h" 1 3 4
# 154 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkvpaned.h" 1 3 4
# 45 "/usr/include/gtk-2.0/gtk/gtkvpaned.h" 3 4
typedef struct _GtkVPaned GtkVPaned;
typedef struct _GtkVPanedClass GtkVPanedClass;

struct _GtkVPaned
{
  GtkPaned paned;
};

struct _GtkVPanedClass
{
  GtkPanedClass parent_class;
};

GType gtk_vpaned_get_type (void) ;
GtkWidget *gtk_vpaned_new (void);
# 156 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkvruler.h" 1 3 4
# 58 "/usr/include/gtk-2.0/gtk/gtkvruler.h" 3 4
typedef struct _GtkVRuler GtkVRuler;
typedef struct _GtkVRulerClass GtkVRulerClass;

struct _GtkVRuler
{
  GtkRuler ruler;
};

struct _GtkVRulerClass
{
  GtkRulerClass parent_class;
};


GType gtk_vruler_get_type (void) ;
GtkWidget* gtk_vruler_new (void);
# 157 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 1 "/usr/include/gtk-2.0/gtk/gtkvscale.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkvscale.h" 3 4
typedef struct _GtkVScale GtkVScale;
typedef struct _GtkVScaleClass GtkVScaleClass;

struct _GtkVScale
{
  GtkScale scale;
};

struct _GtkVScaleClass
{
  GtkScaleClass parent_class;
};


GType gtk_vscale_get_type (void) ;
GtkWidget* gtk_vscale_new (GtkAdjustment *adjustment);
GtkWidget* gtk_vscale_new_with_range (gdouble min,
                                      gdouble max,
                                      gdouble step);
# 158 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4

# 1 "/usr/include/gtk-2.0/gtk/gtkvseparator.h" 1 3 4
# 48 "/usr/include/gtk-2.0/gtk/gtkvseparator.h" 3 4
typedef struct _GtkVSeparator GtkVSeparator;
typedef struct _GtkVSeparatorClass GtkVSeparatorClass;

struct _GtkVSeparator
{
  GtkSeparator separator;
};

struct _GtkVSeparatorClass
{
  GtkSeparatorClass parent_class;
};


GType gtk_vseparator_get_type (void) ;
GtkWidget* gtk_vseparator_new (void);
# 160 "/usr/include/gtk-2.0/gtk/gtk.h" 2 3 4
# 45 "/usr/include/gtk++/gtktypedefs.hpp" 2 3 4

namespace lgtkpp
{
# 94 "/usr/include/gtk++/gtktypedefs.hpp" 3 4
  typedef gint coord_t;
  typedef guint dim_t;
  typedef gpointer data_t;




  enum orientation
  {
    horizontal,
    vertical
  };


  typedef gfloat range_min;
  typedef gfloat range_max;
  typedef gfloat range_cur;

  typedef guint std_id;

}
# 47 "/usr/include/gtk++/gtkobjects.hpp" 2 3 4

# 1 "/usr/include/c++/3.3/stdexcept" 1 3 4
# 42 "/usr/include/c++/3.3/stdexcept" 3 4
       
# 43 "/usr/include/c++/3.3/stdexcept" 3




namespace std
{





  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual
    ~logic_error() ;



    virtual const char*
    what() const ;
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual
    ~runtime_error() ;



    virtual const char*
    what() const ;
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
  };
}
# 49 "/usr/include/gtk++/gtkobjects.hpp" 2 3 4
# 59 "/usr/include/gtk++/gtkobjects.hpp" 3 4
namespace lgtkpp
{

  typedef unsigned id_signal;
  typedef unsigned mess_type;
# 83 "/usr/include/gtk++/gtkobjects.hpp" 3 4
  class gtk_object {
    typedef gtk_object same;
    typedef gtk_object self;
    typedef GtkObject gtkself;







    gtkself * Object;
    bool DestroyObject;
    bool destroyData;
  protected:
    typedef gtk_object base;
    mutable unsigned indent;
  protected:
    gtk_object() : Object(0),DestroyObject(true),indent(0), destroyData(true)
      {
        ((void) 0);
      }
    gtk_object(gtk_object const &, bool);

    gtk_object (gtkself* anObject);
  public:
    gtk_object(gtk_object const & go) : Object(go.Object), DestroyObject(false), destroyData(true)
      {
        ((void) 0);
      }
    virtual ~gtk_object();
  public:




    operator bool () const {return (Object != ((void *)0));}
    bool operator !() const {return ! operator bool ();}

    bool operator == (self const & o) const {return Object == o.Object;}
    bool operator == (gtkself const * o) const {return Object == o;}
    bool operator != (self const & o) const {return !(*this == o);}
    bool operator != (gtkself const * o) const {return !(*this == o);}

    gtkself const * operator -> () const {((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 127, ((const char *) 0)), 0))); return ((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Object)), ((gtk_object_get_type ()))))));}
    gtkself const & operator * () const {return *operator ->();}
  public:
    gtkself * GetObject () {return ((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Object)), ((gtk_object_get_type ()))))));}
    gtkself const * GetObject() const {return ((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Object)), ((gtk_object_get_type ()))))));}
    self& SetObject (GtkObject * o) {((void) (((Object == ((void *)0)) || (o == ((void *)0))) ? 0 : (__assert_fail ("(Object == ((void *)0)) || (o == ((void *)0))", "/usr/include/gtk++/gtkobjects.hpp", 132, ((const char *) 0)), 0))); Object = o; return *this;}
    bool ToDestroy() {return DestroyObject;}
    self& ToDestroy(bool aDestroy) {DestroyObject = aDestroy; return *this;}
  public:
    gpointer GetData (std::string const & k) {((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 136, ((const char *) 0)), 0))); return gtk_object_get_data (Object,k.c_str());}
    virtual GtkType GetType () const {((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 137, ((const char *) 0)), 0))); return gtk_object_get_type ();}
    gpointer GetUserData () {((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 138, ((const char *) 0)), 0))); return gtk_object_get_user_data (Object);}
    self& RemoveData (std::string const & k) {((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 139, ((const char *) 0)), 0))); gtk_object_remove_data (Object,k.c_str()); return *this;}
    self& SetData (std::string const & k, gpointer d) {((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 140, ((const char *) 0)), 0))); gtk_object_set_data(Object,k.c_str(),d); return *this;}
    self& SetUserData(gpointer d) {((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 141, ((const char *) 0)), 0))); gtk_object_set_user_data(Object,d); return *this;}
    id_signal SignalConnect(std::string const &, GtkSignalFunc, gpointer);
    id_signal SignalConnectObject(std::string const &, GtkSignalFunc, gtk_object &);
    self& SignalDisconnect (id_signal);
  public:
    virtual same* Clone () const = 0;
    void AttachData () {gtk_object_set_data(Object, "this", this);}
    virtual bool Create ();
    virtual self& CreateObject () = 0;
    virtual std::ostream& Print (std::ostream& o) const {return o <<"gtk_object{Object="<<Object<<",DestroyObject="<<DestroyObject<<"}"<<std::endl;}
  };



  typedef gtk_object & r_object;
  typedef gtk_object const & rc_object;
  typedef gtk_object * p_object;
  typedef gtk_object const * pc_object;
# 170 "/usr/include/gtk++/gtkobjects.hpp" 3 4
  inline gtk_object::gtk_object(gtk_object const & AnObject, bool) : indent(0), destroyData(true)
    {
      GtkArg *Args;
      GtkType Type;
      guint NbArgs;

      ((void) 0);


      if (AnObject.GetObject())
        {

          Type = AnObject.GetType();


          Object = (GtkObject *) g_object_new (Type, ((void *)0));


          gtk_object_remove_data (Object, "this");
          gtk_object_set_data (Object, "this", this);
        }
      else
        Object = 0;

      DestroyObject = false;
    }
# 204 "/usr/include/gtk++/gtkobjects.hpp" 3 4
  inline gtk_object::gtk_object (gtkself* anObject) : Object(((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((anObject)), ((gtk_object_get_type ()))))))), DestroyObject(false), indent(0)
    {
      ((void) 0);

      if (gtk_object_get_data(Object,"this") != ((void *)0))
        destroyData = false;
      else
        {
          destroyData = true;
          gtk_object_set_data(Object,"this",this);
        }
    }




  inline gtk_object::~gtk_object ()
    {

      ((void) 0);
      if (Object) {
        if ((((g_type_check_instance_is_a ((GTypeInstance*) ((Object)), ((gtk_object_get_type ())))))))
          {
            if (destroyData)
              gtk_object_remove_data (((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Object)), ((gtk_object_get_type ())))))), "this");
            if (DestroyObject)
              gtk_object_destroy(((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Object)), ((gtk_object_get_type ())))))));
          }
      }
      Object = ((void *)0);
    }
# 263 "/usr/include/gtk++/gtkobjects.hpp" 3 4
  inline bool gtk_object::Create () {
    ((void) ((Object == ((void *)0)) ? 0 : (__assert_fail ("Object == ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 264, ((const char *) 0)), 0)));

    CreateObject ();
    if (!Object)
      return false;

    ::gtk_object_set_data (Object, "this", this);
    return true;
  }




  inline gtk_object& gtk_object::SignalDisconnect (id_signal aSignal)
    {
      ((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 279, ((const char *) 0)), 0)));
      ::g_signal_handler_disconnect ((((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Object)), ((gtk_object_get_type ()))))))), (aSignal));
      return *this;
    }


  inline id_signal gtk_object::SignalConnect(std::string const & Signal, GtkSignalFunc Callback, gpointer Data)
    {
      ((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 287, ((const char *) 0)), 0)));
      return ::gtk_signal_connect_full ((((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Object)), ((gtk_object_get_type ()))))))), (Signal.c_str()), (Callback), 0, (Data), 0, 0, 0);
    }

  inline id_signal gtk_object::SignalConnectObject(std::string const & Signal, GtkSignalFunc Callback, gtk_object & Cible)
    {
      ((void) ((Object != ((void *)0)) ? 0 : (__assert_fail ("Object != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 293, ((const char *) 0)), 0)));
      ((void) ((Cible.GetObject () != ((void *)0)) ? 0 : (__assert_fail ("Cible.GetObject () != ((void *)0)", "/usr/include/gtk++/gtkobjects.hpp", 294, ((const char *) 0)), 0)));
      return ::gtk_signal_connect_full ((((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Object)), ((gtk_object_get_type ()))))))), (Signal.c_str()), (Callback), 0, (Cible.GetObject()), 0, 1, 0);
    }

  inline std::ostream& operator << (std::ostream& o, lgtkpp::gtk_object const& go)
    {
      return go.Print(o);
    }

}
# 44 "/usr/include/gtk++/gtkwidgets.hpp" 2 3 4
# 53 "/usr/include/gtk++/gtkwidgets.hpp" 3 4
namespace lgtkpp
{

typedef gint widget_siz;
typedef gint widget_pos;
typedef gint event_id;
typedef gint screen_pos;

class gtk_widget : public gtk_object {
  typedef gtk_widget self;
  typedef gtk_widget same;
  typedef GtkWidget gtkself;
  typedef gtk_object ant;
protected:
  typedef gtk_widget widget_base;

private:
  bool Loop;
  void * Returned;

protected:
  gtk_widget (gtk_widget const & gw, bool): ant (gw,true)
    {
      ((void) 0);
    }
public:
  gtk_widget ();
  gtk_widget (GtkWidget * aObject) : ant ((GtkObject*)(aObject))
    {
      ((void) 0);
    }
  gtk_widget (gtk_widget const &);
  virtual ~gtk_widget ()
    {
      ((void) 0);
    }
public:

  gtkself const * operator -> () const
    {
      ((void) 0);
      ((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkwidgets.hpp", 94, ((const char *) 0)), 0)));
      return ((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ()))))));
    }
  gtkself * operator -> ()
    {
      ((void) 0);
      ((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkwidgets.hpp", 100, ((const char *) 0)), 0)));
      return ((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ()))))));
    }
  gtkself const & operator * () const {return *operator ->();}
  gtkself & operator * () {return *operator ->();}
public:
  virtual GtkType GetType () const { return ::gtk_widget_get_type();}

  std::string GetName();
  self& SetName (std::string const & aName);

  self& SetEvents (event_id aEvent);
  self& AddEvents (event_id aEvent);
  event_id GetEvents ();
  self& GetPointer (screen_pos& aX, screen_pos& aY);







  self& Unparent ();
  self& SetParent (gtk_widget& aParent);
  self& Reparent (gtk_widget& aNouveauParent);

  same GetToplevel ();
  bool IsAncestor (gtk_widget & aAncetre);
  self& SetSensitive (bool aSensitif);
  self& SetUposition (widget_pos aX, widget_pos aY);
  self& SetUsize (widget_siz aWidth, widget_siz aHeight);






  self& Destroy ();

  self& HideOnDelete ();

  self& Realize ();
  self& Unrealize ();
  self& Map ();
  self& Unmap ();
  self& Show ();
  self& ShowNow ();
  self& Hide ();
  self& ShowAll ();
  self& HideAll ();
  self& QueueDraw ();
  self& QueueDrawArea (widget_pos aX, widget_pos aY, widget_siz aWidth, widget_siz aHeight);
  self& QueueClear ();
  self& GrabFocus ();
  self& GrabDefault ();

public:
  self& SetFlags (GtkWidgetFlags);
  self& UnsetFlags (GtkWidgetFlags);
public:
  virtual same* Clone () const {return new gtk_widget (*this);}
  virtual bool Create ();
  virtual self& CreateObject() {return *this;}
  virtual std::ostream& Print (std::ostream& o) const {ant::Print(o)<<"gtk_widget{}"<<std::endl; return o;}
  virtual self& SetupWidget ()
    {
      ((void) 0);
      return *this;
    }
  virtual void BreakWait (void *);
  virtual void * Wait () ;
public:
};

typedef gtk_widget & r_widget;
typedef gtk_widget const & rc_widget;
typedef gtk_widget * p_widget;
typedef gtk_widget const * pc_widget;

inline gtk_widget::gtk_widget () : ant()
{
  ((void) 0);
}

inline gtk_widget::gtk_widget (gtk_widget const & w) : ant(w)
{
  ((void) 0);
}

inline void gtk_widget::BreakWait(void * rs)
{
  Returned = rs;
  Loop = false;
}





inline gtk_widget& gtk_widget::AddEvents (event_id aEvents)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 201, ((const char *) 0)), 0)));
  ::gtk_widget_add_events (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))),aEvents);
  return *this;
}





inline bool gtk_widget::Create ()
{
  ((void) ((!*this) ? 0 : (__assert_fail ("!*this", "/usr/include/gtk++/gtkwidgets.hpp", 212, ((const char *) 0)), 0)));

  bool Result = ant::Create ();
  ((void) 0);
  if (Result)
    SetupWidget ();
  return Result;
}





inline gtk_widget& gtk_widget::Destroy ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 227, ((const char *) 0)), 0)));
  ::gtk_widget_destroy (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  SetObject(((void *)0));
  return *this;
}




inline event_id gtk_widget::GetEvents ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 238, ((const char *) 0)), 0)));
  return ::gtk_widget_get_events (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
}





inline gtk_widget& gtk_widget::GetPointer (widget_pos& aX, widget_pos& aY)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 248, ((const char *) 0)), 0)));
  ::gtk_widget_get_pointer (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))), &aX, &aY);
  return *this;
}





inline std::string gtk_widget::GetName()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 259, ((const char *) 0)), 0)));
  return ::gtk_widget_get_name (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
}


inline gtk_widget gtk_widget::GetToplevel ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 266, ((const char *) 0)), 0)));
  return ::gtk_widget_get_toplevel(((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
}




inline gtk_widget& gtk_widget::GrabDefault()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 275, ((const char *) 0)), 0)));
  ::gtk_widget_grab_default(((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::GrabFocus ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 286, ((const char *) 0)), 0)));
  ::gtk_widget_grab_focus (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::Hide ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 297, ((const char *) 0)), 0)));
  ::gtk_widget_hide (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::HideAll ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 308, ((const char *) 0)), 0)));
  ::gtk_widget_hide_all (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::HideOnDelete ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 319, ((const char *) 0)), 0)));
  ::gtk_widget_hide_on_delete (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline bool gtk_widget::IsAncestor (gtk_widget & aAncetre)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 330, ((const char *) 0)), 0)));
  ((void) ((aAncetre) ? 0 : (__assert_fail ("aAncetre", "/usr/include/gtk++/gtkwidgets.hpp", 331, ((const char *) 0)), 0)));
  ::gtk_widget_is_ancestor (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))), ((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((aAncetre.GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::Map ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 342, ((const char *) 0)), 0)));
  ::gtk_widget_map (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::Unmap ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 353, ((const char *) 0)), 0)));
  ::gtk_widget_unmap (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::QueueClear()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 364, ((const char *) 0)), 0)));
  ::gtk_widget_queue_clear (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::QueueDraw ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 375, ((const char *) 0)), 0)));
  ::gtk_widget_queue_draw (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::QueueDrawArea (widget_pos aX, widget_pos aY, widget_siz aWidth, widget_siz aHeight)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 386, ((const char *) 0)), 0)));
  ::gtk_widget_queue_draw_area (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))),aX,aY,aWidth,aHeight);
  return *this;
}





inline gtk_widget& gtk_widget::Realize ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 397, ((const char *) 0)), 0)));
  ::gtk_widget_realize (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::Reparent (gtk_widget& aNouveauParent)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 408, ((const char *) 0)), 0)));
  ((void) ((aNouveauParent) ? 0 : (__assert_fail ("aNouveauParent", "/usr/include/gtk++/gtkwidgets.hpp", 409, ((const char *) 0)), 0)));
  ::gtk_widget_reparent (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))),((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((aNouveauParent.GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::SetEvents (event_id aEvents)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 420, ((const char *) 0)), 0)));
  ::gtk_widget_set_events (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))),aEvents);
  return *this;
}





inline gtk_widget& gtk_widget::SetFlags(GtkWidgetFlags aFlag)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 431, ((const char *) 0)), 0)));
  do{ (((((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))))), ((gtk_object_get_type ()))))))->flags)) |= (aFlag)); }while (0);
  return *this;
}





inline gtk_widget& gtk_widget::SetName (std::string const & aName)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 442, ((const char *) 0)), 0)));
  ::gtk_widget_set_name (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))),aName.c_str());
  return *this;
}





inline gtk_widget& gtk_widget::SetParent (gtk_widget& aParent)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 453, ((const char *) 0)), 0)));
  ((void) ((aParent) ? 0 : (__assert_fail ("aParent", "/usr/include/gtk++/gtkwidgets.hpp", 454, ((const char *) 0)), 0)));
  ::gtk_widget_set_parent (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))), ((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((aParent.GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::SetSensitive (bool aSensitif)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 465, ((const char *) 0)), 0)));
  ::gtk_widget_set_sensitive(((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))), aSensitif);
  return *this;
}





inline gtk_widget& gtk_widget::Show ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 476, ((const char *) 0)), 0)));
  ::gtk_widget_show (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::ShowAll ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 487, ((const char *) 0)), 0)));
  ::gtk_widget_show_all (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::ShowNow ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 498, ((const char *) 0)), 0)));
  ::gtk_widget_show_now (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::Unparent ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 509, ((const char *) 0)), 0)));
  ::gtk_widget_unparent (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::Unrealize ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 520, ((const char *) 0)), 0)));
  ::gtk_widget_unrealize (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_widget& gtk_widget::UnsetFlags(GtkWidgetFlags aFlag)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 531, ((const char *) 0)), 0)));
  do{ (((((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))))), ((gtk_object_get_type ()))))))->flags)) &= ~(aFlag)); }while (0);
  return *this;
}




inline gtk_widget& gtk_widget::SetUposition (widget_pos aX, widget_pos aY)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 541, ((const char *) 0)), 0)));
  ::gtk_widget_set_uposition(((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))),aX,aY);
  return *this;
}





inline gtk_widget& gtk_widget::SetUsize (widget_siz aWidth, widget_siz aHeight)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwidgets.hpp", 552, ((const char *) 0)), 0)));
  ::gtk_widget_set_usize(((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_widget_get_type ())))))),aWidth,aHeight);
  return *this;
}


inline void * gtk_widget::Wait ()
{
  Loop = true;
  while (Loop)
    {
      if (::gtk_events_pending())
        ::gtk_main_iteration ();
    }
  return Returned;
}

}
# 50 "/usr/include/gtk++/gtkcontainers.hpp" 2 3 4
# 59 "/usr/include/gtk++/gtkcontainers.hpp" 3 4
namespace lgtkpp
{
# 84 "/usr/include/gtk++/gtkcontainers.hpp" 3 4
  class gtk_container : public gtk_widget
  {
    typedef gtk_container self;
    typedef gtk_container same;
    typedef GtkContainer gtkself;
    typedef gtk_widget ant;

    bool Special;

  protected:

    gtk_container () : ant (),Special(false)
      {
        ((void) 0);
      }

    gtk_container (gtkself* Container) : ant (((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((Container)), ((gtk_widget_get_type ()))))))),Special(false)
      {
        ((void) 0);
      }

    gtk_container (self const & c, bool) : ant (c,true)
      {
        ((void) 0);
      }
  public:

    gtk_container (self const & c);

    inline virtual ~gtk_container ();
  public:


    gtkself const * operator -> () const {((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkcontainers.hpp", 117, ((const char *) 0)), 0))); return ((((GtkContainer*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_container_get_type ()))))));}

    gtkself const & operator * () const {return *operator ->();}


    gtk_container& operator += (gtk_widget& w) {Add(w); return *this;}

    gtk_container& operator -= (gtk_widget& w) {Remove(w); return *this;}

    inline gtk_widget & operator [] (int p);

    inline gtk_widget const & operator [] (int p) const;
  public:

    self& Add (gtk_widget&);


    self& Remove (gtk_widget&);

    self& SetBorderWidth (guint);
  public:

    gtk_container & SetSpecial (bool aSpecial) {Special = aSpecial; return *this;}

    virtual std::ostream & Print (std::ostream & o) const {return o <<"gtk_container{"<<ant::Print(o)<<"Special="<<Special<<"}";}

    size_t Length() const;
  };


  typedef gtk_container & r_container;
  typedef gtk_container const & rc_container;
  typedef gtk_container * p_container;
  typedef gtk_container const * pc_container;






  inline gtk_container::gtk_container (self const & c) : ant (c), Special(c.Special)
    {
      GList *Children;
      GtkWidget *Widget;
      gtk_widget *MyWidget;
      size_t nbElements;
      int Index;

      ((void) 0);

      if (Special)
        return;


      if (c.GetObject() != ((void *)0))
        {

          Children = gtk_container_get_children(const_cast<GtkContainer*>(((((GtkContainer*) g_type_check_instance_cast ((GTypeInstance*) ((c.GetObject())), ((gtk_container_get_type ()))))))));
          nbElements = g_list_length (Children);

          for (Index = 0; Index < nbElements; ++nbElements)
            {

              Widget = ((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((g_list_nth(Children,nbElements)->data)), ((gtk_widget_get_type ()))))));
              if (Widget != ((void *)0))
                {
                  MyWidget = (gtk_widget *) gtk_object_get_data (((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Widget)), ((gtk_object_get_type ())))))),"this");
                  if (MyWidget != ((void *)0))
                    Add(*dynamic_cast<gtk_widget *>(MyWidget->Clone()));
                }
            }
        }
    }
# 198 "/usr/include/gtk++/gtkcontainers.hpp" 3 4
  gtk_container::~gtk_container ()
    {
      GList *Children;
      GtkWidget *Widget;
      gtk_widget *MyWidget;
      size_t nbElements;
      int Index;

      ((void) 0);

      if (Special)
        return;

      if (!ToDestroy())
        return;
# 232 "/usr/include/gtk++/gtkcontainers.hpp" 3 4
    }
# 242 "/usr/include/gtk++/gtkcontainers.hpp" 3 4
  gtk_widget const & gtk_container::operator [] (int p) const
    {
      GList *Children;
      GtkWidget *Widget;
      gtk_widget *MyWidget;

      ((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkcontainers.hpp", 248, ((const char *) 0)), 0)));

      Children = gtk_container_get_children(const_cast<GtkContainer*>(((((GtkContainer*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_container_get_type ()))))))));
      if (g_list_length (Children) <= p)
        {
          std::out_of_range Error("Argument depasse");
          throw Error;
        }
      Widget = ((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((g_list_nth(Children,p)->data)), ((gtk_widget_get_type ()))))));
      if (Widget != ((void *)0))
        {
          MyWidget = (gtk_widget *) gtk_object_get_data (((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Widget)), ((gtk_object_get_type ())))))),"this");





          ((void) ((MyWidget != ((void *)0)) ? 0 : (__assert_fail ("MyWidget != ((void *)0)", "/usr/include/gtk++/gtkcontainers.hpp", 265, ((const char *) 0)), 0)));


        }
      else
        {
          ((void) ((0) ? 0 : (__assert_fail ("0", "/usr/include/gtk++/gtkcontainers.hpp", 271, ((const char *) 0)), 0)));

        }

      return *MyWidget;
    }
# 285 "/usr/include/gtk++/gtkcontainers.hpp" 3 4
  gtk_widget & gtk_container::operator [] (int p)
    {
      GList *Children;
      GtkWidget *Widget;
      gtk_widget *MyWidget;

      ((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkcontainers.hpp", 291, ((const char *) 0)), 0)));

      Children = gtk_container_get_children(((((GtkContainer*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_container_get_type ())))))));
      if (g_list_length (Children) <= p)
        {
          std::out_of_range Error ("Argument depasse");
          ;
        }
      Widget = ((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((g_list_nth(Children,p)->data)), ((gtk_widget_get_type ()))))));
      if (Widget != ((void *)0))
        {
          MyWidget = (gtk_widget *) gtk_object_get_data (((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Widget)), ((gtk_object_get_type ())))))),"this");




          ((void) ((MyWidget != ((void *)0)) ? 0 : (__assert_fail ("MyWidget != ((void *)0)", "/usr/include/gtk++/gtkcontainers.hpp", 307, ((const char *) 0)), 0)));


        }
      else
        {
          ((void) ((0) ? 0 : (__assert_fail ("0", "/usr/include/gtk++/gtkcontainers.hpp", 313, ((const char *) 0)), 0)));

        }

      return *MyWidget;
    }
# 329 "/usr/include/gtk++/gtkcontainers.hpp" 3 4
  inline gtk_container& gtk_container::Add (gtk_widget& aWidget)
    {
      ((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkcontainers.hpp", 331, ((const char *) 0)), 0)));
      if (!aWidget.GetObject ())
        aWidget.Create ();
      ::gtk_container_add (((((GtkContainer*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_container_get_type ())))))), ((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((aWidget.GetObject())), ((gtk_widget_get_type ())))))));
      return *this;
    }






  inline size_t gtk_container::Length() const
    {
      GList *Children;

      if (GetObject() == ((void *)0))
        return 0;

      Children = gtk_container_get_children(const_cast<GtkContainer*>(((((GtkContainer*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_container_get_type ()))))))));
      return ::g_list_length(Children);
    }






  inline gtk_container& gtk_container::Remove (gtk_widget& aWidget)
    {
      ((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkcontainers.hpp", 361, ((const char *) 0)), 0)));
      ::gtk_container_remove (((((GtkContainer*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_container_get_type ())))))), ((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((aWidget.GetObject())), ((gtk_widget_get_type ())))))));
      return *this;
    }
# 373 "/usr/include/gtk++/gtkcontainers.hpp" 3 4
  inline gtk_container& gtk_container::SetBorderWidth (guint aLargeur)
    {
      ((void) ((GetObject () != ((void *)0)) ? 0 : (__assert_fail ("GetObject () != ((void *)0)", "/usr/include/gtk++/gtkcontainers.hpp", 375, ((const char *) 0)), 0)));
      ::gtk_container_set_border_width (((((GtkContainer*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_container_get_type ())))))), aLargeur);
      return *this;
    }

}
# 52 "/usr/include/gtk++/gtkbins.hpp" 2 3 4
# 61 "/usr/include/gtk++/gtkbins.hpp" 3 4
namespace lgtkpp
{
# 75 "/usr/include/gtk++/gtkbins.hpp" 3 4
  class gtk_bin : public gtk_container
  {
    typedef gtk_bin self;
    typedef gtk_bin same;
    typedef GtkBin gtkself;
    typedef gtk_container ant;

  protected:

    gtk_bin () : ant () {SetSpecial(true);};

    gtk_bin (GtkBin* b) : ant(((((GtkContainer*) g_type_check_instance_cast ((GTypeInstance*) ((b)), ((gtk_container_get_type ()))))))) {};

    gtk_bin (gtk_bin const & gb) : ant(gb) {}

    gtk_bin (gtk_bin const & gb, bool) : ant (gb,false) {}

    inline virtual ~gtk_bin ();
  public:


    gtkself const * operator -> () const
      {
        ((void) 0);
        ((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkbins.hpp", 99, ((const char *) 0)), 0)));
        return ((((GtkBin*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_bin_get_type ()))))));
      }

    gtkself const & operator * () const {return *operator ->();}

    gtkself * operator -> ()
      {
        ((void) 0);
        ((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkbins.hpp", 108, ((const char *) 0)), 0)));
        return ((((GtkBin*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_bin_get_type ()))))));
      }

    gtkself & operator * () {return *operator ->();}
  public:

    gtk_widget * GetChild ();

    virtual std::ostream & Print (std::ostream & o) const {return o <<"gtk_bin{"<<ant::Print(o)<<"}";}
  };


  typedef gtk_bin & r_bin;
  typedef gtk_bin const & rc_bin;
  typedef gtk_bin * p_bin;
  typedef gtk_bin const * pc_bin;




  inline gtk_bin::~gtk_bin ()
    {
# 140 "/usr/include/gtk++/gtkbins.hpp" 3 4
    }




  inline gtk_widget* gtk_bin::GetChild () {
    GtkWidget *Widget;
    gtk_widget *MyWidget;


    Widget=((((GtkBin*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_bin_get_type ()))))))->child;
    if (Widget == 0)
      return 0;

    MyWidget = (gtk_widget *) ::gtk_object_get_data (((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((Widget)), ((gtk_object_get_type ())))))),"this");
    return MyWidget;
  }
# 172 "/usr/include/gtk++/gtkbins.hpp" 3 4
}
# 35 "/usr/include/gtk++/gtkwindows.hpp" 2 3 4
# 44 "/usr/include/gtk++/gtkwindows.hpp" 3 4
namespace lgtkpp
{

class gtk_window : public gtk_bin {
  typedef gtk_window self;
  typedef gtk_window same;
  typedef GtkWindow gtkself;
  typedef gtk_bin ant;


  GtkWindowType Type;
public:
  gtk_window (GtkWindowType=GTK_WINDOW_TOPLEVEL, bool=true);
  gtk_window (const self& gw) : ant(gw), Type(gw.Type) {};
  gtk_window (const self& gw,bool) : ant(gw,true), Type(gw.Type) {};
  gtk_window (gtkself * gw) : ant(((((GtkBin*) g_type_check_instance_cast ((GTypeInstance*) ((gw)), ((gtk_bin_get_type ()))))))) {}
  virtual ~gtk_window() {};
private:
  gtk_window operator = (const self&) {};
public:

  gtkself const * operator -> () const {((void) ((GetObject() != ((void *)0)) ? 0 : (__assert_fail ("GetObject() != ((void *)0)", "/usr/include/gtk++/gtkwindows.hpp", 65, ((const char *) 0)), 0))); return ((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ()))))));}
  gtkself const & operator * () const {return *operator ->();} public:
public:
  virtual GtkType GetType() const {return gtk_widget_get_type();}
  self& SetTitle (std::string const & aTitre);
  self& SetWmclass (std::string const & aNom, std::string const & aClasse);
  self& SetPolicy (bool aAllowShrink, bool aAllowGrow, bool aAutoShrink);
  self& SetPosition (GtkWindowPosition);
  self& SetTransientFor (gtk_window & aDessous);
  self& SetTransientOther (gtk_window & aDessus);
  self& SetModal (bool );
  bool ActivateFocus ();
  bool ActivateDefault ();
  self& SetFocus (gtk_widget &);
public:
  virtual same* Clone() const;
  virtual self& CreateObject ();
  virtual self& SetupWidget () {return *this;};
  virtual std::ostream& Print (std::ostream& o) const {return o<<"gtk_window{"<<ant::Print(o)<<"}";}
};

typedef gtk_window & r_window;
typedef gtk_window const & rc_window;
typedef gtk_window * p_window;
typedef gtk_window const * pc_window;
# 107 "/usr/include/gtk++/gtkwindows.hpp" 3 4
inline gtk_window::gtk_window(GtkWindowType aType, bool Immediate) : ant ()
{
  Type = aType;
  if (Immediate)
    Create();
}






inline bool gtk_window::ActivateFocus ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 121, ((const char *) 0)), 0)));
  return gtk_window_activate_focus (((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ()))))))) != 0;
}






inline bool gtk_window::ActivateDefault ()
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 132, ((const char *) 0)), 0)));
  return gtk_window_activate_default (((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ()))))))) != 0;
}





inline gtk_window::same* gtk_window::Clone() const
{
  return new gtk_window(*this, true);
}






inline gtk_window::self& gtk_window::CreateObject()
{
  ((void) ((!*this) ? 0 : (__assert_fail ("!*this", "/usr/include/gtk++/gtkwindows.hpp", 152, ((const char *) 0)), 0)));
  SetObject(((((GtkObject*) g_type_check_instance_cast ((GTypeInstance*) ((::gtk_window_new (Type))), ((gtk_object_get_type ())))))));
  return *this;
}







inline gtk_window& gtk_window::SetFocus (gtk_widget & aFocus)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 165, ((const char *) 0)), 0)));
  ((void) ((aFocus) ? 0 : (__assert_fail ("aFocus", "/usr/include/gtk++/gtkwindows.hpp", 166, ((const char *) 0)), 0)));
  ::gtk_window_set_focus (((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ())))))),((((GtkWidget*) g_type_check_instance_cast ((GTypeInstance*) ((aFocus.GetObject())), ((gtk_widget_get_type ())))))));
  return *this;
}





inline gtk_window& gtk_window::SetModal (bool aModale)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 177, ((const char *) 0)), 0)));
  ::gtk_window_set_modal (((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ())))))), aModale);
  return *this;
}
# 192 "/usr/include/gtk++/gtkwindows.hpp" 3 4
inline gtk_window& gtk_window::SetPolicy (bool aAllowShrink, bool aAllowGrow, bool aAutoShrink)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 194, ((const char *) 0)), 0)));
  ::gtk_window_set_policy (((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ())))))),aAllowShrink, aAllowGrow, aAutoShrink);
  return *this;
}







inline gtk_window& gtk_window::SetPosition (GtkWindowPosition aPosition)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 207, ((const char *) 0)), 0)));

  ::gtk_window_set_position (((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ())))))), aPosition);
  return *this;
}







inline gtk_window& gtk_window::SetTitle (std::string const & aTitre)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 221, ((const char *) 0)), 0)));
  ::gtk_window_set_title(((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ())))))),aTitre.c_str());
  return *this;
}







inline gtk_window& gtk_window::SetTransientFor (gtk_window & aDessous)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 234, ((const char *) 0)), 0)));
  ((void) ((aDessous) ? 0 : (__assert_fail ("aDessous", "/usr/include/gtk++/gtkwindows.hpp", 235, ((const char *) 0)), 0)));
  ::gtk_window_set_transient_for (((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ())))))), ((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((aDessous.GetObject())), ((gtk_window_get_type ())))))));
  return *this;
}







inline gtk_window& gtk_window::SetTransientOther (gtk_window & aDessus)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 248, ((const char *) 0)), 0)));
  ((void) ((aDessus) ? 0 : (__assert_fail ("aDessus", "/usr/include/gtk++/gtkwindows.hpp", 249, ((const char *) 0)), 0)));
  ::gtk_window_set_transient_for (((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((aDessus.GetObject())), ((gtk_window_get_type ())))))), ((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ())))))));
  return *this;
}
# 261 "/usr/include/gtk++/gtkwindows.hpp" 3 4
inline gtk_window& gtk_window::SetWmclass (std::string const & aNom, std::string const & aClasse)
{
  ((void) ((*this) ? 0 : (__assert_fail ("*this", "/usr/include/gtk++/gtkwindows.hpp", 263, ((const char *) 0)), 0)));

  ::gtk_window_set_wmclass (((((GtkWindow*) g_type_check_instance_cast ((GTypeInstance*) ((GetObject())), ((gtk_window_get_type ())))))), aNom.c_str(), aClasse.c_str());
  return *this;
}

}
# 2 "<stdin>" 2

using namespace lgtkpp;

int main(int argc, char *argv[]) {
        gtk_window* window;
	window->
